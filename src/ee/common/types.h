/* This file is part of VoltDB.
 * Copyright (C) 2008-2019 VoltDB Inc.
 *
 * This file contains original code and/or modifications of original code.
 * Any modifications made by VoltDB Inc. are licensed under the following
 * terms and conditions:
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with VoltDB.  If not, see <http://www.gnu.org/licenses/>.
 */
/* Copyright (C) 2008 by H-Store Project
 * Brown University
 * Massachusetts Institute of Technology
 * Yale University
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT
 * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */
#pragma once

#include <string>
#include <stdint.h>
namespace voltdb {

// forward declare
class NValue;

// ------------------------------------------------------------------
// Value Types
// This file defines all the types that we will support
// We do not allow for user-defined types, nor do we try to do anything dyanmic
//
// N.B. Oridnals MUST equal corresponding types in Java
// ------------------------------------------------------------------
enum class ValueType {
    tINVALID      = 0,    // a column should never be this type!
    tNULL         = 1,    // and they should never be this either!
    NumericDiagnostics = 2, // Java planner only. Not used in EE.

    //
    // Column Types
    //
    tTINYINT      = 3,    // 1 byte int
    tSMALLINT     = 4,    // 2 bytes int
    tINTEGER      = 5,    // 4 bytes int
    tBIGINT       = 6,    // 8 bytes int
    tDOUBLE       = 8,    // 8 bytes floating, called FLOAT in java
    tVARCHAR      = 9,    // variable length chars
    tTIMESTAMP    = 11,   // 8 bytes int
    tDECIMAL      = 22,   // decimal(p,s)
    tBOOLEAN      = 23,   // used internally by the planner and EE. Not a valid user data type
    tADDRESS      = 24,   // generated by certain expression code in the EE
    tVARBINARY    = 25,   // variable length bytes
    tPOINT        = 26,   // a geospatial point (lat/long)
    tGEOGRAPHY    = 27,   // a geospatial object (polygon, etc)
    tARRAY       = -99,   // an array of elements whose type is indicated elsewhere.
};

// ------------------------------------------------------------------
// Execution Result Codes
// ------------------------------------------------------------------
enum ResultType {
    RESULT_NOOP         = 1,
    RESULT_OK           = 2,
    RESULT_ABORTED      = 3,
    RESULT_ERROR        = 4,
    RESULT_UNKNOWN      = 5
};

// ------------------------------------------------------------------
// Payload Message Type
// ------------------------------------------------------------------
enum PayloadType {
    PAYLOAD_TYPE_INVALID            = 0,
    PAYLOAD_TYPE_CLIENT_REQUEST     = 1,
    PAYLOAD_TYPE_CLIENT_RESPONSE    = 2,
    PAYLOAD_TYPE_EXECUTE_REQUEST    = 3,
    PAYLOAD_TYPE_EXECUTE_RESPONSE   = 4,
};

// ------------------------------------------------------------------
// Query Type
// ------------------------------------------------------------------
enum QueryType {
    QUERY_TYPE_INVALID      = 0, // used for parsing
    QUERY_TYPE_NOOP         = 1,
    QUERY_TYPE_SELECT       = 2,
    QUERY_TYPE_INSERT       = 3,
    QUERY_TYPE_UPDATE       = 4,
    QUERY_TYPE_DELETE       = 5
};

// ------------------------------------------------------------------
// Join Type
// ------------------------------------------------------------------
enum JoinType {
    JOIN_TYPE_INVALID       = 0,
    JOIN_TYPE_INNER         = 1,
    JOIN_TYPE_LEFT          = 2,
    JOIN_TYPE_FULL          = 3,
    JOIN_TYPE_RIGHT         = 4,
};

// ------------------------------------------------------------------
// Constraint Type
// ------------------------------------------------------------------
enum ConstraintType {
    CONSTRAINT_TYPE_FOREIGN_KEY    = 0,
    CONSTRAINT_TYPE_MAIN           = 1,
    CONSTRAINT_TYPE_UNIQUE         = 2,
    CONSTRAINT_TYPE_CHECK          = 3,
    CONSTRAINT_TYPE_PRIMARY_KEY    = 4,
    CONSTRAINT_TYPE_NOT_NULL       = 5,
    CONSTRAINT_TYPE_PARTITIONING   = 6,
    CONSTRAINT_TYPE_LIMIT          = 7,                    // org.voltdb.types.ConstraintType.java
    CONSTRAINT_TYPE_NUMERIC        = 8,
};

// ------------------------------------------------------------------
// Sort Direction Type
// ------------------------------------------------------------------
enum SortDirectionType {
    SORT_DIRECTION_TYPE_INVALID = 0,
    SORT_DIRECTION_TYPE_ASC     = 1,
    SORT_DIRECTION_TYPE_DESC    = 2,
};

// ------------------------------------------------------------------
// Union Type
// ------------------------------------------------------------------
enum UnionType {
    UNION_TYPE_NOUNION          = 0,
    UNION_TYPE_UNION            = 1,
    UNION_TYPE_UNION_ALL        = 2,
    UNION_TYPE_INTERSECT        = 3,
    UNION_TYPE_INTERSECT_ALL    = 4,
    UNION_TYPE_EXCEPT_ALL       = 5,
    UNION_TYPE_EXCEPT           = 6
};

// ------------------------------------------------------------------
// PlanNode Type
// ------------------------------------------------------------------
enum class PlanNodeType {
    Invalid          = 0, // for parsing...

    //
    // Scan Nodes
    //
    SeqScan          = 10,
    IndexScan        = 11,
    // special counting index
    IndexCount       = 12,
    TableCount       = 13,
    // for sql-in using indexes
    MaterializedScan = 14,
    // for sql-expression-select
    TupleScan        = 15,
    //
    // Join Nodes
    //
    Nestloop         = 20,
    NestloopIndex    = 21,
    MergeJoin        = 22,

    //
    // Operator Nodes
    //
    Update           = 30,
    Insert           = 31,
    Delete           = 32,
    // UPSERT           = 33, // RESERVED, but not used in the EE
    SwapTables       = 34,
    Migrate          = 35,

    //
    // Communication Nodes
    //
    Send             = 40,
    Receive          = 41,
    MergeReceive     = 42,

    //
    // Misc Nodes
    //
    Aggregate        = 50,
    HashAggregate    = 51,
    Union            = 52,
    OrderBy          = 53,
    Projection       = 54,
    Materialize      = 55,
    Limit            = 56,
    PartialAggregate = 57,
    WindowFunction   = 58,
    CommonTable      = 59
};

// ------------------------------------------------------------------
//  Resource Access Mode Type for ReadWrite set
// ------------------------------------------------------------------
enum ReadWriteType {
    READWRITE_TYPE_NONE     = 0,
    READWRITE_TYPE_S        = 1,
    READWRITE_TYPE_X        = 2,
    READWRITE_TYPE_IS       = 3,
    READWRITE_TYPE_IX       = 4,
    READWRITE_TYPE_SIX      = 5
    // mode U/IU cannot exist as the read/write set is checked after execution
    // TODO : range ReadWrite types? if we need them, like SQLServer or like DB2?
};

// ------------------------------------------------------------------
// Undo Log Entry Types
// ------------------------------------------------------------------
enum UndoLogType {
   UNDOLOG_NOOP                 = 0,
   UNDOLOG_INSERT               = 1,
   UNDOLOG_UPDATE               = 2,
   UNDOLOG_DELETE               = 3,
   UNDOLOG_CHECKCONSISTENCY     = 4 //check consistency
};

// ------------------------------------------------------------------
// Predicate Expression Operation Types
// ------------------------------------------------------------------
enum ExpressionType {
    EXPRESSION_TYPE_INVALID                     = 0,

    // -----------------------------
    // Arithmetic Operators
    // Implicit Numeric Casting: Trying to implement SQL-92.
    // Implicit Character Casting: Trying to implement SQL-92, but not easy...
    // Anyway, use explicit EXPRESSION_TYPE_OPERATOR_CAST if you could.
    // -----------------------------
    EXPRESSION_TYPE_OPERATOR_PLUS                   = 1, // left + right (both must be number. implicitly casted)
    EXPRESSION_TYPE_OPERATOR_MINUS                  = 2, // left - right (both must be number. implicitly casted)
    EXPRESSION_TYPE_OPERATOR_MULTIPLY               = 3, // left * right (both must be number. implicitly casted)
    EXPRESSION_TYPE_OPERATOR_DIVIDE                 = 4, // left / right (both must be number. implicitly casted)
    EXPRESSION_TYPE_OPERATOR_CONCAT                 = 5, // left || right (both must be char/varchar)
    EXPRESSION_TYPE_OPERATOR_MOD                    = 6, // left % right (both must be integer)
    EXPRESSION_TYPE_OPERATOR_CAST                   = 7, // explicitly cast left as right (right is integer in ValueType enum)
    EXPRESSION_TYPE_OPERATOR_NOT                    = 8, // logical not operator
    EXPRESSION_TYPE_OPERATOR_IS_NULL                = 9, // is null test.
    EXPRESSION_TYPE_OPERATOR_EXISTS                 = 18, // exists test.
    EXPRESSION_TYPE_OPERATOR_UNARY_MINUS            = 22, // exists test.

    // -----------------------------
    // Comparison Operators
    // -----------------------------
    EXPRESSION_TYPE_COMPARE_EQUAL                   = 10, // equal operator between left and right
    EXPRESSION_TYPE_COMPARE_NOTEQUAL                = 11, // inequal operator between left and right
    EXPRESSION_TYPE_COMPARE_LESSTHAN                = 12, // less than operator between left and right
    EXPRESSION_TYPE_COMPARE_GREATERTHAN             = 13, // greater than operator between left and right
    EXPRESSION_TYPE_COMPARE_LESSTHANOREQUALTO       = 14, // less than equal operator between left and right
    EXPRESSION_TYPE_COMPARE_GREATERTHANOREQUALTO    = 15, // greater than equal operator between left and right
    EXPRESSION_TYPE_COMPARE_LIKE                    = 16, // LIKE operator (left LIKE right). both children must be string.
    EXPRESSION_TYPE_COMPARE_IN                      = 17, // IN operator [left IN (right1, right2, ...)]
    // value 18 is assigned to EXPRESSION_TYPE_OPERATOR_EXISTS
    EXPRESSION_TYPE_COMPARE_NOTDISTINCT             = 19, // Not distinct operator between left and right
    EXPRESSION_TYPE_COMPARE_STARTSWITH              = 150,

    // -----------------------------
    // Conjunction Operators
    // -----------------------------
    EXPRESSION_TYPE_CONJUNCTION_AND                 = 20,
    EXPRESSION_TYPE_CONJUNCTION_OR                  = 21,

    // -----------------------------
    // Values
    // -----------------------------
    EXPRESSION_TYPE_VALUE_CONSTANT                  = 30,
    EXPRESSION_TYPE_VALUE_PARAMETER                 = 31,
    EXPRESSION_TYPE_VALUE_TUPLE                     = 32,
    EXPRESSION_TYPE_VALUE_TUPLE_ADDRESS             = 33,
    EXPRESSION_TYPE_VALUE_NULL                      = 34,
    EXPRESSION_TYPE_VALUE_VECTOR                    = 35,
    EXPRESSION_TYPE_VALUE_SCALAR                    = 36,

    // -----------------------------
    // Aggregates
    // -----------------------------
    EXPRESSION_TYPE_AGGREGATE_COUNT                 = 40,
    EXPRESSION_TYPE_AGGREGATE_COUNT_STAR            = 41,
    EXPRESSION_TYPE_AGGREGATE_SUM                   = 42,
    EXPRESSION_TYPE_AGGREGATE_MIN                   = 43,
    EXPRESSION_TYPE_AGGREGATE_MAX                   = 44,
    EXPRESSION_TYPE_AGGREGATE_AVG                   = 45,
    EXPRESSION_TYPE_AGGREGATE_APPROX_COUNT_DISTINCT = 46,
    EXPRESSION_TYPE_AGGREGATE_VALS_TO_HYPERLOGLOG   = 47,
    EXPRESSION_TYPE_AGGREGATE_HYPERLOGLOGS_TO_CARD  = 48,
    // -----------------------------
    // User-defined Aggregates
    // -----------------------------
    EXPRESSION_TYPE_USER_DEFINED_AGGREGATE    = 106,

    // -----------------------------
    // Windowed Expression Aggregates.
    // -----------------------------
    EXPRESSION_TYPE_AGGREGATE_WINDOWED_RANK                   = 70,
    EXPRESSION_TYPE_AGGREGATE_WINDOWED_DENSE_RANK             = 71,
    EXPRESSION_TYPE_AGGREGATE_WINDOWED_COUNT                  = 72,
    EXPRESSION_TYPE_AGGREGATE_WINDOWED_MAX                    = 73,
    EXPRESSION_TYPE_AGGREGATE_WINDOWED_MIN                    = 74,
    EXPRESSION_TYPE_AGGREGATE_WINDOWED_SUM                    = 75,
    EXPRESSION_TYPE_AGGREGATE_WINDOWED_ROW_NUMBER             = 76,
    // -----------------------------
    // Functions
    // -----------------------------
    EXPRESSION_TYPE_FUNCTION                        = 100,


    // -----------------------------
    // Internals added for Elastic
    // -----------------------------
    EXPRESSION_TYPE_HASH_RANGE                      = 200,

    // -----------------------------
    // Internals added for Case When
    // -----------------------------
    EXPRESSION_TYPE_OPERATOR_CASE_WHEN                       = 300,
    EXPRESSION_TYPE_OPERATOR_ALTERNATIVE                     = 301,

    // -----------------------------
    // Subquery IN/EXISTS
    // -----------------------------
    EXPRESSION_TYPE_ROW_SUBQUERY                       = 400,
    EXPRESSION_TYPE_SELECT_SUBQUERY                    = 401

};

// ------------------------------------------------------------------
// Expression Quantifier Types
// ------------------------------------------------------------------
enum QuantifierType {
    QUANTIFIER_TYPE_NONE    = 0,
    QUANTIFIER_TYPE_ANY     = 1,
    QUANTIFIER_TYPE_ALL     = 2,
};
// ------------------------------------------------------------------
// Table Index Types
// ------------------------------------------------------------------
enum TableIndexType {
    BALANCED_TREE_INDEX     = 1,
    HASH_TABLE_INDEX        = 2,
    BTREE_INDEX             = 3, // unused
    COVERING_CELL_INDEX     = 4
};

// ------------------------------------------------------------------
// Index Lookup Types
// ------------------------------------------------------------------
enum class IndexLookupType {
   Invalid = 0,
   Equal = 1,
   Greater = 2,
   GreaterEqual = 3,
   Less = 4,
   LessEqual = 5,
   GeoContains = 6
};

// ------------------------------------------------------------------
// Table Stream Types
//
// IMPORTANT: Keep this enum in sync with the Java equivalent
//            in TableStreamType.java!
//
// Use the functions in preference to switch/case constructs on enum
// values. This minimizes the spread of stream type assumptions and
// makes it less painful to change the enum.
// ------------------------------------------------------------------
enum TableStreamType {
    // Table stream types that use predicates.
    TABLE_STREAM_SNAPSHOT,
    TABLE_STREAM_ELASTIC_INDEX,

    // Materialize previously-captured index.
    TABLE_STREAM_ELASTIC_INDEX_READ,

    // Clear previously-captured index using the same range predicate that
    // was used for TABLE_STREAM_ELASTIC_INDEX_READ.
    TABLE_STREAM_ELASTIC_INDEX_CLEAR,

    // Table stream type provided when no stream is active.
    TABLE_STREAM_NONE = -1
};

// Serialization special values returned by serializeMore(), etc. instead
// of the normal count. There's only one possible value for now.
enum TableStreamSerializationError {
    TABLE_STREAM_SERIALIZATION_ERROR = -1
};

/**
 * Return true if the table stream type uses predicates.
 */
inline bool tableStreamTypeHasPredicates(TableStreamType streamType) {
    return streamType == TABLE_STREAM_SNAPSHOT
        || streamType == TABLE_STREAM_ELASTIC_INDEX
        || streamType == TABLE_STREAM_ELASTIC_INDEX_READ;
}

/**
 * Return true if the table stream type is performing a snapshot.
 */
inline bool tableStreamTypeIsSnapshot(TableStreamType streamType) {
    return streamType == TABLE_STREAM_SNAPSHOT;
}

/**
 * Return true if the table stream type valid.
 */
inline bool tableStreamTypeIsValid(TableStreamType streamType) {
    return streamType != TABLE_STREAM_NONE;
}

inline bool tableStreamTypeIsStreamIndexing(TableStreamType streamType) {
    return streamType == TABLE_STREAM_ELASTIC_INDEX;
}

// ------------------------------------------------------------------
// Statistics Selector Types
// ------------------------------------------------------------------
enum StatisticsSelectorType {
    STATISTICS_SELECTOR_TYPE_TABLE,
    STATISTICS_SELECTOR_TYPE_INDEX
};

// ------------------------------------------------------------------
// Types of generic tasks that can be submitted to the EE
// ------------------------------------------------------------------
enum TaskType {
    TASK_TYPE_VALIDATE_PARTITIONING = 0,
    TASK_TYPE_GET_DR_TUPLESTREAM_STATE = 1,
    TASK_TYPE_SET_DR_SEQUENCE_NUMBERS = 2,
    TASK_TYPE_SET_DR_PROTOCOL_VERSION = 3,
    TASK_TYPE_SP_JAVA_GET_DRID_TRACKER = 4,      // not supported in EE
    TASK_TYPE_GENERATE_DR_EVENT = 5,
    TASK_TYPE_RESET_DR_APPLIED_TRACKER = 6,      // not supported in EE
    TASK_TYPE_SET_MERGED_DRID_TRACKER = 7,       // not supported in EE
    TASK_TYPE_INIT_DRID_TRACKER = 8,             // not supported in EE
    TASK_TYPE_RESET_DR_APPLIED_TRACKER_SINGLE = 9, // not supported in EE
    TASK_TYPE_ELASTIC_CHANGE = 10,                 // not supported in EE
};

// ------------------------------------------------------------------
// Types of DR in-band events
// ------------------------------------------------------------------
enum DREventType {
    NOT_A_EVENT = 0,
    POISON_PILL = 1,      // not supported in EE
    CATALOG_UPDATE = 2,
    DR_STREAM_START = 3,
    SWAP_TABLE = 4,
    DR_STREAM_END = 5,
    DR_ELASTIC_CHANGE = 6,
    DR_ELASTIC_REBALANCE = 7,
};


// ------------------------------------------------------------------
// Types of DR records
// ------------------------------------------------------------------
enum DRRecordType {
    DR_RECORD_INVALID = -1,
    DR_RECORD_INSERT = 0,
    DR_RECORD_DELETE = 1,
    DR_RECORD_UPDATE = 2,
    DR_RECORD_BEGIN_TXN = 3,
    DR_RECORD_END_TXN = 4,
    DR_RECORD_TRUNCATE_TABLE = 5,
    DR_RECORD_DELETE_BY_INDEX = 6,
    DR_RECORD_UPDATE_BY_INDEX = 7,
    DR_RECORD_HASH_DELIMITER = 8
};

// ------------------------------------------------------------------
// Flags of DR Transaction Partition Hash
// ------------------------------------------------------------------
enum DRTxnPartitionHashFlag {
    TXN_PAR_HASH_PLACEHOLDER = 0, // a sentinel for unassigned hash flag
    TXN_PAR_HASH_REPLICATED = 1,  // txn is from DR stream for replicated table
    TXN_PAR_HASH_SINGLE = 2,      // txn contains a single partition key hash
    TXN_PAR_HASH_MULTI = 3,       // txn contains multiple partition key hashes
    TXN_PAR_HASH_SPECIAL = 4      // txn contains TRUNCATE_TABLE record(s)
};

inline size_t rowCostForDRRecord(DRRecordType type) {
    // Warning: Currently, the PersistentTableUndo*Actions rely on
    // DR_RECORD_{0}_BY_INDEX costing the same as DR_RECORD_{0}
    switch (type) {
    case DR_RECORD_INSERT:
    case DR_RECORD_DELETE:
    case DR_RECORD_DELETE_BY_INDEX:
        return 1;
    case DR_RECORD_UPDATE:
    case DR_RECORD_UPDATE_BY_INDEX:
        return 2;
    case DR_RECORD_TRUNCATE_TABLE:
        return 100;
    default:
        return 0;
    }
}

// ------------------------------------------------------------------
// Tuple serialization formats
// ------------------------------------------------------------------
enum TupleSerializationFormat { TUPLE_SERIALIZATION_NATIVE = 0, TUPLE_SERIALIZATION_DR = 1 };

// ------------------------------------------------------------------
// Endianess
// ------------------------------------------------------------------
enum Endianess { BYTE_ORDER_BIG_ENDIAN = 0, BYTE_ORDER_LITTLE_ENDIAN = 1 };

// ------------------------------------------------------------------
// Types of DR conflict (keep sync with DRConflictType at PartitionDRGateway.java)
// ------------------------------------------------------------------
enum DRConflictType {
    NO_CONFLICT,
    CONFLICT_CONSTRAINT_VIOLATION,
    CONFLICT_EXPECTED_ROW_MISSING,
    CONFLICT_EXPECTED_ROW_MISMATCH,
};

enum DRConflictRowType {
    EXISTING_ROW,
    EXPECTED_ROW,
    NEW_ROW,
    DELETED_ROW,
};

enum DRRowDecision {
   ACCEPT,
   REJECT,
};

enum DRDivergence {
    NOT_DIVERGE,
    DIVERGE,
};

enum DRConflictOnPK {
    NOT_CONFLICT_ON_PK,
    CONFLICT_ON_PK,
};

/*
 * Keep it sync with frontend/org/voltdb/TableType.java
 */
enum TableType {
     // This will be unset and hence 0 for pre-9.0 catalogs
     INVALID = 0,

      // Regular PersistentTable
     PERSISTENT = 1,

      // StreamTable without ExportTupleStream
     CONNECTOR_LESS_STREAM = 2,

     // StreamTable with ExportTupleStream
     STREAM = 3,

     // PersistentTable with associated Stream for migrating DELETES
     PERSISTENT_MIGRATE  = 4,

     // PersistentTable with associated Stream for linking INSERTS
     PERSISTENT_EXPORT_INSERT = 8,
     PERSISTENT_EXPORT_DELETE = 16,
     PERSISTENT_EXPORT_UPDATE_OLD = 32,
     PERSISTENT_EXPORT_UPDATE_NEW = 64,
     PERSISTENT_EXPORT_INSERT_DELETE = PERSISTENT_EXPORT_INSERT +
                                       PERSISTENT_EXPORT_DELETE,
     PERSISTENT_EXPORT_INSERT_UPDATEold = PERSISTENT_EXPORT_INSERT +
                                          PERSISTENT_EXPORT_UPDATE_OLD,
     PERSISTENT_EXPORT_DELETE_UPDATEold = PERSISTENT_EXPORT_DELETE +
                                          PERSISTENT_EXPORT_UPDATE_OLD,
     PERSISTENT_EXPORT_INSERT_DELETE_UPDATEold = PERSISTENT_EXPORT_INSERT_DELETE +
                                                 PERSISTENT_EXPORT_UPDATE_OLD,
     PERSISTENT_EXPORT_INSERT_UPDATEnew = PERSISTENT_EXPORT_INSERT +
                                          PERSISTENT_EXPORT_UPDATE_NEW,
     PERSISTENT_EXPORT_DELETE_UPDATEnew = PERSISTENT_EXPORT_DELETE +
                                          PERSISTENT_EXPORT_UPDATE_NEW,
     PERSISTENT_EXPORT_INSERT_DELETE_UPDATEnew = PERSISTENT_EXPORT_INSERT_DELETE +
                                                 PERSISTENT_EXPORT_UPDATE_NEW,
     PERSISTENT_EXPORT_UPDATE = PERSISTENT_EXPORT_UPDATE_OLD + PERSISTENT_EXPORT_UPDATE_NEW,
     PERSISTENT_EXPORT_INSERT_UPDATE = PERSISTENT_EXPORT_INSERT +
                                       PERSISTENT_EXPORT_UPDATE,
     PERSISTENT_EXPORT_DELETE_UPDATE = PERSISTENT_EXPORT_DELETE +
                                       PERSISTENT_EXPORT_UPDATE,
     PERSISTENT_EXPORT_INSERT_DELETE_UPDATE = PERSISTENT_EXPORT_INSERT_DELETE +
                                              PERSISTENT_EXPORT_UPDATE,
};

inline bool tableTypeIsExportStream(TableType tableType) {
    return tableType == STREAM;
}

inline bool tableTypeIsConnectorLessStream(TableType tableType) {
    return tableType == CONNECTOR_LESS_STREAM;
}

inline bool tableTypeIsStream(TableType tableType) {
    return tableTypeIsExportStream(tableType) ||
            tableTypeIsConnectorLessStream(tableType);
}

inline bool isTableWithExport(TableType tableType) {
    return tableType >= PERSISTENT_EXPORT_INSERT;
}

inline bool isTableWithExportInserts(TableType tableType) {
    return static_cast<int>(tableType) & static_cast<int>(PERSISTENT_EXPORT_INSERT);
}

inline bool isTableWithExportDeletes(TableType tableType) {
    return static_cast<int>(tableType) & static_cast<int>(PERSISTENT_EXPORT_DELETE);
}

inline bool isTableWithExportUpdateOld(TableType tableType) {
    return static_cast<int>(tableType) & static_cast<int>(PERSISTENT_EXPORT_UPDATE_OLD);
}

inline bool isTableWithExportUpdateNew(TableType tableType) {
    return static_cast<int>(tableType) & static_cast<int>(PERSISTENT_EXPORT_UPDATE_NEW);
}

inline bool isTableWithStream(TableType tableType) {
    return tableType == PERSISTENT_MIGRATE || tableType >= PERSISTENT_EXPORT_INSERT;
}

inline bool tableTypeNeedsTupleStream(TableType tableType) {
    return tableTypeIsExportStream(tableType) || isTableWithStream(tableType);
}

inline bool isTableWithMigrate(TableType tableType) {
    return tableType == PERSISTENT_MIGRATE;
}


// ------------------------------------------------------------------
// Utility functions.
// -----------------------------------------------------------------
std::string getTypeName(ValueType type);
std::string tableStreamTypeToString(TableStreamType type);

bool isNumeric(ValueType type);
bool isIntegralType(ValueType type);
bool isVariableLengthType(ValueType type);

std::string valueToString(ValueType type);
ValueType stringToValue(std::string const& str);

std::string joinToString(JoinType type);
JoinType stringToJoin(std::string const& str);

std::string sortDirectionToString(SortDirectionType type);
SortDirectionType stringToSortDirection(std::string const& str);

std::string planNodeToString(PlanNodeType type);
PlanNodeType stringToPlanNode(std::string const& str);

std::string expressionToString(ExpressionType type);
ExpressionType stringToExpression(std::string const& str);

std::string indexLookupToString(IndexLookupType type);
IndexLookupType stringToIndexLookup(std::string const& str);

int64_t getMaxTypeValue (ValueType type);

bool hexDecodeToBinary(unsigned char *bufferdst, const char *hexString);
}

