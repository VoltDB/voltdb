/* This file is part of VoltDB.
 * Copyright (C) 2008-2012 VoltDB Inc.
 *
 * VoltDB is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * VoltDB is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with VoltDB.  If not, see <http://www.gnu.org/licenses/>.
 */

package org.voltdb.dtxn;

import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.Queue;
import java.util.Set;

import org.voltdb.ClientInterface;
import org.voltdb.SiteStatsSource;
import org.voltdb.StoredProcedureInvocation;
import org.voltdb.SysProcSelector;
import org.voltdb.VoltDB;
import org.voltdb.VoltTable.ColumnInfo;
import org.voltdb.VoltType;
import org.voltdb.client.ClientResponse;

/**
 * Class that provides storage for statistical information generated by an Initiator
 */
public class InitiatorStats extends SiteStatsSource {


    /**
     * Map from the combined key of ConnectionId and ProcedureName to statistical information related to the specific procedure.
     */
    private final HashMap<String, InvocationInfo> m_connectionStats =
                new HashMap<String, InvocationInfo>();

    /**
     *
     * @param name
     * @param siteId
     */
    public InitiatorStats(long siteId) {
        super(siteId, false);
        VoltDB.instance().getStatsAgent().registerStatsSource(SysProcSelector.INITIATOR, 0, this);
    }

    public static class InvocationInfo {

        /**
         * Hostname of the host this connection is with
         */
        private final String connectionHostname;

        /**
         * Number of time procedure has been invoked
         */
        private long invocationCount = 0;
        private long lastInvocationCount = 0;

        /**
         * Shortest amount of time this procedure has executed in
         */
        private int minExecutionTime = Integer.MAX_VALUE;
        private int lastMinExecutionTime = Integer.MAX_VALUE;

        /**
         * Longest amount of time this procedure has executed in
         */
        private int maxExecutionTime = Integer.MIN_VALUE;
        private int lastMaxExecutionTime = Integer.MIN_VALUE;

        /**
         * Total amount of time spent executing procedure
         */
        private long totalExecutionTime = 0;
        private long lastTotalExecutionTime = 0;

        private long abortCount = 0;
        private long lastAbortCount = 0;
        private long failureCount = 0;
        private long lastFailureCount = 0;

        public InvocationInfo (String hostname) {
            connectionHostname = hostname;
        }

        public void processInvocation(int delta, byte status) {
            totalExecutionTime += delta;
            minExecutionTime = Math.min( delta, minExecutionTime);
            maxExecutionTime = Math.max(  delta, maxExecutionTime);
            lastMinExecutionTime = Math.min( delta, lastMinExecutionTime);
            lastMaxExecutionTime = Math.max( delta, lastMaxExecutionTime);
            invocationCount++;
            if (status != ClientResponse.SUCCESS) {
                if (status == ClientResponse.GRACEFUL_FAILURE || status == ClientResponse.USER_ABORT) {
                    abortCount++;
                } else {
                    failureCount++;
                }
            }
        }
    }

    /**
     * Called by the Initiator every time a transaction is completed
     * @param connectionId Id of the connection that the invocation orginated from
     * @param invocation Procedure executed
     * @param delta Time the procedure took to round trip intra cluster
     */
    public synchronized void logTransactionCompleted(
            long connectionId,
            String connectionHostname,
            StoredProcedureInvocation invocation,
            int delta,
            byte status) {
        final StringBuilder key = new StringBuilder(2048);
        key.append(invocation.getProcName()).append('$').append(connectionId);
        final String keyString = key.toString();
        InvocationInfo info = m_connectionStats.get(keyString);
        if (info == null) {
            info = new InvocationInfo(connectionHostname);
            m_connectionStats.put(keyString, info);
        }
        info.processInvocation(delta, status);
    }

    /**
     * Remove all stats of a connection.
     * @param connectionId
     */
    public synchronized void removeConnectionStats(long connectionId) {
        Set<String> keySet = m_connectionStats.keySet();
        LinkedList<String> keysToRemove = new LinkedList<String>();
        for (String key : keySet) {
            // note: use lastIndexOf below to support inner classes as procedures
            long cId = Long.parseLong(key.substring(key.lastIndexOf('$') + 1));
            if (cId == connectionId) {
                keysToRemove.add(key);
            }
        }

        for (String key : keysToRemove) {
            m_connectionStats.remove(key);
        }
        keysToRemove.clear();
    }

    @Override
    protected void populateColumnSchema(ArrayList<ColumnInfo> columns) {
        super.populateColumnSchema(columns);
        columns.add(new ColumnInfo("CONNECTION_ID", VoltType.BIGINT));
        columns.add(new ColumnInfo("CONNECTION_HOSTNAME", VoltType.STRING));
        columns.add(new ColumnInfo("PROCEDURE_NAME", VoltType.STRING));
        columns.add(new ColumnInfo("INVOCATIONS", VoltType.BIGINT));
        columns.add(new ColumnInfo("AVG_EXECUTION_TIME", VoltType.INTEGER));
        columns.add(new ColumnInfo("MIN_EXECUTION_TIME", VoltType.INTEGER));
        columns.add(new ColumnInfo("MAX_EXECUTION_TIME", VoltType.INTEGER));
        columns.add(new ColumnInfo("ABORTS", VoltType.BIGINT));
        columns.add(new ColumnInfo("FAILURES", VoltType.BIGINT));
    }

    @Override
    protected void updateStatsRow(final Object rowKey, Object rowValues[]) {
        DummyIterator iterator = (DummyIterator)rowKey;
        Map.Entry<String, InvocationInfo> entry = iterator.next;
        iterator.next = null;
        final InvocationInfo info = entry.getValue();
        final String statsKey = entry.getKey();
        final String statsKeySplit[] = statsKey.split("\\$");
        final String procName = statsKeySplit[0];
        final String connectionId = statsKeySplit[1];

        long invocationCount = info.invocationCount;
        long totalExecutionTime = info.totalExecutionTime;
        int minExecutionTime = info.minExecutionTime;
        int maxExecutionTime = info.maxExecutionTime;
        long abortCount = info.abortCount;
        long failureCount = info.failureCount;

        if (iterator.interval) {
            invocationCount = info.invocationCount - info.lastInvocationCount;
            info.lastInvocationCount = info.invocationCount;

            totalExecutionTime = info.totalExecutionTime - info.lastTotalExecutionTime;
            info.lastTotalExecutionTime = info.totalExecutionTime;

            minExecutionTime = info.lastMinExecutionTime;
            maxExecutionTime = info.lastMaxExecutionTime;
            info.lastMinExecutionTime = Integer.MAX_VALUE;
            info.lastMaxExecutionTime = Integer.MIN_VALUE;

            abortCount = info.abortCount - info.lastAbortCount;
            info.lastAbortCount = info.abortCount;

            failureCount = info.failureCount - info.lastFailureCount;
            info.lastFailureCount = info.failureCount;
        }

        rowValues[columnNameToIndex.get("CONNECTION_ID")] = new Long(connectionId);
        rowValues[columnNameToIndex.get("CONNECTION_HOSTNAME")] = info.connectionHostname;
        rowValues[columnNameToIndex.get("PROCEDURE_NAME")] = procName;
        rowValues[columnNameToIndex.get("INVOCATIONS")] = invocationCount;
        rowValues[columnNameToIndex.get("AVG_EXECUTION_TIME")] = (int)(totalExecutionTime / invocationCount);
        rowValues[columnNameToIndex.get("MIN_EXECUTION_TIME")] = minExecutionTime;
        rowValues[columnNameToIndex.get("MAX_EXECUTION_TIME")] = maxExecutionTime;
        rowValues[columnNameToIndex.get("ABORTS")] = abortCount;
        rowValues[columnNameToIndex.get("FAILURES")] = failureCount;
        super.updateStatsRow(rowKey, rowValues);
    }

    /**
     * A dummy iterator that wraps an Iterator<String> and provides the Iterator<Object> necessary
     * for getStatsRowKeyIterator()
     *
     */
    private class DummyIterator implements Iterator<Object> {
        private final Iterator<Map.Entry<String, InvocationInfo>> i;
        private Map.Entry<String, InvocationInfo> next = null;
        private final boolean interval;
        private DummyIterator(Iterator<Map.Entry<String, InvocationInfo>> i, boolean interval) {
            this.i = i;
            this.interval = interval;
        }

        @Override
        public boolean hasNext() {
            if (!interval) {
                if (i.hasNext()) {
                    next = i.next();
                    return true;
                } else {
                    return false;
                }
            }
            if (!i.hasNext()) {
                return false;
            } else {
                while (next == null && i.hasNext()) {
                    Map.Entry<String, InvocationInfo> entry = i.next();
                    InvocationInfo info = entry.getValue();
                    if (info.invocationCount - info.lastInvocationCount == 0) {
                        continue;
                    } else {
                        next = entry;
                    }
                }
                if (next == null) {
                    return false;
                }
            }
            return true;
        }

        @Override
        public Object next() {
            return this;
        }

        @Override
        public void remove() {
            throw new UnsupportedOperationException();
        }
    }

    private class AggregatingIterator implements Iterator<Map.Entry<String, InvocationInfo>> {

        private final Queue<Iterator<Map.Entry<String, InvocationInfo>>> m_sources;
        private AggregatingIterator(Queue<Iterator<Map.Entry<String, InvocationInfo>>> sources) {
            m_sources = sources;
        }

        @Override
        public boolean hasNext() {
            Iterator<Map.Entry<String, InvocationInfo>> i = null;
            while ((i = m_sources.peek()) != null) {
                if (i.hasNext()) return true;
                m_sources.remove();
            }
            return false;
        }

        @Override
        public Map.Entry<String, InvocationInfo> next() {
            final Iterator<Map.Entry<String, InvocationInfo>> i = m_sources.peek();
            if (i == null || !i.hasNext()) {
                throw new NoSuchElementException();
            }
            return i.next();
        }

        @Override
        public void remove() {
            throw new UnsupportedOperationException();
        }

    }

    @Override
    protected Iterator<Object> getStatsRowKeyIterator(boolean interval) {
        ArrayDeque<Iterator<Map.Entry<String, InvocationInfo>>> d =
                new ArrayDeque<Iterator<Map.Entry<String, InvocationInfo>>>();
        if (VoltDB.instance().isIV2Enabled()) {
            for (ClientInterface ci : VoltDB.instance().getClientInterfaces()) {
                d.addAll(ci.getIV2InitiatorStats());
            }
        } else {
            d.offer(m_connectionStats.entrySet().iterator());
        }
        return new DummyIterator(
                new AggregatingIterator(d),
                interval);
    }
}
