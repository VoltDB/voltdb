CREATE TABLE P1 (
  ID INTEGER DEFAULT '0' NOT NULL,
  PAST TIMESTAMP,
  PRESENT TIMESTAMP,
  FUTURE TIMESTAMP,
  RATIO FLOAT NOT NULL,
  PRIMARY KEY (ID)
);
PARTITION TABLE P1 ON COLUMN ID;

CREATE TABLE P2 (
  ID INTEGER DEFAULT '0' NOT NULL,
  PAST TIMESTAMP,
  PRESENT TIMESTAMP,
  FUTURE TIMESTAMP,
  RATIO FLOAT NOT NULL,
  PRIMARY KEY (ID)
);
PARTITION TABLE P2 ON COLUMN ID;

CREATE TABLE P3 (
  ID INTEGER DEFAULT '0' NOT NULL,
  PAST TIMESTAMP,
  PRESENT TIMESTAMP,
  FUTURE TIMESTAMP,
  RATIO FLOAT NOT NULL,
  PRIMARY KEY (ID)
);
PARTITION TABLE P3 ON COLUMN ID;

CREATE TABLE R1 (
  ID INTEGER DEFAULT '0' NOT NULL,
  PAST TIMESTAMP,
  PRESENT TIMESTAMP,
  FUTURE TIMESTAMP,
  RATIO FLOAT NOT NULL,
  PRIMARY KEY (ID)
);

CREATE TABLE R2 (
  ID INTEGER DEFAULT '0' NOT NULL,
  PAST TIMESTAMP,
  PRESENT TIMESTAMP,
  FUTURE TIMESTAMP,
  RATIO FLOAT NOT NULL,
  PRIMARY KEY (ID)
);

CREATE TABLE R3 (
  ID INTEGER DEFAULT '0' NOT NULL,
  PAST TIMESTAMP,
  PRESENT TIMESTAMP,
  FUTURE TIMESTAMP,
  RATIO FLOAT NOT NULL,
  PRIMARY KEY (ID)
);

-- Define some Materialized Views using Joins; note that we mostly use the same
-- column names used above in the table definitions, since those are the only
-- column names that will be used explicitly in SELECT statements generated from
-- query templates (though SELECT * is also sometimes used, so all columns will
-- be tested, to some extent)

-- Minimal Materialized Views using Joins with 1 column: COUNT(*) only
CREATE VIEW V0 (ID) AS
  SELECT COUNT(*) FROM P1 T1 JOIN P2 T2 ON T1.ID = T2.ID;

CREATE VIEW V1 (ID) AS
  SELECT COUNT(*) FROM P1 T1 JOIN R1 T2 ON T1.PRESENT = T2.PRESENT;

CREATE VIEW V2 (ID) AS
  SELECT COUNT(*) FROM R1 T1 JOIN R2 T2 ON T1.PRESENT = T2.FUTURE;


-- "Simple" Materialized Views using Joins with 2 columns: 1 COUNT(*), 1 Aggregate Function
CREATE VIEW V3 (ID, FUTURE) AS
  SELECT COUNT(*),   MIN(T2.FUTURE) FROM P1 T1 JOIN P2 T2 USING(ID);

CREATE VIEW V4 (ID, PAST) AS
  SELECT COUNT(*),   MAX(T2.PAST) FROM P1 T1 JOIN R1 T2 ON T1.PRESENT = T2.FUTURE;

CREATE VIEW V5 (COUNT_STAR, ID) AS
  SELECT COUNT(*),   SUM(T1.ID)    FROM R2 T1 JOIN P2 T2 USING(PRESENT);

CREATE VIEW V6 (ID, COUNT2) AS
  SELECT COUNT(*), COUNT(T1.PRESENT)   FROM R1 T1 JOIN R2 T2 ON T1.ID = T2.ID;


-- "Simple" Materialized Views using Joins with 2 columns: 1 GROUP BY, 1 COUNT(*)
CREATE VIEW V7 (FUTURE, ID) AS
  SELECT   T1.FUTURE, COUNT(*) FROM P1 T1 JOIN P2 T2 ON T1.ID = T2.ID
  GROUP BY T1.FUTURE;

CREATE VIEW V8 (PRESENT, ID) AS
  SELECT   T1.PRESENT,   COUNT(*) FROM P1 T1 JOIN R1 T2 ON T1.ID = T2.ID
  GROUP BY T1.PRESENT;

CREATE VIEW V9 (PAST, ID) AS
  SELECT   T1.PAST, COUNT(*) FROM R2 T1 JOIN P2 T2 ON T1.PRESENT = T2.FUTURE
  GROUP BY T1.PAST;

CREATE VIEW V10 (ID, COUNT_STAR) AS
  SELECT   T1.ID,    COUNT(*) FROM R1 T1 JOIN R2 T2 USING(PRESENT)
  GROUP BY T1.ID;


-- "Normal" Materialized Views using Joins with 3 columns: 1 GROUP BY, 1 COUNT(*), 1 Aggregate Function
CREATE VIEW V11 (PAST, ID, PRESENT) AS
  SELECT   T1.PAST, COUNT(*),   MIN(T1.PRESENT)   FROM P1 T1 JOIN P2 T2 ON T1.ID = T2.ID
  GROUP BY T1.PAST;

CREATE VIEW V12 (PRESENT, ID, FUTURE) AS
  SELECT   T1.PRESENT,   COUNT(*),   MAX(T2.FUTURE) FROM P1 T1 JOIN P2 T2 USING(ID)
  GROUP BY T1.PRESENT;

CREATE VIEW V13 (FUTURE, COUNT_STAR, ID) AS
  SELECT   T2.FUTURE, COUNT(*),   SUM(T1.ID)    FROM P1 T1 JOIN R1 T2 USING(ID)
  GROUP BY T2.FUTURE;

CREATE VIEW V14 (ID, COUNT_STAR, COUNT2) AS
  SELECT   T2.ID,    COUNT(*), COUNT(T2.PAST) FROM P1 T1 JOIN R1 T2 ON T1.FUTURE = T2.PRESENT
  GROUP BY T2.ID;

CREATE VIEW V15 (FUTURE, ID, PAST) AS
  SELECT   T1.FUTURE, COUNT(*),   MIN(T2.PAST) FROM R2 T1 JOIN P2 T2 ON T1.PRESENT = T2.PRESENT
  GROUP BY T1.FUTURE;

CREATE VIEW V16 (ID, COUNT_STAR, PRESENT) AS
  SELECT   T2.PRESENT,   COUNT(*),   MAX(T1.PRESENT)   FROM R1 T1 JOIN R2 T2 ON T1.ID = T2.ID
  GROUP BY T2.PRESENT;

CREATE VIEW V17 (PAST, ID, FUTURE) AS
  SELECT   T1.PAST, COUNT(*),   MIN(T2.FUTURE) FROM R1 T1 JOIN R2 T2 ON T1.PRESENT = T2.FUTURE
  GROUP BY T1.PAST;

CREATE VIEW V18 (PRESENT, COUNT_STAR, ID) AS
  SELECT   T1.PRESENT,   COUNT(*), COUNT(T1.ID)    FROM R1 T1 JOIN R2 T2 USING(PRESENT)
  GROUP BY T1.PRESENT;


-- "Normal-plus" Materialized Views using Joins with 4 or more columns
CREATE VIEW V19 (FUTURE, ID, COUNT2, PAST) AS
  SELECT   T1.FUTURE,           COUNT(*), COUNT(T2.PRESENT),     MAX(T2.PAST) FROM P1 T1 JOIN P2 T2 ON T1.ID = T2.ID
  GROUP BY T1.FUTURE;

CREATE VIEW V20 (ID, FUTURE, COUNT_STAR, PAST) AS
  SELECT   T1.ID,    T2.FUTURE, COUNT(*),   MIN(T1.PAST)                  FROM P1 T1 JOIN R1 T2 ON T1.FUTURE  = T2.PRESENT
  GROUP BY T1.ID,    T2.FUTURE;

CREATE VIEW V21 (PRESENT, PAST, COUNT_STAR, FUTURE, ID) AS
  SELECT   T2.PRESENT,   T2.PAST, COUNT(*),   MIN(T1.FUTURE), COUNT(T2.ID)    FROM R2 T1 JOIN P2 T2 ON T1.FUTURE  = T2.PRESENT
  GROUP BY T2.PRESENT,   T2.PAST;

CREATE VIEW V22 (PAST, PRESENT, COUNT_STAR, ID, FUTURE) AS
  SELECT   T1.PAST, T2.PRESENT,   COUNT(*),   MAX(T2.ID),      MIN(T1.FUTURE) FROM R1 T1 JOIN R2 T2 ON T1.PRESENT = T2.PRESENT
  GROUP BY T1.PAST, T2.PRESENT;

CREATE VIEW V23 (PRESENT, PAST, PRESENT2, COUNT_STAR, ID, FUTURE, FUTURE2) AS
  SELECT   T1.PRESENT, T1.PAST, T2.PRESENT, COUNT(*), MIN(T2.ID), MAX(T1.FUTURE), MAX(T2.FUTURE) FROM P1 T1 JOIN R1 T2 ON T1.ID = T2.ID
  GROUP BY T1.PRESENT, T1.PAST, T2.PRESENT;


-- "Abnormal" Materialized Views using Joins that are not equi-joins (cannot use 2 partitioned tables)
CREATE VIEW V24 (PRESENT, ID, PRESENT2) AS
  SELECT   T1.PRESENT,   COUNT(*),   MIN(T2.PRESENT)   FROM P1 T1 JOIN R1 T2 ON T1.ID  <  T2.ID
  GROUP BY T1.PRESENT;

CREATE VIEW V25 (FUTURE, ID, PAST) AS
  SELECT   T1.FUTURE, COUNT(*),   MAX(T2.PAST) FROM R2 T1 JOIN P2 T2 ON T1.PAST  >  T2.PRESENT
  GROUP BY T1.FUTURE;

CREATE VIEW V26 (ID, COUNT_STAR, FUTURE) AS
  SELECT   T1.ID,    COUNT(*),   MAX(T2.FUTURE) FROM R1 T1 JOIN R2 T2 ON T1.PRESENT <= T2.PRESENT
  GROUP BY T1.ID;

CREATE VIEW V27 (PAST, ID, COUNT2) AS
  SELECT   T1.PAST, COUNT(*), COUNT(T2.PRESENT)   FROM R1 T1 JOIN R2 T2 ON T1.PAST  >= T2.PRESENT
  GROUP BY T1.PAST;


-- Cross-joins (cannot cross-join 2 partitioned tables)
CREATE VIEW V28 (PRESENT, ID, PAST) AS
  SELECT   T1.PRESENT,   COUNT(*),   MIN(T2.PAST) FROM P1 T1 CROSS JOIN R1 T2
  GROUP BY T1.PRESENT;

CREATE VIEW V29 (PAST, ID, FUTURE) AS
  SELECT   T1.PAST, COUNT(*),   MAX(T2.FUTURE) FROM R2 T1 CROSS JOIN P2 T2
  GROUP BY T1.PAST;

CREATE VIEW V30 (FUTURE, ID, COUNT2) AS
  SELECT   T1.FUTURE, COUNT(*), COUNT(T2.PRESENT)   FROM R1 T1 CROSS JOIN R2 T2
  GROUP BY T1.FUTURE;


-- "Complex" Materialized Views using Joins on 3 tables
CREATE VIEW V31 (PAST, COUNT_STAR, PRESENT, COUNT2) AS
  SELECT   T1.PAST, COUNT(*),   MIN(T2.PRESENT),   COUNT(T3.FUTURE) FROM P1 T1 JOIN P2 T2 ON T1.ID = T2.ID JOIN P3 T3 ON T2.ID = T3.ID
  GROUP BY T1.PAST;

CREATE VIEW V32 (PRESENT, ID, FUTURE, PAST) AS
  SELECT   T1.PRESENT,   COUNT(*),   MAX(T2.FUTURE),   MIN(T3.PAST) FROM P1 T1 JOIN P2 T2 ON T1.ID = T2.ID JOIN R1 T3 ON T2.ID = T3.ID
  GROUP BY T1.PRESENT;

CREATE VIEW V33 (FUTURE, COUNT_STAR, ID, COUNT2) AS
  SELECT   T1.FUTURE, COUNT(*), COUNT(T2.PAST),   COUNT(T3.PRESENT)   FROM P1 T1 JOIN R1 T2 ON T1.ID = T2.ID JOIN R2 T3 ON T2.ID = T3.ID
  GROUP BY T1.FUTURE;

CREATE VIEW V34 (FUTURE, ID, PRESENT, PAST) AS
  SELECT   T1.FUTURE, COUNT(*),   MAX(T2.PRESENT),     MAX(T3.PAST) FROM R1 T1 JOIN R2 T2 ON T1.ID = T2.ID JOIN R3 T3 ON T2.ID = T3.ID
  GROUP BY T1.FUTURE;


-- Joins on 4 tables!
CREATE VIEW V35 (PAST, PRESENT, COUNT_STAR, FUTURE, ID) AS
  SELECT   T1.PAST, T2.PRESENT,   COUNT(*), MIN(T3.FUTURE), COUNT(T4.PAST) FROM P1 T1 JOIN P2 T2 ON T1.ID = T2.ID JOIN R1 T3 ON T2.ID = T3.ID JOIN R2 T4 ON T2.ID = T4.ID
  GROUP BY T1.PAST, T2.PRESENT;

CREATE VIEW V36 (PRESENT, FUTURE, COUNT_STAR, PAST, ID) AS
  SELECT   T1.PRESENT,   T2.FUTURE, COUNT(*), MAX(T3.PAST),   SUM(T4.ID)    FROM P1 T1 JOIN P2 T2 ON T1.ID = T2.ID JOIN R1 T3 ON T2.ID = T3.ID JOIN R2 T4 ON T3.ID = T4.ID
  GROUP BY T1.PRESENT,   T2.FUTURE;
