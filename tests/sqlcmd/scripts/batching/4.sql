CREATE PROCEDURE PROC_ORDER2016 AS
    SELECT
        CUSTOMERS.NAME,
        COUNT(*)
    FROM CUSTOMERS JOIN ORDERS ON CUSTOMERS.CUSTOMER_ID = ORDERS.CUSTOMER_ID
    WHERE ORDERS.ORDER_TIME >= '2016-01-01 00:00:00'
    GROUP BY CUSTOMERS.NAME
    ORDER BY 1;

-- Shadow tables for caching table state to restore post-truncation.
CREATE TABLE WAS_CUSTOMERS (
    CUSTOMER_ID INTEGER NOT NULL,
    NAME VARCHAR(50) NOT NULL,
    ADDRESS VARCHAR(50),
    PRIMARY KEY (CUSTOMER_ID)
);

CREATE TABLE WAS_ORDERS (
    ORDER_ID INTEGER NOT NULL,
    CUSTOMER_ID INTEGER NOT NULL,
    ORDER_TIME TIMESTAMP NOT NULL,
    PRIMARY KEY (ORDER_ID)
);
PARTITION TABLE WAS_ORDERS ON COLUMN ORDER_ID;

CREATE TABLE WAS_ORDERITEMS (
    ORDER_ID INTEGER NOT NULL,
    PID INTEGER NOT NULL,
    QTY INTEGER NOT NULL
);
PARTITION TABLE WAS_ORDERITEMS ON COLUMN ORDER_ID;
CREATE INDEX WAS_ORDERITEMS_BY_ID ON WAS_ORDERITEMS(ORDER_ID);

CREATE TABLE WAS_PRODUCTS (
    PID INTEGER NOT NULL,
    PNAME VARCHAR(50) NOT NULL,
    PRICE FLOAT NOT NULL,
    PRIMARY KEY (PID)
);

-- a single table view case
CREATE VIEW QTYPERPRODUCT (PID, CNT, SUMQTY) AS
    SELECT PID, COUNT(*), SUM(QTY)
    FROM ORDERITEMS
    GROUP BY PID;

CREATE PROCEDURE PROC_QTYPERPRODUCT AS
    SELECT PID, COUNT(*), SUM(QTY)
    FROM ORDERITEMS
    GROUP BY PID
    ORDER BY 1;

CREATE TABLE P1_ENG_11024 (
  ID INTEGER NOT NULL,
  VCHAR VARCHAR(300),
  NUM INTEGER,
  RATIO FLOAT,
  PRIMARY KEY (ID)
);
PARTITION TABLE P1_ENG_11024 ON COLUMN ID;

CREATE TABLE P2_ENG_11024 (
  ID INTEGER NOT NULL,
  VCHAR VARCHAR(300),
  NUM INTEGER,
  RATIO FLOAT,
  PRIMARY KEY (ID)
);
PARTITION TABLE P2_ENG_11024 ON COLUMN ID;

CREATE TABLE R1_ENG_11024 (
  ID INTEGER NOT NULL,
  VCHAR VARCHAR(300),
  NUM INTEGER,
  RATIO FLOAT,
  PRIMARY KEY (ID)
);

CREATE TABLE R2_ENG_11024 (
  ID INTEGER NOT NULL,
  VCHAR VARCHAR(300),
  NUM INTEGER,
  RATIO FLOAT,
  PRIMARY KEY (ID)
);

CREATE VIEW V3_ENG_11024_JOIN (ID, RATIO) AS
  SELECT COUNT(*), MIN(T2.RATIO)
  FROM P1_ENG_11024 T1 JOIN P2_ENG_11024 T2 USING(ID);

CREATE VIEW V3_ENG_11024_1tbl (ID, RATIO) AS
  SELECT COUNT(*), MIN(RATIO)
  FROM P1_ENG_11024;

-- Repro for ENG-11042 uses same source tables as 11024
-- (both found by sqlcmd)
CREATE VIEW V16_ENG_11042 (ID, COUNT_STAR, NUM) AS
  SELECT T2.NUM, COUNT(*), MAX(T1.NUM)
  FROM R1_ENG_11024 T1 JOIN R2_ENG_11024 T2 ON T1.ID = T2.ID
  GROUP BY T2.NUM;

-- Repro for ENG-11043, also uses same source tables as 11024
CREATE VIEW V27 (NUM, ID, RATIO, VCHAR) AS
  SELECT T1.NUM, COUNT(*), MAX(T2.RATIO), MIN(T3.VCHAR)
  FROM P1_ENG_11024 T1 JOIN P2_ENG_11024 T2 ON T1.ID = T2.ID JOIN R1_ENG_11024 T3 ON T2.ID = T3.ID
  GROUP BY T1.NUM;

-- Repro for ENG-11047
CREATE VIEW V21 (NUM, VCHAR, COUNT_STAR, RATIO, ID) AS
  SELECT T2.NUM, T2.VCHAR, COUNT(*), MIN(T1.RATIO), COUNT(T2.ID)
  FROM R2_ENG_11024 T1 JOIN P2_ENG_11024 T2 ON T1.ID = T2.NUM
  GROUP BY T2.NUM, T2.VCHAR;

-- Repro for ENG-11074
-- These tables are used in the "string" suite of sqlcoverage matview join tests.
CREATE TABLE P1_ENG_11074 (
       ID INTEGER DEFAULT '0' NOT NULL,
       VCHAR VARCHAR(64 BYTES),
       VCHAR_INLINE_MAX VARCHAR(15),
       VCHAR_INLINE VARCHAR(42 BYTES),
       RATIO FLOAT NOT NULL,
       PRIMARY KEY (ID)
);
PARTITION TABLE P1_ENG_11074 ON COLUMN ID;

CREATE TABLE P2_ENG_11074 (
       ID INTEGER DEFAULT '0' NOT NULL,
       VCHAR VARCHAR(64 BYTES),
       VCHAR_INLINE_MAX VARCHAR(15),
       VCHAR_INLINE VARCHAR(42 BYTES),
       RATIO FLOAT NOT NULL,
       PRIMARY KEY (ID)
);
PARTITION TABLE P2_ENG_11074 ON COLUMN ID;

CREATE TABLE R1_ENG_11074 (
       ID INTEGER DEFAULT '0' NOT NULL,
       VCHAR VARCHAR(5000),
       VCHAR_INLINE_MAX VARCHAR(63 BYTES),
       VCHAR_INLINE VARCHAR(14),
       RATIO FLOAT NOT NULL,
       PRIMARY KEY (ID)
);
