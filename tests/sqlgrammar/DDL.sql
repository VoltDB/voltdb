-- Define "standard" DDL (tables, indexes, views), for use with the SQL grammar generator

-- Drop all items first, in case they already exist
DROP TABLE R0 IF EXISTS CASCADE;
DROP TABLE P0 IF EXISTS CASCADE;
DROP TABLE R1 IF EXISTS CASCADE;
DROP TABLE P1 IF EXISTS CASCADE;
DROP TABLE R2 IF EXISTS CASCADE;
DROP TABLE P2 IF EXISTS CASCADE;
DROP TABLE R3 IF EXISTS CASCADE;
DROP TABLE P3 IF EXISTS CASCADE;
DROP TABLE R4 IF EXISTS CASCADE;
DROP TABLE P4 IF EXISTS CASCADE;
DROP TABLE R5 IF EXISTS CASCADE;
DROP TABLE P5 IF EXISTS CASCADE;
DROP TABLE R6 IF EXISTS CASCADE;
DROP TABLE P6 IF EXISTS CASCADE;
DROP TABLE R7 IF EXISTS CASCADE;
DROP TABLE P7 IF EXISTS CASCADE;

CREATE TABLE R0 (
  ID      INTEGER,
  TINY    TINYINT,
  SMALL   SMALLINT,
  INT     INTEGER,
  BIG     BIGINT,
  NUM     FLOAT,
  DEC     DECIMAL,
  VCHAR_INLINE     VARCHAR(14),
  VCHAR_INLINE_MAX VARCHAR(63 BYTES),
  VCHAR            VARCHAR(64 BYTES),
  VCHAR_JSON       VARCHAR(1000),
  TIME    TIMESTAMP,
  VARBIN  VARBINARY(100),
  POINT   GEOGRAPHY_POINT,
  POLYGON GEOGRAPHY
);

CREATE TABLE P0 (
  ID      INTEGER NOT NULL,
  TINY    TINYINT,
  SMALL   SMALLINT,
  INT     INTEGER,
  BIG     BIGINT,
  NUM     FLOAT,
  DEC     DECIMAL,
  VCHAR_INLINE     VARCHAR(14),
  VCHAR_INLINE_MAX VARCHAR(63 BYTES),
  VCHAR            VARCHAR(64 BYTES),
  VCHAR_JSON       VARCHAR(1000),
  TIME    TIMESTAMP,
  VARBIN  VARBINARY(100),
  POINT   GEOGRAPHY_POINT,
  POLYGON GEOGRAPHY
);
PARTITION TABLE P0 ON COLUMN ID;

CREATE TABLE R1 (
  ID      INTEGER NOT NULL PRIMARY KEY,
  TINY    TINYINT,
  SMALL   SMALLINT,
  INT     INTEGER,
  BIG     BIGINT,
  NUM     FLOAT,
  DEC     DECIMAL,
  VCHAR_INLINE     VARCHAR(42 BYTES),
  VCHAR_INLINE_MAX VARCHAR(15),
  VCHAR            VARCHAR(16),
  VCHAR_JSON       VARCHAR(4000 BYTES),
  TIME    TIMESTAMP,
  VARBIN  VARBINARY(100),
  POINT   GEOGRAPHY_POINT,
  POLYGON GEOGRAPHY
);

CREATE TABLE P1 (
  ID      INTEGER NOT NULL PRIMARY KEY,
  TINY    TINYINT,
  SMALL   SMALLINT,
  INT     INTEGER,
  BIG     BIGINT,
  NUM     FLOAT,
  DEC     DECIMAL,
  VCHAR_INLINE     VARCHAR(42 BYTES),
  VCHAR_INLINE_MAX VARCHAR(15),
  VCHAR            VARCHAR(16),
  VCHAR_JSON       VARCHAR(4000 BYTES),
  TIME    TIMESTAMP,
  VARBIN  VARBINARY(100),
  POINT   GEOGRAPHY_POINT,
  POLYGON GEOGRAPHY
);
PARTITION TABLE P1 ON COLUMN ID;

CREATE TABLE R2 (
  ID      INTEGER NOT NULL,
  TINY    TINYINT,
  SMALL   SMALLINT,
  INT     INTEGER,
  BIG     BIGINT,
  NUM     FLOAT,
  DEC     DECIMAL,
  VCHAR_INLINE     VARCHAR(14),
  VCHAR_INLINE_MAX VARCHAR(63 BYTES),
  VCHAR            VARCHAR(64 BYTES),
  VCHAR_JSON       VARCHAR(1000),
  TIME    TIMESTAMP,
  VARBIN  VARBINARY(100),
  POINT   GEOGRAPHY_POINT,
  POLYGON GEOGRAPHY,
  PRIMARY KEY (ID)
);
CREATE INDEX IDX_R2_TINY ON R2 (TINY);
CREATE INDEX IDX_R2_BIG  ON R2 (BIG);
CREATE INDEX IDX_R2_DEC  ON R2 (DEC);
CREATE INDEX IDX_R2_VIM  ON R2 (VCHAR_INLINE_MAX);
CREATE INDEX IDX_R2_TIME ON R2 (TIME);
CREATE INDEX IDX_R2_VBIN ON R2 (VARBIN);
CREATE INDEX IDX_R2_POLY ON R2 (POLYGON);

CREATE TABLE P2 (
  ID      INTEGER NOT NULL,
  TINY    TINYINT,
  SMALL   SMALLINT,
  INT     INTEGER,
  BIG     BIGINT,
  NUM     FLOAT,
  DEC     DECIMAL,
  VCHAR_INLINE     VARCHAR(14),
  VCHAR_INLINE_MAX VARCHAR(63 BYTES),
  VCHAR            VARCHAR(64 BYTES),
  VCHAR_JSON       VARCHAR(1000),
  TIME    TIMESTAMP,
  VARBIN  VARBINARY(100),
  POINT   GEOGRAPHY_POINT,
  POLYGON GEOGRAPHY,
  PRIMARY KEY (ID)
);
PARTITION TABLE P2 ON COLUMN ID;
CREATE INDEX IDX_P2_TINY ON P2 (TINY);
CREATE INDEX IDX_P2_BIG  ON P2 (BIG);
CREATE INDEX IDX_P2_DEC  ON P2 (DEC);
CREATE INDEX IDX_P2_VIM  ON P2 (VCHAR_INLINE_MAX);
CREATE INDEX IDX_P2_TIME ON P2 (TIME);
CREATE INDEX IDX_P2_VBIN ON P2 (VARBIN);
CREATE INDEX IDX_P2_POLY ON P2 (POLYGON);

CREATE TABLE R3 (
  ID      INTEGER NOT NULL,
  TINY    TINYINT,
  SMALL   SMALLINT,
  INT     INTEGER,
  BIG     BIGINT,
  NUM     FLOAT,
  DEC     DECIMAL,
  VCHAR_INLINE     VARCHAR(42 BYTES),
  VCHAR_INLINE_MAX VARCHAR(15),
  VCHAR            VARCHAR(16),
  VCHAR_JSON       VARCHAR(4000 BYTES),
  TIME    TIMESTAMP,
  VARBIN  VARBINARY(100),
  POINT   GEOGRAPHY_POINT,
  POLYGON GEOGRAPHY,
  PRIMARY KEY (VCHAR)
  -- Will not work with SqlCoverage/PostgreSQL (2 lines):
  , CONSTRAINT IDX_R3_TV  UNIQUE (TINY, VCHAR)
  , CONSTRAINT IDX_R3_VSI UNIQUE (VCHAR_INLINE, INT, NUM)
);

CREATE TABLE P3 (
  ID      INTEGER,
  TINY    TINYINT,
  SMALL   SMALLINT,
  INT     INTEGER,
  BIG     BIGINT,
  NUM     FLOAT,
  DEC     DECIMAL,
  VCHAR_INLINE     VARCHAR(42 BYTES),
  VCHAR_INLINE_MAX VARCHAR(15),
  VCHAR            VARCHAR(16) NOT NULL,
  VCHAR_JSON       VARCHAR(4000 BYTES),
  TIME    TIMESTAMP,
  VARBIN  VARBINARY(100),
  POINT   GEOGRAPHY_POINT,
  POLYGON GEOGRAPHY,
  PRIMARY KEY (VCHAR)
  -- Will not work with SqlCoverage/PostgreSQL (2 lines):
  , CONSTRAINT IDX_P3_TV        UNIQUE (TINY, VCHAR)
  , CONSTRAINT IDX_P3_VSI ASSUMEUNIQUE (VCHAR_INLINE, INT, NUM)
);
PARTITION TABLE P3 ON COLUMN VCHAR;

CREATE TABLE R4 (
  ID      INTEGER  DEFAULT 0,
  TINY    TINYINT  DEFAULT 0,
  SMALL   SMALLINT DEFAULT 0,
  INT     INTEGER  DEFAULT 0,
  BIG     BIGINT   DEFAULT 0,
  NUM     FLOAT    DEFAULT 0,
  DEC     DECIMAL  DEFAULT 0,
  VCHAR_INLINE     VARCHAR(14)       DEFAULT '0',
  VCHAR_INLINE_MAX VARCHAR(63 BYTES) DEFAULT '0',
  VCHAR            VARCHAR(64 BYTES) DEFAULT '0' NOT NULL,
  VCHAR_JSON       VARCHAR(1000)     DEFAULT '0',
  TIME    TIMESTAMP       DEFAULT '2013-10-30 23:22:29',
  VARBIN  VARBINARY(100)  DEFAULT x'00',
  -- Default values of GEOGRAPHY_POINT and GEOGRAPHY not supported (ENG-12028)
  POINT   GEOGRAPHY_POINT,
  POLYGON GEOGRAPHY,
  PRIMARY KEY (ID, VCHAR)
);
-- Will not work with SqlCoverage/PostgreSQL (2 lines):
CREATE UNIQUE INDEX IDX_R4_TV  ON R4 (TINY, VCHAR);
CREATE UNIQUE INDEX IDX_R4_VSI ON R4 (VCHAR, SMALL, INT);

CREATE TABLE P4 (
  ID      INTEGER  DEFAULT 0,
  TINY    TINYINT  DEFAULT 0,
  SMALL   SMALLINT DEFAULT 0,
  INT     INTEGER  DEFAULT 0,
  BIG     BIGINT   DEFAULT 0,
  NUM     FLOAT    DEFAULT 0,
  DEC     DECIMAL  DEFAULT 0,
  VCHAR_INLINE     VARCHAR(14)       DEFAULT '0',
  VCHAR_INLINE_MAX VARCHAR(63 BYTES) DEFAULT '0',
  VCHAR            VARCHAR(64 BYTES) DEFAULT '0' NOT NULL,
  VCHAR_JSON       VARCHAR(1000)     DEFAULT '0',
  TIME    TIMESTAMP       DEFAULT '2013-10-30 23:22:29',
  VARBIN  VARBINARY(100)  DEFAULT x'00',
  -- Default values of GEOGRAPHY_POINT and GEOGRAPHY not supported (ENG-12028)
  POINT   GEOGRAPHY_POINT,
  POLYGON GEOGRAPHY,
  PRIMARY KEY (ID, VCHAR)
);
PARTITION TABLE P4 ON COLUMN VCHAR;
-- Will not work with SqlCoverage/PostgreSQL (2 lines):
CREATE       UNIQUE INDEX IDX_P4_TV  ON P4 (TINY, VCHAR);
CREATE ASSUMEUNIQUE INDEX IDX_P4_VSI ON P4 (VCHAR_INLINE_MAX, SMALL, INT);

CREATE TABLE R5 (
  ID      INTEGER  NOT NULL,
  TINY    TINYINT  NOT NULL,
  SMALL   SMALLINT NOT NULL,
  INT     INTEGER  NOT NULL,
  BIG     BIGINT   NOT NULL,
  NUM     FLOAT    NOT NULL,
  DEC     DECIMAL  NOT NULL,
  VCHAR_INLINE     VARCHAR(42 BYTES)   NOT NULL,
  VCHAR_INLINE_MAX VARCHAR(15)         NOT NULL,
  VCHAR            VARCHAR(16)         NOT NULL,
  VCHAR_JSON       VARCHAR(4000 BYTES) NOT NULL,
  TIME    TIMESTAMP       NOT NULL,
  VARBIN  VARBINARY(100)  NOT NULL,
  POINT   GEOGRAPHY_POINT NOT NULL,
  POLYGON GEOGRAPHY       NOT NULL,
  PRIMARY KEY (VCHAR, ID)
);
CREATE       UNIQUE INDEX IDX_R5_IV  ON R5 (ID, VCHAR)                WHERE ID >= 0;
CREATE ASSUMEUNIQUE INDEX IDX_R5_VSI ON R5 (VCHAR_INLINE, SMALL, INT) WHERE VCHAR_INLINE_MAX < 'a';
CREATE              INDEX IDX_R5_IVI ON R5 (INT, VCHAR_INLINE_MAX)    WHERE INT >= 0 AND VCHAR_INLINE IS NOT NULL;

CREATE TABLE P5 (
  ID      INTEGER  NOT NULL,
  TINY    TINYINT  NOT NULL,
  SMALL   SMALLINT NOT NULL,
  INT     INTEGER  NOT NULL,
  BIG     BIGINT   NOT NULL,
  NUM     FLOAT    NOT NULL,
  DEC     DECIMAL  NOT NULL,
  VCHAR_INLINE     VARCHAR(42 BYTES)   NOT NULL,
  VCHAR_INLINE_MAX VARCHAR(15)         NOT NULL,
  VCHAR            VARCHAR(16)         NOT NULL,
  VCHAR_JSON       VARCHAR(4000 BYTES) NOT NULL,
  TIME    TIMESTAMP       NOT NULL,
  VARBIN  VARBINARY(100)  NOT NULL,
  POINT   GEOGRAPHY_POINT NOT NULL,
  POLYGON GEOGRAPHY       NOT NULL,
  PRIMARY KEY (VCHAR, ID)
);
PARTITION TABLE P5 ON COLUMN ID;
CREATE       UNIQUE INDEX IDX_P5_IV  ON P5 (ID, VCHAR)                WHERE ID >= 0;
CREATE ASSUMEUNIQUE INDEX IDX_P5_VSI ON P5 (VCHAR_INLINE, SMALL, INT) WHERE VCHAR_INLINE_MAX < 'a';
CREATE              INDEX IDX_P5_IVI ON P5 (INT, VCHAR_INLINE_MAX)    WHERE INT >= 0 AND VCHAR_INLINE IS NOT NULL;

CREATE TABLE R6 (
  ID      INTEGER  DEFAULT 0 NOT NULL,
  TINY    TINYINT  DEFAULT 0 NOT NULL,
  SMALL   SMALLINT DEFAULT 0 NOT NULL,
  INT     INTEGER  DEFAULT 0 NOT NULL,
  BIG     BIGINT   DEFAULT 0 NOT NULL,
  NUM     FLOAT    DEFAULT 0 NOT NULL,
  DEC     DECIMAL  DEFAULT 0 NOT NULL,
  VCHAR_INLINE     VARCHAR(14)       DEFAULT '0' NOT NULL,
  VCHAR_INLINE_MAX VARCHAR(63 BYTES) DEFAULT '0' NOT NULL,
  VCHAR            VARCHAR(64 BYTES) DEFAULT '0' NOT NULL,
  VCHAR_JSON       VARCHAR(1000)     DEFAULT '0' NOT NULL,
  TIME    TIMESTAMP       DEFAULT '2013-10-30 23:22:29' NOT NULL,
  VARBIN  VARBINARY(100)  DEFAULT x'00' NOT NULL,
  -- Default values of GEOGRAPHY_POINT and GEOGRAPHY not supported (ENG-12028)
  POINT   GEOGRAPHY_POINT,
  POLYGON GEOGRAPHY,
  PRIMARY KEY (VARBIN)
  -- Will not work with SqlCoverage/PostgreSQL:
  , LIMIT PARTITION ROWS 5
);

CREATE TABLE P6 (
  ID      INTEGER  DEFAULT 0 NOT NULL,
  TINY    TINYINT  DEFAULT 0 NOT NULL,
  SMALL   SMALLINT DEFAULT 0 NOT NULL,
  INT     INTEGER  DEFAULT 0 NOT NULL,
  BIG     BIGINT   DEFAULT 0 NOT NULL,
  NUM     FLOAT    DEFAULT 0 NOT NULL,
  DEC     DECIMAL  DEFAULT 0 NOT NULL,
  VCHAR_INLINE     VARCHAR(14)       DEFAULT '0' NOT NULL,
  VCHAR_INLINE_MAX VARCHAR(63 BYTES) DEFAULT '0' NOT NULL,
  VCHAR            VARCHAR(64 BYTES) DEFAULT '0' NOT NULL,
  VCHAR_JSON       VARCHAR(1000)     DEFAULT '0' NOT NULL,
  TIME    TIMESTAMP       DEFAULT '2013-10-30 23:22:29' NOT NULL,
  VARBIN  VARBINARY(100)  DEFAULT x'00' NOT NULL,
  -- Default values of GEOGRAPHY_POINT and GEOGRAPHY not supported (ENG-12028)
  POINT   GEOGRAPHY_POINT,
  POLYGON GEOGRAPHY,
  PRIMARY KEY (VARBIN)
  -- Will not work with SqlCoverage/PostgreSQL:
  , LIMIT PARTITION ROWS 5
);
PARTITION TABLE P6 ON COLUMN VARBIN;

CREATE TABLE R7 (
  ID      INTEGER  UNIQUE,
  TINY    TINYINT  UNIQUE,
  SMALL   SMALLINT UNIQUE,
  INT     INTEGER  UNIQUE,
  BIG     BIGINT   UNIQUE,
  NUM     FLOAT    UNIQUE,
  DEC     DECIMAL  UNIQUE,
  VCHAR_INLINE     VARCHAR(42 BYTES)   UNIQUE,
  VCHAR_INLINE_MAX VARCHAR(15)         UNIQUE,
  VCHAR            VARCHAR(16)         UNIQUE,
  VCHAR_JSON       VARCHAR(4000 BYTES) UNIQUE,
  TIME    TIMESTAMP       UNIQUE,
  VARBIN  VARBINARY(100)  UNIQUE,
  POINT   GEOGRAPHY_POINT,
  POLYGON GEOGRAPHY,
  PRIMARY KEY (ID, VCHAR, VARBIN)
  -- Will not work with SqlCoverage/PostgreSQL:
  , LIMIT PARTITION ROWS 6 EXECUTE
      (DELETE FROM R7 ORDER BY ID, VCHAR, VARBIN LIMIT 3)
);

CREATE TABLE P7 (
  ID      INTEGER  ASSUMEUNIQUE,
  TINY    TINYINT  ASSUMEUNIQUE,
  SMALL   SMALLINT ASSUMEUNIQUE,
  INT     INTEGER  ASSUMEUNIQUE,
  BIG     BIGINT   ASSUMEUNIQUE,
  NUM     FLOAT    ASSUMEUNIQUE,
  DEC     DECIMAL  ASSUMEUNIQUE,
  VCHAR_INLINE     VARCHAR(42 BYTES)   ASSUMEUNIQUE,
  VCHAR_INLINE_MAX VARCHAR(15)         ASSUMEUNIQUE,
  VCHAR            VARCHAR(16)         ASSUMEUNIQUE,
  VCHAR_JSON       VARCHAR(4000 BYTES) ASSUMEUNIQUE,
  TIME    TIMESTAMP       ASSUMEUNIQUE,
  VARBIN  VARBINARY(100)  NOT NULL UNIQUE,
  POINT   GEOGRAPHY_POINT,
  POLYGON GEOGRAPHY,
  PRIMARY KEY (ID, VCHAR, VARBIN)
  -- Will not work with SqlCoverage/PostgreSQL:
  , LIMIT PARTITION ROWS 6 EXECUTE
      (DELETE FROM P7 ORDER BY ID, VCHAR, VARBIN LIMIT 3)
);
PARTITION TABLE P7 ON COLUMN VARBIN;



CREATE VIEW VR1 (TINY,
    ID, SMALL, INT, BIG, NUM, DEC,
    VCHAR_INLINE, VCHAR_INLINE_MAX, VCHAR, VCHAR_JSON, TIME
    -- Will not work with SqlCoverage/PostgreSQL:
    , VARBIN, POINT, POLYGON
    ) AS
  SELECT TINY,
    COUNT(*), SUM(SMALL), COUNT(INT), MIN(BIG), MAX(NUM), SUM(DEC),
    MIN(VCHAR_INLINE), MIN(VCHAR_INLINE_MAX), MIN(VCHAR), MIN(VCHAR_JSON), MIN(TIME)
    -- Will not work with SqlCoverage/PostgreSQL:
    , MIN(VARBIN), MIN(POINT), MIN(POLYGON)
  FROM R1
GROUP BY TINY;

CREATE VIEW VP1 (TINY,
    ID, SMALL, INT, BIG, NUM, DEC,
    VCHAR_INLINE, VCHAR_INLINE_MAX, VCHAR, VCHAR_JSON, TIME
    -- Will not work with SqlCoverage/PostgreSQL:
    , VARBIN, POINT, POLYGON
    ) AS
  SELECT TINY,
    COUNT(*), SUM(SMALL), COUNT(INT), MIN(BIG), MAX(NUM), SUM(DEC),
    MIN(VCHAR_INLINE), MIN(VCHAR_INLINE_MAX), MIN(VCHAR), MIN(VCHAR_JSON), MIN(TIME)
    -- Will not work with SqlCoverage/PostgreSQL:
    , MIN(VARBIN), MIN(POINT), MIN(POLYGON)
  FROM P1
GROUP BY TINY;


CREATE VIEW VR2 (TINY,
    ID, SMALL, INT, BIG, NUM, DEC,
    VCHAR_INLINE, VCHAR_INLINE_MAX, VCHAR, VCHAR_JSON, TIME
    -- Will not work with SqlCoverage/PostgreSQL:
    , VARBIN, POINT, POLYGON
    ) AS
  SELECT TINY,
    COUNT(*), COUNT(SMALL), MIN(INT), MAX(BIG), SUM(NUM), MIN(DEC),
    MAX(VCHAR_INLINE), MAX(VCHAR_INLINE_MAX), MAX(VCHAR), MAX(VCHAR_JSON), MAX(TIME)
    -- Will not work with SqlCoverage/PostgreSQL:
    , MAX(VARBIN), MAX(POINT), MAX(POLYGON)
  FROM R2 WHERE ABS(TINY) < 64
GROUP BY TINY;

CREATE VIEW VP2 (TINY,
    ID, SMALL, INT, BIG, NUM, DEC,
    VCHAR_INLINE, VCHAR_INLINE_MAX, VCHAR, VCHAR_JSON,TIME
    -- Will not work with SqlCoverage/PostgreSQL:
    , VARBIN, POINT, POLYGON
    ) AS
  SELECT TINY,
    COUNT(*), COUNT(SMALL), MIN(INT), MAX(BIG), SUM(NUM), MIN(DEC),
    MAX(VCHAR_INLINE), MAX(VCHAR_INLINE_MAX), MAX(VCHAR), MAX(VCHAR_JSON), MAX(TIME)
    -- Will not work with SqlCoverage/PostgreSQL:
    , MAX(VARBIN), MAX(POINT), MAX(POLYGON)
  FROM P2 WHERE ABS(TINY) < 64
GROUP BY TINY;


CREATE VIEW VR3 (VCHAR_INLINE_MAX,
    ID, TINY, SMALL, INT, BIG, NUM, DEC,
    VCHAR_INLINE, VCHAR, VCHAR_JSON, TIME
    -- Will not work with SqlCoverage/PostgreSQL:
    , VARBIN, POINT, POLYGON
    ) AS
  SELECT VCHAR_INLINE_MAX,
    COUNT(*), COUNT(TINY), MIN(SMALL), MAX(INT), SUM(BIG), MIN(NUM), MAX(DEC),
    MIN(VCHAR_INLINE), MAX(VCHAR), MAX(VCHAR_JSON), MIN(TIME)
    -- Will not work with SqlCoverage/PostgreSQL:
    , MAX(VARBIN), MIN(POINT), MAX(POLYGON)
  FROM R3
GROUP BY VCHAR_INLINE_MAX;

CREATE VIEW VP3 (VCHAR_INLINE_MAX,
    ID, TINY, SMALL, INT, BIG, NUM, DEC,
    VCHAR_INLINE, VCHAR, VCHAR_JSON, TIME
    -- Will not work with SqlCoverage/PostgreSQL:
    , VARBIN, POINT, POLYGON
    ) AS
  SELECT VCHAR_INLINE_MAX,
    COUNT(*), COUNT(TINY), MIN(SMALL), MAX(INT), SUM(BIG), MIN(NUM), MAX(DEC),
    MIN(VCHAR_INLINE), MAX(VCHAR), MAX(VCHAR_JSON), MIN(TIME)
    -- Will not work with SqlCoverage/PostgreSQL:
    , MAX(VARBIN), MIN(POINT), MAX(POLYGON)
  FROM P3
GROUP BY VCHAR_INLINE_MAX;


CREATE VIEW VR4 (VCHAR, BIG,
    ID, TINY, SMALL, INT, NUM, DEC,
    VCHAR_INLINE, VCHAR_INLINE_MAX, VCHAR_JSON, TIME
    -- Will not work with SqlCoverage/PostgreSQL:
    , VARBIN, POINT, POLYGON
    ) AS
  SELECT VCHAR, BIG,
    COUNT(*), SUM(TINY), MAX(SMALL), COUNT(VCHAR_INLINE_MAX), MAX(NUM), MIN(DEC),
    MAX(VCHAR_INLINE), MIN(VCHAR_INLINE_MAX), MIN(VCHAR_JSON), MAX(TIME)
    -- Will not work with SqlCoverage/PostgreSQL:
    , MIN(VARBIN), MAX(POINT), MIN(POLYGON)
  FROM R4 WHERE VCHAR_INLINE < 'N'
GROUP BY VCHAR, BIG;
CREATE INDEX IDX_VR4_VB  ON VR4 (VCHAR, BIG)             WHERE BIG >= 0;
CREATE INDEX IDX_VR4_IDV ON VR4 (INT, DEC, VCHAR_INLINE) WHERE VCHAR_INLINE < 'a';
CREATE INDEX IDX_VR4_VMB ON VR4 (VCHAR_INLINE_MAX, BIG)  WHERE BIG >= 0 AND VCHAR_INLINE_MAX IS NOT NULL;

CREATE VIEW VP4 (VCHAR, BIG,
    ID, TINY, SMALL, INT, NUM, DEC,
    VCHAR_INLINE, VCHAR_INLINE_MAX, VCHAR_JSON, TIME
    -- Will not work with SqlCoverage/PostgreSQL:
    , VARBIN, POINT, POLYGON
    ) AS
  SELECT VCHAR, BIG,
    COUNT(*), SUM(TINY), MAX(SMALL), COUNT(VCHAR_INLINE_MAX), MAX(NUM), MIN(DEC),
    MAX(VCHAR_INLINE), MIN(VCHAR_INLINE_MAX), MIN(VCHAR_JSON), MAX(TIME)
    -- Will not work with SqlCoverage/PostgreSQL:
    , MIN(VARBIN), MAX(POINT), MIN(POLYGON)
  FROM P4 WHERE VCHAR_INLINE < 'N'
GROUP BY VCHAR, BIG;
CREATE INDEX IDX_VP4_VB  ON VP4 (VCHAR, BIG)             WHERE BIG >= 0;
CREATE INDEX IDX_VP4_IDV ON VP4 (INT, DEC, VCHAR_INLINE) WHERE VCHAR_INLINE < 'a';
CREATE INDEX IDX_VP4_VMB ON VP4 (VCHAR_INLINE_MAX, BIG)  WHERE BIG >= 0 AND VCHAR_INLINE_MAX IS NOT NULL;


CREATE VIEW VR5 (SMALL, VCHAR, TINY,
    ID, INT, BIG, NUM, DEC,
    VCHAR_INLINE, VCHAR_INLINE_MAX, VCHAR_JSON, TIME
    -- Will not work with SqlCoverage/PostgreSQL:
    , VARBIN, POINT, POLYGON
    ) AS
  SELECT SMALL, VCHAR, TINY,
    COUNT(*), COUNT(TIME), COUNT(POINT), SUM(NUM), SUM(DEC),
    MIN(VCHAR_INLINE), MAX(VCHAR_INLINE_MAX), MAX(VCHAR_JSON), MIN(TIME)
    -- Will not work with SqlCoverage/PostgreSQL:
    , MAX(VARBIN), MIN(POINT), MAX(POLYGON)
  FROM R5 WHERE TINY < 64
GROUP BY SMALL, VCHAR, TINY;
CREATE INDEX IDX_VR5_SVT ON VR5 (SMALL, VCHAR, TINY)      WHERE SMALL >= 0;
CREATE INDEX IDX_VR5_VID ON VR5 (VCHAR_INLINE, INT, DEC)  WHERE VCHAR_INLINE < 'a';
CREATE INDEX IDX_VR5_VS  ON VR5 (VCHAR_INLINE_MAX, SMALL) WHERE SMALL >= 0 AND VCHAR_INLINE_MAX IS NOT NULL;


CREATE VIEW VP5 (SMALL, VCHAR, TINY,
    ID, INT, BIG, NUM, DEC,
    VCHAR_INLINE, VCHAR_INLINE_MAX, VCHAR_JSON, TIME
    -- Will not work with SqlCoverage/PostgreSQL:
    , VARBIN, POINT, POLYGON
    ) AS
  SELECT SMALL, VCHAR, TINY,
    COUNT(*), COUNT(VARBIN), COUNT(POLYGON), SUM(NUM), SUM(DEC),
    MIN(VCHAR_INLINE), MAX(VCHAR_INLINE_MAX), MAX(VCHAR_JSON), MIN(TIME)
    -- Will not work with SqlCoverage/PostgreSQL:
    , MAX(VARBIN), MIN(POINT), MAX(POLYGON)
  FROM P5 WHERE TINY < 64
GROUP BY SMALL, VCHAR, TINY;
CREATE INDEX IDX_VP5_SVT ON VP5 (SMALL, VCHAR, TINY)      WHERE SMALL >= 0;
CREATE INDEX IDX_VP5_VID ON VP5 (VCHAR_INLINE, INT, DEC)  WHERE VCHAR_INLINE < 'a';
CREATE INDEX IDX_VP5_VS  ON VP5 (VCHAR_INLINE_MAX, SMALL) WHERE SMALL >= 0 AND VCHAR_INLINE_MAX IS NOT NULL;
