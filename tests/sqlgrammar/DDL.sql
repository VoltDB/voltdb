-- Define "standard" DDL (tables, indexes, views), for use with the SQL grammar generator

-- Drop all items first, in case they already exist
file -inlinebatch END_OF_BATCH_1

DROP PROCEDURE RPROC0      IF EXISTS;
DROP PROCEDURE RPROC1      IF EXISTS;
DROP PROCEDURE RPROC2      IF EXISTS;
DROP PROCEDURE RPROC3      IF EXISTS;
DROP PROCEDURE RPROC4      IF EXISTS;
DROP PROCEDURE RPROC5      IF EXISTS;
DROP PROCEDURE RPROC6      IF EXISTS;
DROP PROCEDURE RPROC7      IF EXISTS;
DROP PROCEDURE RPROC8      IF EXISTS;
DROP PROCEDURE RPROC9      IF EXISTS;

DROP PROCEDURE SSPR0min    IF EXISTS;
DROP PROCEDURE SSPR0max    IF EXISTS;
DROP PROCEDURE SSPR0insMin IF EXISTS;
DROP PROCEDURE SSPR0insMax IF EXISTS;
DROP PROCEDURE SSPR0ins    IF EXISTS;
DROP PROCEDURE SSPR0sel    IF EXISTS;
DROP PROCEDURE SSPP0min    IF EXISTS;
DROP PROCEDURE SSPP0max    IF EXISTS;
DROP PROCEDURE SSPP0insMin IF EXISTS;
DROP PROCEDURE SSPP0insMax IF EXISTS;
DROP PROCEDURE SSPP0ins    IF EXISTS;
DROP PROCEDURE SSPP0sel    IF EXISTS;
DROP PROCEDURE SSPR1min    IF EXISTS;
DROP PROCEDURE SSPR1max    IF EXISTS;
DROP PROCEDURE SSPR1insMin IF EXISTS;
DROP PROCEDURE SSPR1insMax IF EXISTS;
DROP PROCEDURE SSPR1ins    IF EXISTS;
DROP PROCEDURE SSPR1sel    IF EXISTS;
DROP PROCEDURE SSPP1min    IF EXISTS;
DROP PROCEDURE SSPP1max    IF EXISTS;
DROP PROCEDURE SSPP1insMin IF EXISTS;
DROP PROCEDURE SSPP1insMax IF EXISTS;
DROP PROCEDURE SSPP1ins    IF EXISTS;
DROP PROCEDURE SSPP1sel    IF EXISTS;
DROP PROCEDURE SSPR2min    IF EXISTS;
DROP PROCEDURE SSPR2max    IF EXISTS;
DROP PROCEDURE SSPR2insMin IF EXISTS;
DROP PROCEDURE SSPR2insMax IF EXISTS;
DROP PROCEDURE SSPR2ins    IF EXISTS;
DROP PROCEDURE SSPR2sel    IF EXISTS;
DROP PROCEDURE SSPP2min    IF EXISTS;
DROP PROCEDURE SSPP2max    IF EXISTS;
DROP PROCEDURE SSPP2insMin IF EXISTS;
DROP PROCEDURE SSPP2insMax IF EXISTS;
DROP PROCEDURE SSPP2ins    IF EXISTS;
DROP PROCEDURE SSPP2sel    IF EXISTS;
DROP PROCEDURE SSPR3min    IF EXISTS;
DROP PROCEDURE SSPR3max    IF EXISTS;
DROP PROCEDURE SSPR3insMin IF EXISTS;
DROP PROCEDURE SSPR3insMax IF EXISTS;
DROP PROCEDURE SSPR3ins    IF EXISTS;
DROP PROCEDURE SSPR3sel    IF EXISTS;
DROP PROCEDURE SSPP3min    IF EXISTS;
DROP PROCEDURE SSPP3max    IF EXISTS;
DROP PROCEDURE SSPP3insMin IF EXISTS;
DROP PROCEDURE SSPP3insMax IF EXISTS;
DROP PROCEDURE SSPP3ins    IF EXISTS;
DROP PROCEDURE SSPP3sel    IF EXISTS;
DROP PROCEDURE SSPR4min    IF EXISTS;
DROP PROCEDURE SSPR4max    IF EXISTS;
DROP PROCEDURE SSPR4insMin IF EXISTS;
DROP PROCEDURE SSPR4insMax IF EXISTS;
DROP PROCEDURE SSPR4ins    IF EXISTS;
DROP PROCEDURE SSPR4sel    IF EXISTS;
DROP PROCEDURE SSPP4min    IF EXISTS;
DROP PROCEDURE SSPP4max    IF EXISTS;
DROP PROCEDURE SSPP4insMin IF EXISTS;
DROP PROCEDURE SSPP4insMax IF EXISTS;
DROP PROCEDURE SSPP4ins    IF EXISTS;
DROP PROCEDURE SSPP4sel    IF EXISTS;
DROP PROCEDURE SSPR5min    IF EXISTS;
DROP PROCEDURE SSPR5max    IF EXISTS;
DROP PROCEDURE SSPR5insMin IF EXISTS;
DROP PROCEDURE SSPR5insMax IF EXISTS;
DROP PROCEDURE SSPR5ins    IF EXISTS;
DROP PROCEDURE SSPR5sel    IF EXISTS;
DROP PROCEDURE SSPP5min    IF EXISTS;
DROP PROCEDURE SSPP5max    IF EXISTS;
DROP PROCEDURE SSPP5insMin IF EXISTS;
DROP PROCEDURE SSPP5insMax IF EXISTS;
DROP PROCEDURE SSPP5ins    IF EXISTS;
DROP PROCEDURE SSPP5sel    IF EXISTS;
DROP PROCEDURE SSPR6min    IF EXISTS;
DROP PROCEDURE SSPR6max    IF EXISTS;
DROP PROCEDURE SSPR6insMin IF EXISTS;
DROP PROCEDURE SSPR6insMax IF EXISTS;
DROP PROCEDURE SSPR6ins    IF EXISTS;
DROP PROCEDURE SSPR6sel    IF EXISTS;
DROP PROCEDURE SSPP6min    IF EXISTS;
DROP PROCEDURE SSPP6max    IF EXISTS;
DROP PROCEDURE SSPP6insMin IF EXISTS;
DROP PROCEDURE SSPP6insMax IF EXISTS;
DROP PROCEDURE SSPP6ins    IF EXISTS;
DROP PROCEDURE SSPP6sel    IF EXISTS;
DROP PROCEDURE SSPR7min    IF EXISTS;
DROP PROCEDURE SSPR7max    IF EXISTS;
DROP PROCEDURE SSPR7insMin IF EXISTS;
DROP PROCEDURE SSPR7insMax IF EXISTS;
DROP PROCEDURE SSPR7ins    IF EXISTS;
DROP PROCEDURE SSPR7sel    IF EXISTS;
DROP PROCEDURE SSPP7min    IF EXISTS;
DROP PROCEDURE SSPP7max    IF EXISTS;
DROP PROCEDURE SSPP7insMin IF EXISTS;
DROP PROCEDURE SSPP7insMax IF EXISTS;
DROP PROCEDURE SSPP7ins    IF EXISTS;
DROP PROCEDURE SSPP7sel    IF EXISTS;

DROP PROCEDURE JSPR0min    IF EXISTS;
DROP PROCEDURE JSPR0max    IF EXISTS;
DROP PROCEDURE JSPR0insMin IF EXISTS;
DROP PROCEDURE JSPR0insMax IF EXISTS;
DROP PROCEDURE JSPR0ins    IF EXISTS;
DROP PROCEDURE JSPR0sel    IF EXISTS;
DROP PROCEDURE JSPP0min    IF EXISTS;
DROP PROCEDURE JSPP0max    IF EXISTS;
DROP PROCEDURE JSPP0insMin IF EXISTS;
DROP PROCEDURE JSPP0insMax IF EXISTS;
DROP PROCEDURE JSPP0ins    IF EXISTS;
DROP PROCEDURE JSPP0sel    IF EXISTS;
DROP PROCEDURE JSPR1min    IF EXISTS;
DROP PROCEDURE JSPR1max    IF EXISTS;
DROP PROCEDURE JSPR1insMin IF EXISTS;
DROP PROCEDURE JSPR1insMax IF EXISTS;
DROP PROCEDURE JSPR1ins    IF EXISTS;
DROP PROCEDURE JSPR1sel    IF EXISTS;
DROP PROCEDURE JSPP1min    IF EXISTS;
DROP PROCEDURE JSPP1max    IF EXISTS;
DROP PROCEDURE JSPP1insMin IF EXISTS;
DROP PROCEDURE JSPP1insMax IF EXISTS;
DROP PROCEDURE JSPP1ins    IF EXISTS;
DROP PROCEDURE JSPP1sel    IF EXISTS;
DROP PROCEDURE JSPR2min    IF EXISTS;
DROP PROCEDURE JSPR2max    IF EXISTS;
DROP PROCEDURE JSPR2insMin IF EXISTS;
DROP PROCEDURE JSPR2insMax IF EXISTS;
DROP PROCEDURE JSPR2ins    IF EXISTS;
DROP PROCEDURE JSPR2sel    IF EXISTS;
DROP PROCEDURE JSPP2min    IF EXISTS;
DROP PROCEDURE JSPP2max    IF EXISTS;
DROP PROCEDURE JSPP2insMin IF EXISTS;
DROP PROCEDURE JSPP2insMax IF EXISTS;
DROP PROCEDURE JSPP2ins    IF EXISTS;
DROP PROCEDURE JSPP2sel    IF EXISTS;
DROP PROCEDURE JSPR3min    IF EXISTS;
DROP PROCEDURE JSPR3max    IF EXISTS;
DROP PROCEDURE JSPR3insMin IF EXISTS;
DROP PROCEDURE JSPR3insMax IF EXISTS;
DROP PROCEDURE JSPR3ins    IF EXISTS;
DROP PROCEDURE JSPR3sel    IF EXISTS;
DROP PROCEDURE JSPP3min    IF EXISTS;
DROP PROCEDURE JSPP3max    IF EXISTS;
DROP PROCEDURE JSPP3insMin IF EXISTS;
DROP PROCEDURE JSPP3insMax IF EXISTS;
DROP PROCEDURE JSPP3ins    IF EXISTS;
DROP PROCEDURE JSPP3sel    IF EXISTS;
DROP PROCEDURE JSPR4min    IF EXISTS;
DROP PROCEDURE JSPR4max    IF EXISTS;
DROP PROCEDURE JSPR4insMin IF EXISTS;
DROP PROCEDURE JSPR4insMax IF EXISTS;
DROP PROCEDURE JSPR4ins    IF EXISTS;
DROP PROCEDURE JSPR4sel    IF EXISTS;
DROP PROCEDURE JSPP4min    IF EXISTS;
DROP PROCEDURE JSPP4max    IF EXISTS;
DROP PROCEDURE JSPP4insMin IF EXISTS;
DROP PROCEDURE JSPP4insMax IF EXISTS;
DROP PROCEDURE JSPP4ins    IF EXISTS;
DROP PROCEDURE JSPP4sel    IF EXISTS;
DROP PROCEDURE JSPR5min    IF EXISTS;
DROP PROCEDURE JSPR5max    IF EXISTS;
DROP PROCEDURE JSPR5insMin IF EXISTS;
DROP PROCEDURE JSPR5insMax IF EXISTS;
DROP PROCEDURE JSPR5ins    IF EXISTS;
DROP PROCEDURE JSPR5sel    IF EXISTS;
DROP PROCEDURE JSPP5min    IF EXISTS;
DROP PROCEDURE JSPP5max    IF EXISTS;
DROP PROCEDURE JSPP5insMin IF EXISTS;
DROP PROCEDURE JSPP5insMax IF EXISTS;
DROP PROCEDURE JSPP5ins    IF EXISTS;
DROP PROCEDURE JSPP5sel    IF EXISTS;
DROP PROCEDURE JSPR6min    IF EXISTS;
DROP PROCEDURE JSPR6max    IF EXISTS;
DROP PROCEDURE JSPR6insMin IF EXISTS;
DROP PROCEDURE JSPR6insMax IF EXISTS;
DROP PROCEDURE JSPR6ins    IF EXISTS;
DROP PROCEDURE JSPR6sel    IF EXISTS;
DROP PROCEDURE JSPP6min    IF EXISTS;
DROP PROCEDURE JSPP6max    IF EXISTS;
DROP PROCEDURE JSPP6insMin IF EXISTS;
DROP PROCEDURE JSPP6insMax IF EXISTS;
DROP PROCEDURE JSPP6ins    IF EXISTS;
DROP PROCEDURE JSPP6sel    IF EXISTS;
DROP PROCEDURE JSPR7min    IF EXISTS;
DROP PROCEDURE JSPR7max    IF EXISTS;
DROP PROCEDURE JSPR7insMin IF EXISTS;
DROP PROCEDURE JSPR7insMax IF EXISTS;
DROP PROCEDURE JSPR7ins    IF EXISTS;
DROP PROCEDURE JSPR7sel    IF EXISTS;
DROP PROCEDURE JSPP7min    IF EXISTS;
DROP PROCEDURE JSPP7max    IF EXISTS;
DROP PROCEDURE JSPP7insMin IF EXISTS;
DROP PROCEDURE JSPP7insMax IF EXISTS;
DROP PROCEDURE JSPP7ins    IF EXISTS;
DROP PROCEDURE JSPP7sel    IF EXISTS;

END_OF_BATCH_1

remove classes sqlgrammartest.*;

file -inlinebatch END_OF_BATCH_2

DROP TABLE R0 IF EXISTS CASCADE;
DROP TABLE P0 IF EXISTS CASCADE;
DROP TABLE R1 IF EXISTS CASCADE;
DROP TABLE P1 IF EXISTS CASCADE;
DROP TABLE R2 IF EXISTS CASCADE;
DROP TABLE P2 IF EXISTS CASCADE;
DROP TABLE R3 IF EXISTS CASCADE;
DROP TABLE P3 IF EXISTS CASCADE;
DROP TABLE R4 IF EXISTS CASCADE;
DROP TABLE P4 IF EXISTS CASCADE;
DROP TABLE R5 IF EXISTS CASCADE;
DROP TABLE P5 IF EXISTS CASCADE;
DROP TABLE R6 IF EXISTS CASCADE;
DROP TABLE P6 IF EXISTS CASCADE;
DROP TABLE R7 IF EXISTS CASCADE;
DROP TABLE P7 IF EXISTS CASCADE;
DROP TABLE R11 IF EXISTS CASCADE;
DROP TABLE P11 IF EXISTS CASCADE;
DROP TABLE R12 IF EXISTS CASCADE;
DROP TABLE P12 IF EXISTS CASCADE;
DROP TABLE R13 IF EXISTS CASCADE;
DROP TABLE P13 IF EXISTS CASCADE;
DROP TABLE R14 IF EXISTS CASCADE;
DROP TABLE P14 IF EXISTS CASCADE;
DROP TABLE R21 IF EXISTS CASCADE;
DROP TABLE P21 IF EXISTS CASCADE;
DROP TABLE R31 IF EXISTS CASCADE;
DROP TABLE P31 IF EXISTS CASCADE;

-- Drop the tables that may or may not have been created via randomized DDL
-- during a previous last run
DROP TABLE DT00 IF EXISTS CASCADE;
DROP TABLE DT01 IF EXISTS CASCADE;
DROP TABLE DT02 IF EXISTS CASCADE;
DROP TABLE DT03 IF EXISTS CASCADE;
DROP TABLE DT04 IF EXISTS CASCADE;
DROP TABLE DT05 IF EXISTS CASCADE;
DROP TABLE DT06 IF EXISTS CASCADE;
DROP TABLE DT07 IF EXISTS CASCADE;
DROP TABLE DT08 IF EXISTS CASCADE;
DROP TABLE DT09 IF EXISTS CASCADE;
DROP TABLE DT10 IF EXISTS CASCADE;
DROP TABLE DT11 IF EXISTS CASCADE;
DROP TABLE DT12 IF EXISTS CASCADE;
DROP TABLE DT13 IF EXISTS CASCADE;
DROP TABLE DT14 IF EXISTS CASCADE;
DROP TABLE DT15 IF EXISTS CASCADE;
DROP TABLE DT16 IF EXISTS CASCADE;
DROP TABLE DT17 IF EXISTS CASCADE;
DROP TABLE DT18 IF EXISTS CASCADE;
DROP TABLE DT19 IF EXISTS CASCADE;

-- These only exist for 'pro' tests, due to the restricted number of streams
-- (including in Migrating tables) allowed in the 'community' version;
-- nevertheless, we always drop them (if they exist)
DROP STREAM S100 IF EXISTS CASCADE;
DROP TABLE  R141 IF EXISTS CASCADE;
DROP TABLE  P141 IF EXISTS CASCADE;

END_OF_BATCH_2
file -inlinebatch END_OF_BATCH_3

-- TODO: once ENG-16526 is fixed, change column names INT1 back to INT
-- and TIME1 back to TIME

-- Tables, both replicated (Rx) and partitioned (Px), with various indexes,
-- DEFAULT values, and NOT NULL; first, with none at all (not even a PRIMARY KEY)
CREATE TABLE R0 (
  ID      INTEGER,
  TINY    TINYINT,
  SMALL   SMALLINT,
  INT1     INTEGER,
  BIG     BIGINT,
  NUM     FLOAT,
  DEC     DECIMAL,
  VCHAR_INLINE      VARCHAR(14),
  VCHAR_INLINE_MAX  VARCHAR(63 BYTES),
  VCHAR_OUTLINE_MIN VARCHAR(64 BYTES),
  VCHAR             VARCHAR,
  VCHAR_JSON        VARCHAR(1000),
  TIME1    TIMESTAMP,
  VARBIN  VARBINARY(100),
  POINT   GEOGRAPHY_POINT,
  POLYGON GEOGRAPHY,
  -- Used to test internet address functions:
  -- INET6_ATON, INET6_NTOA, INET_ATON, INET_NTOA
  IPV4    VARCHAR(15),
  IPV6    VARCHAR(60),
  VBIPV4  VARBINARY(4),
  VBIPV6  VARBINARY(16)
);

CREATE TABLE P0 (
  ID      INTEGER NOT NULL,
  TINY    TINYINT,
  SMALL   SMALLINT,
  INT1     INTEGER,
  BIG     BIGINT,
  NUM     FLOAT,
  DEC     DECIMAL,
  VCHAR_INLINE      VARCHAR(14),
  VCHAR_INLINE_MAX  VARCHAR(63 BYTES),
  VCHAR_OUTLINE_MIN VARCHAR(64 BYTES),
  VCHAR             VARCHAR,
  VCHAR_JSON        VARCHAR(1000),
  TIME1    TIMESTAMP,
  VARBIN  VARBINARY(100),
  POINT   GEOGRAPHY_POINT,
  POLYGON GEOGRAPHY,
  -- Used to test internet address functions:
  -- INET6_ATON, INET6_NTOA, INET_ATON, INET_NTOA
  IPV4    VARCHAR(15),
  IPV6    VARCHAR(60),
  VBIPV4  VARBINARY(4),
  VBIPV6  VARBINARY(16)
);
PARTITION TABLE P0 ON COLUMN ID;

-- Tables with one (NOT NULL) PRIMARY KEY column, but no other indexes
CREATE TABLE R1 (
  ID      INTEGER NOT NULL PRIMARY KEY,
  TINY    TINYINT,
  SMALL   SMALLINT,
  INT1     INTEGER,
  BIG     BIGINT,
  NUM     FLOAT,
  DEC     DECIMAL,
  VCHAR_INLINE      VARCHAR(42 BYTES),
  VCHAR_INLINE_MAX  VARCHAR(15),
  VCHAR_OUTLINE_MIN VARCHAR(16),
  VCHAR             VARCHAR,
  VCHAR_JSON        VARCHAR(4000 BYTES),
  TIME1    TIMESTAMP,
  VARBIN  VARBINARY(100),
  POINT   GEOGRAPHY_POINT,
  POLYGON GEOGRAPHY,
  -- Used to test internet address functions:
  -- INET6_ATON, INET6_NTOA, INET_ATON, INET_NTOA
  IPV4    VARCHAR(15),
  IPV6    VARCHAR(60),
  VBIPV4  VARBINARY(4),
  VBIPV6  VARBINARY(16)
);

CREATE TABLE P1 (
  ID      INTEGER NOT NULL PRIMARY KEY,
  TINY    TINYINT,
  SMALL   SMALLINT,
  INT1     INTEGER,
  BIG     BIGINT,
  NUM     FLOAT,
  DEC     DECIMAL,
  VCHAR_INLINE      VARCHAR(42 BYTES),
  VCHAR_INLINE_MAX  VARCHAR(15),
  VCHAR_OUTLINE_MIN VARCHAR(16),
  VCHAR             VARCHAR,
  VCHAR_JSON        VARCHAR(4000 BYTES),
  TIME1    TIMESTAMP,
  VARBIN  VARBINARY(100),
  POINT   GEOGRAPHY_POINT,
  POLYGON GEOGRAPHY,
  -- Used to test internet address functions:
  -- INET6_ATON, INET6_NTOA, INET_ATON, INET_NTOA
  IPV4    VARCHAR(15),
  IPV6    VARCHAR(60),
  VBIPV4  VARBINARY(4),
  VBIPV6  VARBINARY(16)
);
PARTITION TABLE P1 ON COLUMN ID;

-- Tables with various indexes, each on a single column
CREATE TABLE R2 (
  ID      INTEGER NOT NULL,
  TINY    TINYINT,
  SMALL   SMALLINT,
  INT1     INTEGER,
  BIG     BIGINT,
  NUM     FLOAT,
  DEC     DECIMAL,
  VCHAR_INLINE      VARCHAR(14),
  VCHAR_INLINE_MAX  VARCHAR(63 BYTES),
  VCHAR_OUTLINE_MIN VARCHAR(64 BYTES),
  VCHAR             VARCHAR,
  VCHAR_JSON        VARCHAR(1000),
  TIME1    TIMESTAMP,
  VARBIN  VARBINARY(100),
  POINT   GEOGRAPHY_POINT,
  POLYGON GEOGRAPHY,
  -- Used to test internet address functions:
  -- INET6_ATON, INET6_NTOA, INET_ATON, INET_NTOA
  IPV4    VARCHAR(15),
  IPV6    VARCHAR(60),
  VBIPV4  VARBINARY(4),
  VBIPV6  VARBINARY(16),
  PRIMARY KEY (ID)
);
CREATE INDEX IDX_R2_TINY ON R2 (TINY);
CREATE INDEX IDX_R2_BIG  ON R2 (BIG);
CREATE INDEX IDX_R2_DEC  ON R2 (DEC);
CREATE INDEX IDX_R2_VIM  ON R2 (VCHAR_INLINE_MAX);
CREATE INDEX IDX_R2_TIME ON R2 (TIME1);
CREATE INDEX IDX_R2_VBIN ON R2 (VARBIN);
CREATE INDEX IDX_R2_POLY ON R2 (POLYGON);

CREATE TABLE P2 (
  ID      INTEGER NOT NULL,
  TINY    TINYINT,
  SMALL   SMALLINT,
  INT1     INTEGER,
  BIG     BIGINT,
  NUM     FLOAT,
  DEC     DECIMAL,
  VCHAR_INLINE      VARCHAR(14),
  VCHAR_INLINE_MAX  VARCHAR(63 BYTES),
  VCHAR_OUTLINE_MIN VARCHAR(64 BYTES),
  VCHAR             VARCHAR,
  VCHAR_JSON        VARCHAR(1000),
  TIME1    TIMESTAMP,
  VARBIN  VARBINARY(100),
  POINT   GEOGRAPHY_POINT,
  POLYGON GEOGRAPHY,
  -- Used to test internet address functions:
  -- INET6_ATON, INET6_NTOA, INET_ATON, INET_NTOA
  IPV4    VARCHAR(15),
  IPV6    VARCHAR(60),
  VBIPV4  VARBINARY(4),
  VBIPV6  VARBINARY(16),
  PRIMARY KEY (ID)
);
PARTITION TABLE P2 ON COLUMN ID;
CREATE INDEX IDX_P2_TINY ON P2 (TINY);
CREATE INDEX IDX_P2_BIG  ON P2 (BIG);
CREATE INDEX IDX_P2_DEC  ON P2 (DEC);
CREATE INDEX IDX_P2_VIM  ON P2 (VCHAR_INLINE_MAX);
CREATE INDEX IDX_P2_TIME ON P2 (TIME1);
CREATE INDEX IDX_P2_VBIN ON P2 (VARBIN);
CREATE INDEX IDX_P2_POLY ON P2 (POLYGON);

-- Tables with UNIQUE (or ASSUMEUNIQUE) constraints
CREATE TABLE R3 (
  ID      INTEGER NOT NULL,
  TINY    TINYINT,
  SMALL   SMALLINT,
  INT1     INTEGER,
  BIG     BIGINT,
  NUM     FLOAT,
  DEC     DECIMAL,
  VCHAR_INLINE      VARCHAR(42 BYTES),
  VCHAR_INLINE_MAX  VARCHAR(15),
  VCHAR_OUTLINE_MIN VARCHAR(16),
  VCHAR             VARCHAR,
  VCHAR_JSON        VARCHAR(4000 BYTES),
  TIME1    TIMESTAMP,
  VARBIN  VARBINARY(100),
  POINT   GEOGRAPHY_POINT,
  POLYGON GEOGRAPHY,
  -- Used to test internet address functions:
  -- INET6_ATON, INET6_NTOA, INET_ATON, INET_NTOA
  IPV4    VARCHAR(15),
  IPV6    VARCHAR(60),
  VBIPV4  VARBINARY(4),
  VBIPV6  VARBINARY(16),
  PRIMARY KEY (VCHAR)
  -- Will not work with SqlCoverage/PostgreSQL (2 lines):
  , CONSTRAINT IDX_R3_TV  UNIQUE (TINY, VCHAR)
  , CONSTRAINT IDX_R3_VSI UNIQUE (VCHAR_INLINE, INT1, NUM)
);

CREATE TABLE P3 (
  ID      INTEGER,
  TINY    TINYINT,
  SMALL   SMALLINT,
  INT1     INTEGER,
  BIG     BIGINT,
  NUM     FLOAT,
  DEC     DECIMAL,
  VCHAR_INLINE      VARCHAR(42 BYTES),
  VCHAR_INLINE_MAX  VARCHAR(15),
  VCHAR_OUTLINE_MIN VARCHAR(16),
  VCHAR             VARCHAR NOT NULL,
  VCHAR_JSON        VARCHAR(4000 BYTES),
  TIME1    TIMESTAMP,
  VARBIN  VARBINARY(100),
  POINT   GEOGRAPHY_POINT,
  POLYGON GEOGRAPHY,
  -- Used to test internet address functions:
  -- INET6_ATON, INET6_NTOA, INET_ATON, INET_NTOA
  IPV4    VARCHAR(15),
  IPV6    VARCHAR(60),
  VBIPV4  VARBINARY(4),
  VBIPV6  VARBINARY(16),
  PRIMARY KEY (VCHAR)
  -- Will not work with SqlCoverage/PostgreSQL (2 lines):
  , CONSTRAINT IDX_P3_TV        UNIQUE (TINY, VCHAR)
  , CONSTRAINT IDX_P3_VSI ASSUMEUNIQUE (VCHAR_INLINE, INT1, NUM)
);
PARTITION TABLE P3 ON COLUMN VCHAR;

-- Tables with column DEFAULT values; and UNIQUE (or ASSUMEUNIQUE) constraints
CREATE TABLE R4 (
  ID      INTEGER  DEFAULT 0,
  TINY    TINYINT  DEFAULT 0,
  SMALL   SMALLINT DEFAULT 0,
  INT1     INTEGER  DEFAULT 0,
  BIG     BIGINT   DEFAULT 0,
  NUM     FLOAT    DEFAULT 0,
  DEC     DECIMAL  DEFAULT 0,
  VCHAR_INLINE      VARCHAR(14)       DEFAULT '0',
  VCHAR_INLINE_MAX  VARCHAR(63 BYTES) DEFAULT '0',
  VCHAR_OUTLINE_MIN VARCHAR(64 BYTES) DEFAULT '0' NOT NULL,
  VCHAR             VARCHAR           DEFAULT '0',
  VCHAR_JSON        VARCHAR(1000)     DEFAULT '0',
  TIME1    TIMESTAMP       DEFAULT '2013-10-30 23:22:29',
  VARBIN  VARBINARY(100)  DEFAULT x'00',
  -- Default values of GEOGRAPHY_POINT and GEOGRAPHY not supported (ENG-12029)
  POINT   GEOGRAPHY_POINT,
  POLYGON GEOGRAPHY,
  -- Used to test internet address functions:
  -- INET6_ATON, INET6_NTOA, INET_ATON, INET_NTOA
  IPV4    VARCHAR(15),
  IPV6    VARCHAR(60),
  VBIPV4  VARBINARY(4),
  VBIPV6  VARBINARY(16),
  PRIMARY KEY (ID, VCHAR_OUTLINE_MIN)
);
-- Will not work with SqlCoverage/PostgreSQL (2 lines):
CREATE UNIQUE INDEX IDX_R4_TV  ON R4 (TINY, VCHAR);
CREATE UNIQUE INDEX IDX_R4_VSI ON R4 (VCHAR, SMALL, INT1);

CREATE TABLE P4 (
  ID      INTEGER  DEFAULT 0,
  TINY    TINYINT  DEFAULT 0,
  SMALL   SMALLINT DEFAULT 0,
  INT1     INTEGER  DEFAULT 0,
  BIG     BIGINT   DEFAULT 0,
  NUM     FLOAT    DEFAULT 0,
  DEC     DECIMAL  DEFAULT 0,
  VCHAR_INLINE      VARCHAR(14)       DEFAULT '0',
  VCHAR_INLINE_MAX  VARCHAR(63 BYTES) DEFAULT '0',
  VCHAR_OUTLINE_MIN VARCHAR(64 BYTES) DEFAULT '0' NOT NULL,
  VCHAR             VARCHAR           DEFAULT '0',
  VCHAR_JSON        VARCHAR(1000)     DEFAULT '0',
  TIME1    TIMESTAMP       DEFAULT '2013-10-30 23:22:29',
  VARBIN  VARBINARY(100)  DEFAULT x'00',
  -- Default values of GEOGRAPHY_POINT and GEOGRAPHY not supported (ENG-12029)
  POINT   GEOGRAPHY_POINT,
  POLYGON GEOGRAPHY,
  -- Used to test internet address functions:
  -- INET6_ATON, INET6_NTOA, INET_ATON, INET_NTOA
  IPV4    VARCHAR(15),
  IPV6    VARCHAR(60),
  VBIPV4  VARBINARY(4),
  VBIPV6  VARBINARY(16),
  PRIMARY KEY (ID, VCHAR_OUTLINE_MIN)
);
PARTITION TABLE P4 ON COLUMN VCHAR_OUTLINE_MIN;
-- Will not work with SqlCoverage/PostgreSQL (2 lines):
CREATE       UNIQUE INDEX IDX_P4_TV  ON P4 (TINY, VCHAR_OUTLINE_MIN);
CREATE ASSUMEUNIQUE INDEX IDX_P4_VSI ON P4 (VCHAR_INLINE_MAX, SMALL, INT1);

-- Tables with ...
---NOT NULL columns; and UNIQUE (or ASSUMEUNIQUE) constraints
CREATE TABLE R5 (
  ID      INTEGER  NOT NULL,
  TINY    TINYINT  NOT NULL,
  SMALL   SMALLINT NOT NULL,
  INT1     INTEGER  NOT NULL,
  BIG     BIGINT   NOT NULL,
  NUM     FLOAT    NOT NULL,
  DEC     DECIMAL  NOT NULL,
  VCHAR_INLINE      VARCHAR(42 BYTES)   NOT NULL,
  VCHAR_INLINE_MAX  VARCHAR(15)         NOT NULL,
  VCHAR_OUTLINE_MIN VARCHAR(16)         NOT NULL,
  VCHAR             VARCHAR             NOT NULL,
  VCHAR_JSON        VARCHAR(4000 BYTES) NOT NULL,
  TIME1    TIMESTAMP       NOT NULL,
  VARBIN  VARBINARY(100)  NOT NULL,
  POINT   GEOGRAPHY_POINT NOT NULL,
  POLYGON GEOGRAPHY,
  -- Used to test internet address functions:
  -- INET6_ATON, INET6_NTOA, INET_ATON, INET_NTOA
  IPV4    VARCHAR(15),
  IPV6    VARCHAR(60),
  VBIPV4  VARBINARY(4),
  VBIPV6  VARBINARY(16)       NOT NULL,
  PRIMARY KEY (VCHAR, ID)
);
CREATE       UNIQUE INDEX IDX_R5_IV  ON R5 (ID, VCHAR)                WHERE ID >= 0;
CREATE ASSUMEUNIQUE INDEX IDX_R5_VSI ON R5 (VCHAR_INLINE, SMALL, INT1) WHERE VCHAR_INLINE_MAX < 'a';
CREATE              INDEX IDX_R5_IVI ON R5 (INT1, VCHAR_INLINE_MAX)    WHERE INT1 >= 0 AND VCHAR_INLINE IS NOT NULL;

-- Tables with column DEFAULT values; and UNIQUE (or ASSUMEUNIQUE) constraints
CREATE TABLE P5 (
  ID      INTEGER  NOT NULL,
  TINY    TINYINT  NOT NULL,
  SMALL   SMALLINT NOT NULL,
  INT1     INTEGER  NOT NULL,
  BIG     BIGINT   NOT NULL,
  NUM     FLOAT    NOT NULL,
  DEC     DECIMAL  NOT NULL,
  VCHAR_INLINE      VARCHAR(42 BYTES)   NOT NULL,
  VCHAR_INLINE_MAX  VARCHAR(15)         NOT NULL,
  VCHAR_OUTLINE_MIN VARCHAR(16)         NOT NULL,
  VCHAR             VARCHAR             NOT NULL,
  VCHAR_JSON        VARCHAR(4000 BYTES) NOT NULL,
  TIME1    TIMESTAMP       NOT NULL,
  VARBIN  VARBINARY(100)  NOT NULL,
  POINT   GEOGRAPHY_POINT NOT NULL,
  POLYGON GEOGRAPHY,
  -- Used to test internet address functions:
  -- INET6_ATON, INET6_NTOA, INET_ATON, INET_NTOA
  IPV4    VARCHAR(15),
  IPV6    VARCHAR(60),
  VBIPV4  VARBINARY(4),
  VBIPV6  VARBINARY(16)       NOT NULL,
  PRIMARY KEY (VCHAR, ID)
);
PARTITION TABLE P5 ON COLUMN ID;
CREATE       UNIQUE INDEX IDX_P5_IV  ON P5 (ID, VCHAR)                WHERE ID >= 0;
CREATE ASSUMEUNIQUE INDEX IDX_P5_VSI ON P5 (VCHAR_INLINE, SMALL, INT1) WHERE VCHAR_INLINE_MAX < 'a';
CREATE              INDEX IDX_P5_IVI ON P5 (INT1, VCHAR_INLINE_MAX)    WHERE INT1 >= 0 AND VCHAR_INLINE IS NOT NULL;

-- Tables with DEFAULT value NOT NULL columns; and UNIQUE (or ASSUMEUNIQUE) constraints
CREATE TABLE R6 (
  ID      INTEGER  DEFAULT 0 NOT NULL,
  TINY    TINYINT  DEFAULT 0 NOT NULL,
  SMALL   SMALLINT DEFAULT 0 NOT NULL,
  INT1     INTEGER  DEFAULT 0 NOT NULL,
  BIG     BIGINT   DEFAULT 0 NOT NULL,
  NUM     FLOAT    DEFAULT 0 NOT NULL,
  DEC     DECIMAL  DEFAULT 0 NOT NULL,
  VCHAR_INLINE      VARCHAR(14)       DEFAULT '0' NOT NULL,
  VCHAR_INLINE_MAX  VARCHAR(63 BYTES) DEFAULT '0' NOT NULL,
  VCHAR_OUTLINE_MIN VARCHAR(64 BYTES) DEFAULT '0' NOT NULL,
  VCHAR             VARCHAR           DEFAULT '0' NOT NULL,
  VCHAR_JSON        VARCHAR(1000)     DEFAULT '0' NOT NULL,
  TIME1    TIMESTAMP       DEFAULT '2013-10-30 23:22:29' NOT NULL,
  VARBIN  VARBINARY(100)  DEFAULT x'00' NOT NULL,
  -- Default values of GEOGRAPHY_POINT and GEOGRAPHY not supported (ENG-12029)
  POINT   GEOGRAPHY_POINT,
  POLYGON GEOGRAPHY,
  -- Used to test internet address functions:
  -- INET6_ATON, INET6_NTOA, INET_ATON, INET_NTOA
  IPV4    VARCHAR(15),
  IPV6    VARCHAR(60),
  VBIPV4  VARBINARY(4),
  VBIPV6  VARBINARY(16),
  PRIMARY KEY (VARBIN)
);

CREATE TABLE P6 (
  ID      INTEGER  DEFAULT 0 NOT NULL,
  TINY    TINYINT  DEFAULT 0 NOT NULL,
  SMALL   SMALLINT DEFAULT 0 NOT NULL,
  INT1     INTEGER  DEFAULT 0 NOT NULL,
  BIG     BIGINT   DEFAULT 0 NOT NULL,
  NUM     FLOAT    DEFAULT 0 NOT NULL,
  DEC     DECIMAL  DEFAULT 0 NOT NULL,
  VCHAR_INLINE      VARCHAR(14)       DEFAULT '0' NOT NULL,
  VCHAR_INLINE_MAX  VARCHAR(63 BYTES) DEFAULT '0' NOT NULL,
  VCHAR_OUTLINE_MIN VARCHAR(64 BYTES) DEFAULT '0' NOT NULL,
  VCHAR             VARCHAR           DEFAULT '0' NOT NULL,
  VCHAR_JSON        VARCHAR(1000)     DEFAULT '0' NOT NULL,
  TIME1    TIMESTAMP       DEFAULT '2013-10-30 23:22:29' NOT NULL,
  VARBIN  VARBINARY(100)  DEFAULT x'00' NOT NULL,
  -- Default values of GEOGRAPHY_POINT and GEOGRAPHY not supported (ENG-12028)
  POINT   GEOGRAPHY_POINT,
  POLYGON GEOGRAPHY,
  -- Used to test internet address functions:
  -- INET6_ATON, INET6_NTOA, INET_ATON, INET_NTOA
  IPV4    VARCHAR(15),
  IPV6    VARCHAR(60),
  VBIPV4  VARBINARY(4),
  VBIPV6  VARBINARY(16),
  PRIMARY KEY (VARBIN)
);
PARTITION TABLE P6 ON COLUMN VARBIN;

CREATE TABLE R7 (
  ID      INTEGER  UNIQUE,
  TINY    TINYINT  UNIQUE,
  SMALL   SMALLINT UNIQUE,
  INT1     INTEGER  UNIQUE,
  BIG     BIGINT   UNIQUE,
  NUM     FLOAT    UNIQUE,
  DEC     DECIMAL  UNIQUE,
  VCHAR_INLINE      VARCHAR(42 BYTES)   UNIQUE,
  VCHAR_INLINE_MAX  VARCHAR(15)         UNIQUE,
  VCHAR_OUTLINE_MIN VARCHAR(16)         UNIQUE,
  VCHAR             VARCHAR             UNIQUE,
  VCHAR_JSON        VARCHAR(4000 BYTES) UNIQUE,
  TIME1    TIMESTAMP       UNIQUE,
  VARBIN  VARBINARY(100)  UNIQUE,
  POINT   GEOGRAPHY_POINT,
  POLYGON GEOGRAPHY,
  -- Used to test internet address functions:
  -- INET6_ATON, INET6_NTOA, INET_ATON, INET_NTOA
  IPV4    VARCHAR(15),
  IPV6    VARCHAR(60),
  VBIPV4  VARBINARY(4),
  VBIPV6  VARBINARY(16),
  PRIMARY KEY (ID, VCHAR, VARBIN)
);

CREATE TABLE P7 (
  ID      INTEGER  ASSUMEUNIQUE,
  TINY    TINYINT  ASSUMEUNIQUE,
  SMALL   SMALLINT ASSUMEUNIQUE,
  INT1     INTEGER  ASSUMEUNIQUE,
  BIG     BIGINT   ASSUMEUNIQUE,
  NUM     FLOAT    ASSUMEUNIQUE,
  DEC     DECIMAL  ASSUMEUNIQUE,
  VCHAR_INLINE      VARCHAR(42 BYTES)   ASSUMEUNIQUE,
  VCHAR_INLINE_MAX  VARCHAR(15)         ASSUMEUNIQUE,
  VCHAR_OUTLINE_MIN VARCHAR(16)         ASSUMEUNIQUE,
  VCHAR             VARCHAR             ASSUMEUNIQUE,
  VCHAR_JSON        VARCHAR(4000 BYTES) ASSUMEUNIQUE,
  TIME1    TIMESTAMP       ASSUMEUNIQUE,
  VARBIN  VARBINARY(100)  NOT NULL UNIQUE,
  POINT   GEOGRAPHY_POINT,
  POLYGON GEOGRAPHY,
  -- Used to test internet address functions:
  -- INET6_ATON, INET6_NTOA, INET_ATON, INET_NTOA
  IPV4    VARCHAR(15),
  IPV6    VARCHAR(60),
  VBIPV4  VARBINARY(4),
  VBIPV6  VARBINARY(16),
  PRIMARY KEY (ID, VCHAR, VARBIN)
);
PARTITION TABLE P7 ON COLUMN VARBIN;


-- The following pairs of tables are identical (and do not have views),
-- so that they can be used to test @SwapTables; e.g., R11 & R12 are
-- identical (also to R1 above, except that has a view defined on it);
-- P11 & P12 are identical (& P1, except its view), etc.

CREATE TABLE R11 (
  ID      INTEGER NOT NULL PRIMARY KEY,
  TINY    TINYINT,
  SMALL   SMALLINT,
  INT1     INTEGER,
  BIG     BIGINT,
  NUM     FLOAT,
  DEC     DECIMAL,
  VCHAR_INLINE      VARCHAR(42 BYTES),
  VCHAR_INLINE_MAX  VARCHAR(15),
  VCHAR_OUTLINE_MIN VARCHAR(16),
  VCHAR             VARCHAR,
  VCHAR_JSON        VARCHAR(4000 BYTES),
  TIME1    TIMESTAMP,
  VARBIN  VARBINARY(100),
  POINT   GEOGRAPHY_POINT,
  POLYGON GEOGRAPHY,
  -- Used to test internet address functions:
  -- INET6_ATON, INET6_NTOA, INET_ATON, INET_NTOA
  IPV4    VARCHAR(15),
  IPV6    VARCHAR(60),
  VBIPV4  VARBINARY(4),
  VBIPV6  VARBINARY(16)
);

CREATE TABLE R12 (
  ID      INTEGER NOT NULL PRIMARY KEY,
  TINY    TINYINT,
  SMALL   SMALLINT,
  INT1     INTEGER,
  BIG     BIGINT,
  NUM     FLOAT,
  DEC     DECIMAL,
  VCHAR_INLINE      VARCHAR(42 BYTES),
  VCHAR_INLINE_MAX  VARCHAR(15),
  VCHAR_OUTLINE_MIN VARCHAR(16),
  VCHAR             VARCHAR,
  VCHAR_JSON        VARCHAR(4000 BYTES),
  TIME1    TIMESTAMP,
  VARBIN  VARBINARY(100),
  POINT   GEOGRAPHY_POINT,
  POLYGON GEOGRAPHY,
  -- Used to test internet address functions:
  -- INET6_ATON, INET6_NTOA, INET_ATON, INET_NTOA
  IPV4    VARCHAR(15),
  IPV6    VARCHAR(60),
  VBIPV4  VARBINARY(4),
  VBIPV6  VARBINARY(16)
);

CREATE TABLE P11 (
  ID      INTEGER NOT NULL PRIMARY KEY,
  TINY    TINYINT,
  SMALL   SMALLINT,
  INT1     INTEGER,
  BIG     BIGINT,
  NUM     FLOAT,
  DEC     DECIMAL,
  VCHAR_INLINE      VARCHAR(42 BYTES),
  VCHAR_INLINE_MAX  VARCHAR(15),
  VCHAR_OUTLINE_MIN VARCHAR(16),
  VCHAR             VARCHAR,
  VCHAR_JSON        VARCHAR(4000 BYTES),
  TIME1    TIMESTAMP,
  VARBIN  VARBINARY(100),
  POINT   GEOGRAPHY_POINT,
  POLYGON GEOGRAPHY,
  -- Used to test internet address functions:
  -- INET6_ATON, INET6_NTOA, INET_ATON, INET_NTOA
  IPV4    VARCHAR(15),
  IPV6    VARCHAR(60),
  VBIPV4  VARBINARY(4),
  VBIPV6  VARBINARY(16)
);
PARTITION TABLE P11 ON COLUMN ID;

CREATE TABLE P12 (
  ID      INTEGER NOT NULL PRIMARY KEY,
  TINY    TINYINT,
  SMALL   SMALLINT,
  INT1     INTEGER,
  BIG     BIGINT,
  NUM     FLOAT,
  DEC     DECIMAL,
  VCHAR_INLINE      VARCHAR(42 BYTES),
  VCHAR_INLINE_MAX  VARCHAR(15),
  VCHAR_OUTLINE_MIN VARCHAR(16),
  VCHAR             VARCHAR,
  VCHAR_JSON        VARCHAR(4000 BYTES),
  TIME1    TIMESTAMP,
  VARBIN  VARBINARY(100),
  POINT   GEOGRAPHY_POINT,
  POLYGON GEOGRAPHY,
  -- Used to test internet address functions:
  -- INET6_ATON, INET6_NTOA, INET_ATON, INET_NTOA
  IPV4    VARCHAR(15),
  IPV6    VARCHAR(60),
  VBIPV4  VARBINARY(4),
  VBIPV6  VARBINARY(16)
);
PARTITION TABLE P12 ON COLUMN ID;

CREATE TABLE R13 (
  ID      INTEGER NOT NULL,
  TINY    TINYINT,
  SMALL   SMALLINT,
  INT1     INTEGER,
  BIG     BIGINT,
  NUM     FLOAT,
  DEC     DECIMAL,
  VCHAR_INLINE      VARCHAR(14),
  VCHAR_INLINE_MAX  VARCHAR(63 BYTES),
  VCHAR_OUTLINE_MIN VARCHAR(64 BYTES),
  VCHAR             VARCHAR,
  VCHAR_JSON        VARCHAR(1000),
  TIME1    TIMESTAMP,
  VARBIN  VARBINARY(100),
  POINT   GEOGRAPHY_POINT,
  POLYGON GEOGRAPHY,
  -- Used to test internet address functions:
  -- INET6_ATON, INET6_NTOA, INET_ATON, INET_NTOA
  IPV4    VARCHAR(15),
  IPV6    VARCHAR(60),
  VBIPV4  VARBINARY(4),
  VBIPV6  VARBINARY(16),
  PRIMARY KEY (ID)
);
CREATE INDEX IDX_R13_TINY ON R13 (TINY);
CREATE INDEX IDX_R13_BIG  ON R13 (BIG);
CREATE INDEX IDX_R13_DEC  ON R13 (DEC);
CREATE INDEX IDX_R13_VIM  ON R13 (VCHAR_INLINE_MAX);
CREATE INDEX IDX_R13_TIME ON R13 (TIME1);
CREATE INDEX IDX_R13_VBIN ON R13 (VARBIN);
CREATE INDEX IDX_R13_POLY ON R13 (POLYGON);

CREATE TABLE R14 (
  ID      INTEGER NOT NULL,
  TINY    TINYINT,
  SMALL   SMALLINT,
  INT1     INTEGER,
  BIG     BIGINT,
  NUM     FLOAT,
  DEC     DECIMAL,
  VCHAR_INLINE      VARCHAR(14),
  VCHAR_INLINE_MAX  VARCHAR(63 BYTES),
  VCHAR_OUTLINE_MIN VARCHAR(64 BYTES),
  VCHAR             VARCHAR,
  VCHAR_JSON        VARCHAR(1000),
  TIME1    TIMESTAMP,
  VARBIN  VARBINARY(100),
  POINT   GEOGRAPHY_POINT,
  POLYGON GEOGRAPHY,
  -- Used to test internet address functions:
  -- INET6_ATON, INET6_NTOA, INET_ATON, INET_NTOA
  IPV4    VARCHAR(15),
  IPV6    VARCHAR(60),
  VBIPV4  VARBINARY(4),
  VBIPV6  VARBINARY(16),
  PRIMARY KEY (ID)
);
CREATE INDEX IDX_R14_TINY ON R14 (TINY);
CREATE INDEX IDX_R14_BIG  ON R14 (BIG);
CREATE INDEX IDX_R14_DEC  ON R14 (DEC);
CREATE INDEX IDX_R14_VIM  ON R14 (VCHAR_INLINE_MAX);
CREATE INDEX IDX_R14_TIME ON R14 (TIME1);
CREATE INDEX IDX_R14_VBIN ON R14 (VARBIN);
CREATE INDEX IDX_R14_POLY ON R14 (POLYGON);

CREATE TABLE P13 (
  ID      INTEGER NOT NULL,
  TINY    TINYINT,
  SMALL   SMALLINT,
  INT1     INTEGER,
  BIG     BIGINT,
  NUM     FLOAT,
  DEC     DECIMAL,
  VCHAR_INLINE      VARCHAR(14),
  VCHAR_INLINE_MAX  VARCHAR(63 BYTES),
  VCHAR_OUTLINE_MIN VARCHAR(64 BYTES),
  VCHAR             VARCHAR,
  VCHAR_JSON        VARCHAR(1000),
  TIME1    TIMESTAMP,
  VARBIN  VARBINARY(100),
  POINT   GEOGRAPHY_POINT,
  POLYGON GEOGRAPHY,
  -- Used to test internet address functions:
  -- INET6_ATON, INET6_NTOA, INET_ATON, INET_NTOA
  IPV4    VARCHAR(15),
  IPV6    VARCHAR(60),
  VBIPV4  VARBINARY(4),
  VBIPV6  VARBINARY(16),
  PRIMARY KEY (ID)
);
PARTITION TABLE P13 ON COLUMN ID;
CREATE INDEX IDX_P13_TINY ON P13 (TINY);
CREATE INDEX IDX_P13_BIG  ON P13 (BIG);
CREATE INDEX IDX_P13_DEC  ON P13 (DEC);
CREATE INDEX IDX_P13_VIM  ON P13 (VCHAR_INLINE_MAX);
CREATE INDEX IDX_P13_TIME ON P13 (TIME1);
CREATE INDEX IDX_P13_VBIN ON P13 (VARBIN);
CREATE INDEX IDX_P13_POLY ON P13 (POLYGON);

CREATE TABLE P14 (
  ID      INTEGER NOT NULL,
  TINY    TINYINT,
  SMALL   SMALLINT,
  INT1     INTEGER,
  BIG     BIGINT,
  NUM     FLOAT,
  DEC     DECIMAL,
  VCHAR_INLINE      VARCHAR(14),
  VCHAR_INLINE_MAX  VARCHAR(63 BYTES),
  VCHAR_OUTLINE_MIN VARCHAR(64 BYTES),
  VCHAR             VARCHAR,
  VCHAR_JSON        VARCHAR(1000),
  TIME1    TIMESTAMP,
  VARBIN  VARBINARY(100),
  POINT   GEOGRAPHY_POINT,
  POLYGON GEOGRAPHY,
  -- Used to test internet address functions:
  -- INET6_ATON, INET6_NTOA, INET_ATON, INET_NTOA
  IPV4    VARCHAR(15),
  IPV6    VARCHAR(60),
  VBIPV4  VARBINARY(4),
  VBIPV6  VARBINARY(16),
  PRIMARY KEY (ID)
);
PARTITION TABLE P14 ON COLUMN ID;
CREATE INDEX IDX_P14_TINY ON P14 (TINY);
CREATE INDEX IDX_P14_BIG  ON P14 (BIG);
CREATE INDEX IDX_P14_DEC  ON P14 (DEC);
CREATE INDEX IDX_P14_VIM  ON P14 (VCHAR_INLINE_MAX);
CREATE INDEX IDX_P14_TIME ON P14 (TIME1);
CREATE INDEX IDX_P14_VBIN ON P14 (VARBIN);
CREATE INDEX IDX_P14_POLY ON P14 (POLYGON);

-- Tables with a TTL columnn (but no MIGRATE target)
CREATE TABLE R21 (
  ID      INTEGER NOT NULL PRIMARY KEY,
  TINY    TINYINT,
  SMALL   SMALLINT,
  INT1     INTEGER,
  BIG     BIGINT,
  NUM     FLOAT,
  DEC     DECIMAL,
  VCHAR_INLINE      VARCHAR(42 BYTES),
  VCHAR_INLINE_MAX  VARCHAR(15),
  VCHAR_OUTLINE_MIN VARCHAR(16),
  VCHAR             VARCHAR,
  VCHAR_JSON        VARCHAR(4000 BYTES),
  TIME1    TIMESTAMP DEFAULT NOW NOT NULL,
  VARBIN  VARBINARY(100),
  POINT   GEOGRAPHY_POINT,
  POLYGON GEOGRAPHY,
  -- Used to test internet address functions:
  -- INET6_ATON, INET6_NTOA, INET_ATON, INET_NTOA
  IPV4    VARCHAR(15),
  IPV6    VARCHAR(60),
  VBIPV4  VARBINARY(4),
  VBIPV6  VARBINARY(16)
) USING TTL 60 ON COLUMN TIME1;
--[BATCH_SIZE number-of-rows] [MAX_FREQUENCY value]

CREATE TABLE P21 (
  ID      INTEGER NOT NULL PRIMARY KEY,
  TINY    TINYINT,
  SMALL   SMALLINT,
  INT1     INTEGER,
  BIG     BIGINT,
  NUM     FLOAT,
  DEC     DECIMAL,
  VCHAR_INLINE      VARCHAR(42 BYTES),
  VCHAR_INLINE_MAX  VARCHAR(15),
  VCHAR_OUTLINE_MIN VARCHAR(16),
  VCHAR             VARCHAR,
  VCHAR_JSON        VARCHAR(4000 BYTES),
  TIME1    TIMESTAMP DEFAULT NOW NOT NULL,
  VARBIN  VARBINARY(100),
  POINT   GEOGRAPHY_POINT,
  POLYGON GEOGRAPHY,
  -- Used to test internet address functions:
  -- INET6_ATON, INET6_NTOA, INET_ATON, INET_NTOA
  IPV4    VARCHAR(15),
  IPV6    VARCHAR(60),
  VBIPV4  VARBINARY(4),
  VBIPV6  VARBINARY(16)
) USING TTL 60 ON COLUMN TIME1;
PARTITION TABLE P21 ON COLUMN ID;

-- Tables with a MIGRATE target (but no TTL columnn)
CREATE TABLE R31 MIGRATE TO TARGET grammartarget (
  ID      INTEGER NOT NULL PRIMARY KEY,
  TINY    TINYINT,
  SMALL   SMALLINT,
  INT1     INTEGER,
  BIG     BIGINT,
  NUM     FLOAT,
  DEC     DECIMAL,
  VCHAR_INLINE      VARCHAR(42 BYTES),
  VCHAR_INLINE_MAX  VARCHAR(15),
  VCHAR_OUTLINE_MIN VARCHAR(16),
  VCHAR             VARCHAR,
  VCHAR_JSON        VARCHAR(4000 BYTES),
  TIME1    TIMESTAMP,
  VARBIN  VARBINARY(100),
  POINT   GEOGRAPHY_POINT,
  POLYGON GEOGRAPHY,
  -- Used to test internet address functions:
  -- INET6_ATON, INET6_NTOA, INET_ATON, INET_NTOA
  IPV4    VARCHAR(15),
  IPV6    VARCHAR(60),
  VBIPV4  VARBINARY(4),
  VBIPV6  VARBINARY(16)
);

CREATE TABLE P31 MIGRATE TO TARGET grammartarget (
  ID      INTEGER NOT NULL PRIMARY KEY,
  TINY    TINYINT,
  SMALL   SMALLINT,
  INT1     INTEGER,
  BIG     BIGINT,
  NUM     FLOAT,
  DEC     DECIMAL,
  VCHAR_INLINE      VARCHAR(42 BYTES),
  VCHAR_INLINE_MAX  VARCHAR(15),
  VCHAR_OUTLINE_MIN VARCHAR(16),
  VCHAR             VARCHAR,
  VCHAR_JSON        VARCHAR(4000 BYTES),
  TIME1    TIMESTAMP,
  VARBIN  VARBINARY(100),
  POINT   GEOGRAPHY_POINT,
  POLYGON GEOGRAPHY,
  -- Used to test internet address functions:
  -- INET6_ATON, INET6_NTOA, INET_ATON, INET_NTOA
  IPV4    VARCHAR(15),
  IPV6    VARCHAR(60),
  VBIPV4  VARBINARY(4),
  VBIPV6  VARBINARY(16)
);
PARTITION TABLE P31 ON COLUMN ID;

END_OF_BATCH_3
file -inlinebatch END_OF_BATCH_4

-- The following are views defined on most of the above tables
-- (but not the ones used for testing @SwapTables)

CREATE VIEW VR1 (TINY,
    ID, SMALL, INT1, BIG, NUM, DEC,
    VCHAR_INLINE, VCHAR_INLINE_MAX, VCHAR_OUTLINE_MIN, VCHAR, VCHAR_JSON, TIME1
    -- Will not work with SqlCoverage/PostgreSQL:
    , VARBIN, POINT, POLYGON
    , IPV4, IPV6, VBIPV4, VBIPV6
    ) AS
  SELECT TINY,
    COUNT(*), SUM(SMALL), COUNT(INT1), MIN(BIG), MAX(NUM), SUM(DEC),
    MIN(VCHAR_INLINE), MIN(VCHAR_INLINE_MAX), MIN(VCHAR_OUTLINE_MIN), MIN(VCHAR), MIN(VCHAR_JSON), MIN(TIME1)
    -- Will not work with SqlCoverage/PostgreSQL:
    , MIN(VARBIN), MIN(POINT), MIN(POLYGON)
    , MIN(IPV4), MIN(IPV6), MIN(VBIPV4), MIN(VBIPV6)
  FROM R1
GROUP BY TINY;

CREATE VIEW VP1 (TINY,
    ID, SMALL, INT1, BIG, NUM, DEC,
    VCHAR_INLINE, VCHAR_INLINE_MAX, VCHAR_OUTLINE_MIN, VCHAR, VCHAR_JSON, TIME1
    -- Will not work with SqlCoverage/PostgreSQL:
    , VARBIN, POINT, POLYGON
    , IPV4, IPV6, VBIPV4, VBIPV6
    ) AS
  SELECT TINY,
    COUNT(*), SUM(SMALL), COUNT(INT1), MIN(BIG), MAX(NUM), SUM(DEC),
    MIN(VCHAR_INLINE), MIN(VCHAR_INLINE_MAX), MIN(VCHAR_OUTLINE_MIN), MIN(VCHAR), MIN(VCHAR_JSON), MIN(TIME1)
    -- Will not work with SqlCoverage/PostgreSQL:
    , MIN(VARBIN), MIN(POINT), MIN(POLYGON)
    , MIN(IPV4), MIN(IPV6), MIN(VBIPV4), MIN(VBIPV6)
  FROM P1
GROUP BY TINY;


CREATE VIEW VR2 (TINY,
    ID, SMALL, INT1, BIG, NUM, DEC,
    VCHAR_INLINE, VCHAR_INLINE_MAX, VCHAR_OUTLINE_MIN, VCHAR, VCHAR_JSON, TIME1
    -- Will not work with SqlCoverage/PostgreSQL:
    , VARBIN, POINT, POLYGON
    , IPV4, IPV6, VBIPV4, VBIPV6
    ) AS
  SELECT TINY,
    COUNT(*), COUNT(SMALL), MIN(INT1), MAX(BIG), SUM(NUM), MIN(DEC),
    MAX(VCHAR_INLINE), MAX(VCHAR_INLINE_MAX), MAX(VCHAR_OUTLINE_MIN), MAX(VCHAR), MAX(VCHAR_JSON), MAX(TIME1)
    -- Will not work with SqlCoverage/PostgreSQL:
    , MAX(VARBIN), MAX(POINT), MAX(POLYGON)
    , MAX(IPV4), MAX(IPV6), MAX(VBIPV4), MAX(VBIPV6)
  FROM R2 WHERE ABS(TINY) < 64
GROUP BY TINY;

CREATE VIEW VP2 (TINY,
    ID, SMALL, INT1, BIG, NUM, DEC,
    VCHAR_INLINE, VCHAR_INLINE_MAX, VCHAR_OUTLINE_MIN, VCHAR, VCHAR_JSON, TIME1
    -- Will not work with SqlCoverage/PostgreSQL:
    , VARBIN, POINT, POLYGON
    , IPV4, IPV6, VBIPV4, VBIPV6
    ) AS
  SELECT TINY,
    COUNT(*), COUNT(SMALL), MIN(INT1), MAX(BIG), SUM(NUM), MIN(DEC),
    MAX(VCHAR_INLINE), MAX(VCHAR_INLINE_MAX), MAX(VCHAR_OUTLINE_MIN), MAX(VCHAR), MAX(VCHAR_JSON), MAX(TIME1)
    -- Will not work with SqlCoverage/PostgreSQL:
    , MAX(VARBIN), MAX(POINT), MAX(POLYGON)
    , MAX(IPV4), MAX(IPV6), MAX(VBIPV4), MAX(VBIPV6)
  FROM P2 WHERE ABS(TINY) < 64
GROUP BY TINY;


CREATE VIEW VR3 (VCHAR_INLINE_MAX,
    ID, TINY, SMALL, INT1, BIG, NUM, DEC,
    VCHAR_INLINE, VCHAR_OUTLINE_MIN, VCHAR, VCHAR_JSON, TIME1
    -- Will not work with SqlCoverage/PostgreSQL:
    , VARBIN, POINT, POLYGON
    , IPV4, IPV6, VBIPV4, VBIPV6
    ) AS
  SELECT VCHAR_INLINE_MAX,
    COUNT(*), COUNT(TINY), MIN(SMALL), MAX(INT1), SUM(BIG), MIN(NUM), MAX(DEC),
    MIN(VCHAR_INLINE), MAX(VCHAR_OUTLINE_MIN), MIN(VCHAR), MAX(VCHAR_JSON), MIN(TIME1)
    -- Will not work with SqlCoverage/PostgreSQL:
    , MAX(VARBIN), MIN(POINT), MAX(POLYGON)
    , MIN(IPV4), MAX(IPV6), MIN(VBIPV4), MAX(VBIPV6)
  FROM R3
GROUP BY VCHAR_INLINE_MAX;

CREATE VIEW VP3 (VCHAR_INLINE_MAX,
    ID, TINY, SMALL, INT1, BIG, NUM, DEC,
    VCHAR_INLINE, VCHAR_OUTLINE_MIN, VCHAR, VCHAR_JSON, TIME1
    -- Will not work with SqlCoverage/PostgreSQL:
    , VARBIN, POINT, POLYGON
    , IPV4, IPV6, VBIPV4, VBIPV6
    ) AS
  SELECT VCHAR_INLINE_MAX,
    COUNT(*), COUNT(TINY), MIN(SMALL), MAX(INT1), SUM(BIG), MIN(NUM), MAX(DEC),
    MIN(VCHAR_INLINE), MAX(VCHAR_OUTLINE_MIN), MIN(VCHAR), MAX(VCHAR_JSON), MIN(TIME1)
    -- Will not work with SqlCoverage/PostgreSQL:
    , MAX(VARBIN), MIN(POINT), MAX(POLYGON)
    , MIN(IPV4), MAX(IPV6), MIN(VBIPV4), MAX(VBIPV6)
  FROM P3
GROUP BY VCHAR_INLINE_MAX;


CREATE VIEW VR4 (VCHAR, BIG,
    ID, TINY, SMALL, INT1, NUM, DEC,
    VCHAR_INLINE, VCHAR_INLINE_MAX, VCHAR_OUTLINE_MIN, VCHAR_JSON, TIME1
    -- Will not work with SqlCoverage/PostgreSQL:
    , VARBIN, POINT, POLYGON
    , IPV4, IPV6, VBIPV4, VBIPV6
    ) AS
  SELECT VCHAR, BIG,
    COUNT(*), SUM(TINY), MAX(SMALL), COUNT(VCHAR_INLINE_MAX), MAX(NUM), MIN(DEC),
    MAX(VCHAR_INLINE), MIN(VCHAR_INLINE_MAX), MAX(VCHAR_OUTLINE_MIN), MIN(VCHAR_JSON), MAX(TIME1)
    -- Will not work with SqlCoverage/PostgreSQL:
    , MIN(VARBIN), MAX(POINT), MIN(POLYGON)
    , MAX(IPV4), MIN(IPV6), MAX(VBIPV4), MIN(VBIPV6)
  FROM R4 WHERE VCHAR_INLINE < 'N'
GROUP BY VCHAR, BIG;
CREATE INDEX IDX_VR4_VB  ON VR4 (VCHAR, BIG)             WHERE BIG >= 0;
CREATE INDEX IDX_VR4_IDV ON VR4 (INT1, DEC, VCHAR_INLINE) WHERE VCHAR_INLINE < 'a';
CREATE INDEX IDX_VR4_VMB ON VR4 (VCHAR_INLINE_MAX, BIG)  WHERE BIG >= 0 AND VCHAR_INLINE_MAX IS NOT NULL;

CREATE VIEW VP4 (VCHAR, BIG,
    ID, TINY, SMALL, INT1, NUM, DEC,
    VCHAR_INLINE, VCHAR_INLINE_MAX, VCHAR_OUTLINE_MIN, VCHAR_JSON, TIME1
    -- Will not work with SqlCoverage/PostgreSQL:
    , VARBIN, POINT, POLYGON
    , IPV4, IPV6, VBIPV4, VBIPV6
    ) AS
  SELECT VCHAR, BIG,
    COUNT(*), SUM(TINY), MAX(SMALL), COUNT(VCHAR_INLINE_MAX), MAX(NUM), MIN(DEC),
    MAX(VCHAR_INLINE), MIN(VCHAR_INLINE_MAX), MAX(VCHAR_OUTLINE_MIN), MIN(VCHAR_JSON), MAX(TIME1)
    -- Will not work with SqlCoverage/PostgreSQL:
    , MIN(VARBIN), MAX(POINT), MIN(POLYGON)
    , MAX(IPV4), MIN(IPV6), MAX(VBIPV4), MIN(VBIPV6)
  FROM P4 WHERE VCHAR_INLINE < 'N'
GROUP BY VCHAR, BIG;
CREATE INDEX IDX_VP4_VB  ON VP4 (VCHAR, BIG)             WHERE BIG >= 0;
CREATE INDEX IDX_VP4_IDV ON VP4 (INT1, DEC, VCHAR_INLINE) WHERE VCHAR_INLINE < 'a';
CREATE INDEX IDX_VP4_VMB ON VP4 (VCHAR_INLINE_MAX, BIG)  WHERE BIG >= 0 AND VCHAR_INLINE_MAX IS NOT NULL;


CREATE VIEW VR5 (SMALL, VCHAR, TINY,
    ID, INT1, BIG, NUM, DEC,
    VCHAR_INLINE, VCHAR_INLINE_MAX, VCHAR_OUTLINE_MIN, VCHAR_JSON, TIME1
    -- Will not work with SqlCoverage/PostgreSQL:
    , VARBIN, POINT, POLYGON
    , IPV4, IPV6, VBIPV4, VBIPV6
    ) AS
  SELECT SMALL, VCHAR, TINY,
    COUNT(*), COUNT(TIME1), COUNT(POINT), SUM(NUM), SUM(DEC),
    MIN(VCHAR_INLINE), MAX(VCHAR_INLINE_MAX), MIN(VCHAR_OUTLINE_MIN), MAX(VCHAR_JSON), MIN(TIME1)
    -- Will not work with SqlCoverage/PostgreSQL:
    , MAX(VARBIN), MIN(POINT), MAX(POLYGON)
    , MIN(IPV4), MAX(IPV6), MIN(VBIPV4), MAX(VBIPV6)
  FROM R5 WHERE TINY < 64
GROUP BY SMALL, VCHAR, TINY;
CREATE INDEX IDX_VR5_SVT ON VR5 (SMALL, VCHAR, TINY)      WHERE SMALL >= 0;
CREATE INDEX IDX_VR5_VID ON VR5 (VCHAR_INLINE, INT1, DEC)  WHERE VCHAR_INLINE < 'a';
CREATE INDEX IDX_VR5_VS  ON VR5 (VCHAR_INLINE_MAX, SMALL) WHERE SMALL >= 0 AND VCHAR_INLINE_MAX IS NOT NULL;

CREATE VIEW VP5 (SMALL, VCHAR, TINY,
    ID, INT1, BIG, NUM, DEC,
    VCHAR_INLINE, VCHAR_INLINE_MAX, VCHAR_OUTLINE_MIN, VCHAR_JSON, TIME1
    -- Will not work with SqlCoverage/PostgreSQL:
    , VARBIN, POINT, POLYGON
    , IPV4, IPV6, VBIPV4, VBIPV6
    ) AS
  SELECT SMALL, VCHAR, TINY,
    COUNT(*), COUNT(VARBIN), COUNT(POLYGON), SUM(NUM), SUM(DEC),
    MIN(VCHAR_INLINE), MAX(VCHAR_INLINE_MAX), MIN(VCHAR_OUTLINE_MIN), MAX(VCHAR_JSON), MIN(TIME1)
    -- Will not work with SqlCoverage/PostgreSQL:
    , MAX(VARBIN), MIN(POINT), MAX(POLYGON)
    , MIN(IPV4), MAX(IPV6), MIN(VBIPV4), MAX(VBIPV6)
  FROM P5 WHERE TINY < 64
GROUP BY SMALL, VCHAR, TINY;
CREATE INDEX IDX_VP5_SVT ON VP5 (SMALL, VCHAR, TINY)      WHERE SMALL >= 0;
CREATE INDEX IDX_VP5_VID ON VP5 (VCHAR_INLINE, INT1, DEC)  WHERE VCHAR_INLINE < 'a';
CREATE INDEX IDX_VP5_VS  ON VP5 (VCHAR_INLINE_MAX, SMALL) WHERE SMALL >= 0 AND VCHAR_INLINE_MAX IS NOT NULL;

-- A few materialized views without COUNT(*), per ENG-10892
-- (based on VR1, VP1, VR5, and VP5, above):
CREATE VIEW VR6 (TINY,
    ID, SMALL, INT1, BIG, NUM, DEC,
    VCHAR_INLINE, VCHAR_INLINE_MAX, VCHAR_OUTLINE_MIN, VCHAR, VCHAR_JSON, TIME1
    -- Will not work with SqlCoverage/PostgreSQL:
    , VARBIN, POINT, POLYGON
    , IPV4, IPV6, VBIPV4, VBIPV6
    ) AS
  SELECT TINY,
    MIN(ID), SUM(SMALL), COUNT(INT1), MIN(BIG), MAX(NUM), SUM(DEC),
    MIN(VCHAR_INLINE), MIN(VCHAR_INLINE_MAX), MIN(VCHAR_OUTLINE_MIN), MIN(VCHAR), MIN(VCHAR_JSON), MIN(TIME1)
    -- Will not work with SqlCoverage/PostgreSQL:
    , MIN(VARBIN), MIN(POINT), MIN(POLYGON)
    , MIN(IPV4), MIN(IPV6), MIN(VBIPV4), MIN(VBIPV6)
  FROM R1
GROUP BY TINY;

CREATE VIEW VP6 (TINY,
    ID, SMALL, INT1, BIG, NUM, DEC,
    VCHAR_INLINE, VCHAR_INLINE_MAX, VCHAR_OUTLINE_MIN, VCHAR, VCHAR_JSON, TIME1
    -- Will not work with SqlCoverage/PostgreSQL:
    , VARBIN, POINT, POLYGON
    , IPV4, IPV6, VBIPV4, VBIPV6
    ) AS
  SELECT TINY,
    MAX(ID), SUM(SMALL), COUNT(INT1), MIN(BIG), MAX(NUM), SUM(DEC),
    MIN(VCHAR_INLINE), MIN(VCHAR_INLINE_MAX), MIN(VCHAR_OUTLINE_MIN), MIN(VCHAR), MIN(VCHAR_JSON), MIN(TIME1)
    -- Will not work with SqlCoverage/PostgreSQL:
    , MIN(VARBIN), MIN(POINT), MIN(POLYGON)
    , MIN(IPV4), MIN(IPV6), MIN(VBIPV4), MIN(VBIPV6)
  FROM P1
GROUP BY TINY;


CREATE VIEW VR7 (SMALL, VCHAR, TINY,
    ID, INT1, BIG, NUM, DEC,
    VCHAR_INLINE, VCHAR_INLINE_MAX, VCHAR_OUTLINE_MIN, VCHAR_JSON, TIME1
    -- Will not work with SqlCoverage/PostgreSQL:
    , VARBIN, POINT, POLYGON
    , IPV4, IPV6, VBIPV4, VBIPV6
    ) AS
  SELECT SMALL, VCHAR, TINY,
    MAX(ID), COUNT(TIME1), COUNT(POINT), SUM(NUM), SUM(DEC),
    MIN(VCHAR_INLINE), MAX(VCHAR_INLINE_MAX), MIN(VCHAR_OUTLINE_MIN), MAX(VCHAR_JSON), MIN(TIME1)
    -- Will not work with SqlCoverage/PostgreSQL:
    , MAX(VARBIN), MIN(POINT), MAX(POLYGON)
    , MIN(IPV4), MAX(IPV6), MIN(VBIPV4), MAX(VBIPV6)
  FROM R5 WHERE TINY < 64
GROUP BY SMALL, VCHAR, TINY;
CREATE INDEX IDX_VR7_SVT ON VR7 (SMALL, VCHAR, TINY)      WHERE SMALL >= 0;
CREATE INDEX IDX_VR7_VID ON VR7 (VCHAR_INLINE, INT1, DEC)  WHERE VCHAR_INLINE < 'a';
CREATE INDEX IDX_VR7_VS  ON VR7 (VCHAR_INLINE_MAX, SMALL) WHERE SMALL >= 0 AND VCHAR_INLINE_MAX IS NOT NULL;

CREATE VIEW VP7 (SMALL, VCHAR, TINY,
    ID, INT1, BIG, NUM, DEC,
    VCHAR_INLINE, VCHAR_INLINE_MAX, VCHAR_OUTLINE_MIN, VCHAR_JSON, TIME1
    -- Will not work with SqlCoverage/PostgreSQL:
    , VARBIN, POINT, POLYGON
    , IPV4, IPV6, VBIPV4, VBIPV6
    ) AS
  SELECT SMALL, VCHAR, TINY,
    MIN(ID), COUNT(VARBIN), COUNT(POLYGON), SUM(NUM), SUM(DEC),
    MIN(VCHAR_INLINE), MAX(VCHAR_INLINE_MAX), MIN(VCHAR_OUTLINE_MIN), MAX(VCHAR_JSON), MIN(TIME1)
    -- Will not work with SqlCoverage/PostgreSQL:
    , MAX(VARBIN), MIN(POINT), MAX(POLYGON)
    , MIN(IPV4), MAX(IPV6), MIN(VBIPV4), MAX(VBIPV6)
  FROM P5 WHERE TINY < 64
GROUP BY SMALL, VCHAR, TINY;
CREATE INDEX IDX_VP7_SVT ON VP7 (SMALL, VCHAR, TINY)      WHERE SMALL >= 0;
CREATE INDEX IDX_VP7_VID ON VP7 (VCHAR_INLINE, INT1, DEC)  WHERE VCHAR_INLINE < 'a';
CREATE INDEX IDX_VP7_VS  ON VP7 (VCHAR_INLINE_MAX, SMALL) WHERE SMALL >= 0 AND VCHAR_INLINE_MAX IS NOT NULL;

END_OF_BATCH_4
file -inlinebatch END_OF_BATCH_5

-- The following are SQL stored procedures defined on some of the above tables
-- Note: some of these stored procedures (namely the "insMin" & "insMax" ones)
-- that are defined for replicated tables are not supported for partitioned
-- tables, and are therefore omitted.
CREATE PROCEDURE SSPR0min    AS SELECT MIN(ID) FROM R0;
CREATE PROCEDURE SSPR0max    AS SELECT MAX(ID) FROM R0;
CREATE PROCEDURE SSPR0insMin AS INSERT INTO R0 VALUES ((SELECT MIN(ID)-1 FROM R0),
                                                       0, 0, 0, 0, 0, 0,
                                                       'abc', 'ABC', 'XYZ', 'xyz', '{jsonValue:0}',
                                                       null, null, null, null, null, null, null, null);
CREATE PROCEDURE SSPR0insMax AS INSERT INTO R0 VALUES ((SELECT MAX(ID)-1 FROM R0),
                                                       0, 0, 0, 0, 0, 0,
                                                       'abc', 'ABC', 'XYZ', 'xyz', '{jsonValue:0}',
                                                       null, null, null, null, null, null, null, null);
CREATE PROCEDURE SSPR0ins    AS INSERT INTO R0 VALUES (?,
                                                       0, 0, 0, 0, 0, 0,
                                                       'abc', 'ABC', 'XYZ', 'xyz', '{jsonValue:0}',
                                                       null, null, null, null, null, null, null, null);
CREATE PROCEDURE SSPR0sel    AS SELECT * FROM R0 WHERE ID = ?;
CREATE PROCEDURE SSPP0min    AS SELECT MIN(ID) FROM P0;
CREATE PROCEDURE SSPP0max    AS SELECT MAX(ID) FROM P0;
CREATE PROCEDURE SSPP0ins    AS INSERT INTO P0 VALUES (?,
                                                       0, 0, 0, 0, 0, 0,
                                                       'abc', 'ABC', 'XYZ', 'xyz', '{jsonValue:0}',
                                                       null, null, null, null, null, null, null, null);
CREATE PROCEDURE SSPP0sel    AS SELECT * FROM P0 WHERE ID = ?;

CREATE PROCEDURE SSPR1min    AS SELECT MIN(ID) FROM R1;
CREATE PROCEDURE SSPR1max    AS SELECT MAX(ID) FROM R1;
CREATE PROCEDURE SSPR1insMin AS INSERT INTO R1 VALUES ((SELECT MIN(ID)-1 FROM R1),
                                                       0, 0, 0, 0, 0, 0,
                                                       'abc', 'ABC', 'XYZ', 'xyz', '{jsonValue:0}',
                                                       null, null, null, null, null, null, null, null);
CREATE PROCEDURE SSPR1insMax AS INSERT INTO R1 VALUES ((SELECT MAX(ID)-1 FROM R1),
                                                       0, 0, 0, 0, 0, 0,
                                                       'abc', 'ABC', 'XYZ', 'xyz', '{jsonValue:0}',
                                                       null, null, null, null, null, null, null, null);
CREATE PROCEDURE SSPR1ins    AS INSERT INTO R1 VALUES (?,
                                                       0, 0, 0, 0, 0, 0,
                                                       'abc', 'ABC', 'XYZ', 'xyz', '{jsonValue:0}',
                                                       null, null, null, null, null, null, null, null);
CREATE PROCEDURE SSPR1sel    AS SELECT * FROM R1 WHERE ID = ?;
CREATE PROCEDURE SSPP1min    AS SELECT MIN(ID) FROM P1;
CREATE PROCEDURE SSPP1max    AS SELECT MAX(ID) FROM P1;
CREATE PROCEDURE SSPP1ins    AS INSERT INTO P1 VALUES (?,
                                                       0, 0, 0, 0, 0, 0,
                                                       'abc', 'ABC', 'XYZ', 'xyz', '{jsonValue:0}',
                                                       null, null, null, null, null, null, null, null);
CREATE PROCEDURE SSPP1sel    AS SELECT * FROM P1 WHERE ID = ?;

CREATE PROCEDURE SSPR2min    AS SELECT MIN(ID) FROM R2;
CREATE PROCEDURE SSPR2max    AS SELECT MAX(ID) FROM R2;
CREATE PROCEDURE SSPR2insMin AS INSERT INTO R2 VALUES ((SELECT MIN(ID)-1 FROM R2),
                                                       0, 0, 0, 0, 0, 0,
                                                       'abc', 'ABC', 'XYZ', 'xyz', '{jsonValue:0}',
                                                       null, null, null, null, null, null, null, null);
CREATE PROCEDURE SSPR2insMax AS INSERT INTO R2 VALUES ((SELECT MAX(ID)-1 FROM R2),
                                                       0, 0, 0, 0, 0, 0,
                                                       'abc', 'ABC', 'XYZ', 'xyz', '{jsonValue:0}',
                                                       null, null, null, null, null, null, null, null);
CREATE PROCEDURE SSPR2ins    AS INSERT INTO R2 VALUES (?,
                                                       0, 0, 0, 0, 0, 0,
                                                       'abc', 'ABC', 'XYZ', 'xyz', '{jsonValue:0}',
                                                       null, null, null, null, null, null, null, null);
CREATE PROCEDURE SSPR2sel    AS SELECT * FROM R2 WHERE ID = ?;
CREATE PROCEDURE SSPP2min    AS SELECT MIN(ID) FROM P2;
CREATE PROCEDURE SSPP2max    AS SELECT MAX(ID) FROM P2;
CREATE PROCEDURE SSPP2ins    AS INSERT INTO P2 VALUES (?,
                                                       0, 0, 0, 0, 0, 0,
                                                       'abc', 'ABC', 'XYZ', 'xyz', '{jsonValue:0}',
                                                       null, null, null, null, null, null, null, null);
CREATE PROCEDURE SSPP2sel    AS SELECT * FROM P2 WHERE ID = ?;

END_OF_BATCH_5

-- The following are Java stored procedures defined on some of the above tables
load classes testgrammar.jar;

file -inlinebatch END_OF_BATCH_6

CREATE PROCEDURE FROM CLASS sqlgrammartest.JSPR1min;
CREATE PROCEDURE FROM CLASS sqlgrammartest.JSPR1max;
CREATE PROCEDURE FROM CLASS sqlgrammartest.JSPR1insMin;
CREATE PROCEDURE FROM CLASS sqlgrammartest.JSPR1insMax;
CREATE PROCEDURE FROM CLASS sqlgrammartest.JSPR1ins;
CREATE PROCEDURE FROM CLASS sqlgrammartest.JSPR1sel;
CREATE PROCEDURE FROM CLASS sqlgrammartest.JSPP1min;
CREATE PROCEDURE FROM CLASS sqlgrammartest.JSPP1max;
CREATE PROCEDURE FROM CLASS sqlgrammartest.JSPP1insMin;
CREATE PROCEDURE FROM CLASS sqlgrammartest.JSPP1insMax;
CREATE PROCEDURE FROM CLASS sqlgrammartest.JSPP1ins;
CREATE PROCEDURE FROM CLASS sqlgrammartest.JSPP1sel;

END_OF_BATCH_6
