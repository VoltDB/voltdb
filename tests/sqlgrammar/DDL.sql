-- Define "standard" DDL (tables, indexes, views), for use with the SQL grammar generator

-- Drop all items first, in case they already exist
file -inlinebatch END_OF_BATCH_1

DROP PROCEDURE RPROC0      IF EXISTS;
DROP PROCEDURE RPROC1      IF EXISTS;
DROP PROCEDURE RPROC2      IF EXISTS;
DROP PROCEDURE RPROC3      IF EXISTS;
DROP PROCEDURE RPROC4      IF EXISTS;
DROP PROCEDURE RPROC5      IF EXISTS;
DROP PROCEDURE RPROC6      IF EXISTS;
DROP PROCEDURE RPROC7      IF EXISTS;
DROP PROCEDURE RPROC8      IF EXISTS;
DROP PROCEDURE RPROC9      IF EXISTS;

DROP PROCEDURE SSPR0min    IF EXISTS;
DROP PROCEDURE SSPR0max    IF EXISTS;
DROP PROCEDURE SSPR0insMin IF EXISTS;
DROP PROCEDURE SSPR0insMax IF EXISTS;
DROP PROCEDURE SSPR0ins    IF EXISTS;
DROP PROCEDURE SSPR0sel    IF EXISTS;
DROP PROCEDURE SSPP0min    IF EXISTS;
DROP PROCEDURE SSPP0max    IF EXISTS;
DROP PROCEDURE SSPP0insMin IF EXISTS;
DROP PROCEDURE SSPP0insMax IF EXISTS;
DROP PROCEDURE SSPP0ins    IF EXISTS;
DROP PROCEDURE SSPP0sel    IF EXISTS;
DROP PROCEDURE SSPR1min    IF EXISTS;
DROP PROCEDURE SSPR1max    IF EXISTS;
DROP PROCEDURE SSPR1insMin IF EXISTS;
DROP PROCEDURE SSPR1insMax IF EXISTS;
DROP PROCEDURE SSPR1ins    IF EXISTS;
DROP PROCEDURE SSPR1sel    IF EXISTS;
DROP PROCEDURE SSPP1min    IF EXISTS;
DROP PROCEDURE SSPP1max    IF EXISTS;
DROP PROCEDURE SSPP1insMin IF EXISTS;
DROP PROCEDURE SSPP1insMax IF EXISTS;
DROP PROCEDURE SSPP1ins    IF EXISTS;
DROP PROCEDURE SSPP1sel    IF EXISTS;
DROP PROCEDURE SSPR2min    IF EXISTS;
DROP PROCEDURE SSPR2max    IF EXISTS;
DROP PROCEDURE SSPR2insMin IF EXISTS;
DROP PROCEDURE SSPR2insMax IF EXISTS;
DROP PROCEDURE SSPR2ins    IF EXISTS;
DROP PROCEDURE SSPR2sel    IF EXISTS;
DROP PROCEDURE SSPP2min    IF EXISTS;
DROP PROCEDURE SSPP2max    IF EXISTS;
DROP PROCEDURE SSPP2insMin IF EXISTS;
DROP PROCEDURE SSPP2insMax IF EXISTS;
DROP PROCEDURE SSPP2ins    IF EXISTS;
DROP PROCEDURE SSPP2sel    IF EXISTS;
DROP PROCEDURE SSPR3min    IF EXISTS;
DROP PROCEDURE SSPR3max    IF EXISTS;
DROP PROCEDURE SSPR3insMin IF EXISTS;
DROP PROCEDURE SSPR3insMax IF EXISTS;
DROP PROCEDURE SSPR3ins    IF EXISTS;
DROP PROCEDURE SSPR3sel    IF EXISTS;
DROP PROCEDURE SSPP3min    IF EXISTS;
DROP PROCEDURE SSPP3max    IF EXISTS;
DROP PROCEDURE SSPP3insMin IF EXISTS;
DROP PROCEDURE SSPP3insMax IF EXISTS;
DROP PROCEDURE SSPP3ins    IF EXISTS;
DROP PROCEDURE SSPP3sel    IF EXISTS;
DROP PROCEDURE SSPR4min    IF EXISTS;
DROP PROCEDURE SSPR4max    IF EXISTS;
DROP PROCEDURE SSPR4insMin IF EXISTS;
DROP PROCEDURE SSPR4insMax IF EXISTS;
DROP PROCEDURE SSPR4ins    IF EXISTS;
DROP PROCEDURE SSPR4sel    IF EXISTS;
DROP PROCEDURE SSPP4min    IF EXISTS;
DROP PROCEDURE SSPP4max    IF EXISTS;
DROP PROCEDURE SSPP4insMin IF EXISTS;
DROP PROCEDURE SSPP4insMax IF EXISTS;
DROP PROCEDURE SSPP4ins    IF EXISTS;
DROP PROCEDURE SSPP4sel    IF EXISTS;
DROP PROCEDURE SSPR5min    IF EXISTS;
DROP PROCEDURE SSPR5max    IF EXISTS;
DROP PROCEDURE SSPR5insMin IF EXISTS;
DROP PROCEDURE SSPR5insMax IF EXISTS;
DROP PROCEDURE SSPR5ins    IF EXISTS;
DROP PROCEDURE SSPR5sel    IF EXISTS;
DROP PROCEDURE SSPP5min    IF EXISTS;
DROP PROCEDURE SSPP5max    IF EXISTS;
DROP PROCEDURE SSPP5insMin IF EXISTS;
DROP PROCEDURE SSPP5insMax IF EXISTS;
DROP PROCEDURE SSPP5ins    IF EXISTS;
DROP PROCEDURE SSPP5sel    IF EXISTS;
DROP PROCEDURE SSPR6min    IF EXISTS;
DROP PROCEDURE SSPR6max    IF EXISTS;
DROP PROCEDURE SSPR6insMin IF EXISTS;
DROP PROCEDURE SSPR6insMax IF EXISTS;
DROP PROCEDURE SSPR6ins    IF EXISTS;
DROP PROCEDURE SSPR6sel    IF EXISTS;
DROP PROCEDURE SSPP6min    IF EXISTS;
DROP PROCEDURE SSPP6max    IF EXISTS;
DROP PROCEDURE SSPP6insMin IF EXISTS;
DROP PROCEDURE SSPP6insMax IF EXISTS;
DROP PROCEDURE SSPP6ins    IF EXISTS;
DROP PROCEDURE SSPP6sel    IF EXISTS;
DROP PROCEDURE SSPR7min    IF EXISTS;
DROP PROCEDURE SSPR7max    IF EXISTS;
DROP PROCEDURE SSPR7insMin IF EXISTS;
DROP PROCEDURE SSPR7insMax IF EXISTS;
DROP PROCEDURE SSPR7ins    IF EXISTS;
DROP PROCEDURE SSPR7sel    IF EXISTS;
DROP PROCEDURE SSPP7min    IF EXISTS;
DROP PROCEDURE SSPP7max    IF EXISTS;
DROP PROCEDURE SSPP7insMin IF EXISTS;
DROP PROCEDURE SSPP7insMax IF EXISTS;
DROP PROCEDURE SSPP7ins    IF EXISTS;
DROP PROCEDURE SSPP7sel    IF EXISTS;

DROP PROCEDURE JSPR0min    IF EXISTS;
DROP PROCEDURE JSPR0max    IF EXISTS;
DROP PROCEDURE JSPR0insMin IF EXISTS;
DROP PROCEDURE JSPR0insMax IF EXISTS;
DROP PROCEDURE JSPR0ins    IF EXISTS;
DROP PROCEDURE JSPR0sel    IF EXISTS;
DROP PROCEDURE JSPP0min    IF EXISTS;
DROP PROCEDURE JSPP0max    IF EXISTS;
DROP PROCEDURE JSPP0insMin IF EXISTS;
DROP PROCEDURE JSPP0insMax IF EXISTS;
DROP PROCEDURE JSPP0ins    IF EXISTS;
DROP PROCEDURE JSPP0sel    IF EXISTS;
DROP PROCEDURE JSPR1min    IF EXISTS;
DROP PROCEDURE JSPR1max    IF EXISTS;
DROP PROCEDURE JSPR1insMin IF EXISTS;
DROP PROCEDURE JSPR1insMax IF EXISTS;
DROP PROCEDURE JSPR1ins    IF EXISTS;
DROP PROCEDURE JSPR1sel    IF EXISTS;
DROP PROCEDURE JSPP1min    IF EXISTS;
DROP PROCEDURE JSPP1max    IF EXISTS;
DROP PROCEDURE JSPP1insMin IF EXISTS;
DROP PROCEDURE JSPP1insMax IF EXISTS;
DROP PROCEDURE JSPP1ins    IF EXISTS;
DROP PROCEDURE JSPP1sel    IF EXISTS;
DROP PROCEDURE JSPR2min    IF EXISTS;
DROP PROCEDURE JSPR2max    IF EXISTS;
DROP PROCEDURE JSPR2insMin IF EXISTS;
DROP PROCEDURE JSPR2insMax IF EXISTS;
DROP PROCEDURE JSPR2ins    IF EXISTS;
DROP PROCEDURE JSPR2sel    IF EXISTS;
DROP PROCEDURE JSPP2min    IF EXISTS;
DROP PROCEDURE JSPP2max    IF EXISTS;
DROP PROCEDURE JSPP2insMin IF EXISTS;
DROP PROCEDURE JSPP2insMax IF EXISTS;
DROP PROCEDURE JSPP2ins    IF EXISTS;
DROP PROCEDURE JSPP2sel    IF EXISTS;
DROP PROCEDURE JSPR3min    IF EXISTS;
DROP PROCEDURE JSPR3max    IF EXISTS;
DROP PROCEDURE JSPR3insMin IF EXISTS;
DROP PROCEDURE JSPR3insMax IF EXISTS;
DROP PROCEDURE JSPR3ins    IF EXISTS;
DROP PROCEDURE JSPR3sel    IF EXISTS;
DROP PROCEDURE JSPP3min    IF EXISTS;
DROP PROCEDURE JSPP3max    IF EXISTS;
DROP PROCEDURE JSPP3insMin IF EXISTS;
DROP PROCEDURE JSPP3insMax IF EXISTS;
DROP PROCEDURE JSPP3ins    IF EXISTS;
DROP PROCEDURE JSPP3sel    IF EXISTS;
DROP PROCEDURE JSPR4min    IF EXISTS;
DROP PROCEDURE JSPR4max    IF EXISTS;
DROP PROCEDURE JSPR4insMin IF EXISTS;
DROP PROCEDURE JSPR4insMax IF EXISTS;
DROP PROCEDURE JSPR4ins    IF EXISTS;
DROP PROCEDURE JSPR4sel    IF EXISTS;
DROP PROCEDURE JSPP4min    IF EXISTS;
DROP PROCEDURE JSPP4max    IF EXISTS;
DROP PROCEDURE JSPP4insMin IF EXISTS;
DROP PROCEDURE JSPP4insMax IF EXISTS;
DROP PROCEDURE JSPP4ins    IF EXISTS;
DROP PROCEDURE JSPP4sel    IF EXISTS;
DROP PROCEDURE JSPR5min    IF EXISTS;
DROP PROCEDURE JSPR5max    IF EXISTS;
DROP PROCEDURE JSPR5insMin IF EXISTS;
DROP PROCEDURE JSPR5insMax IF EXISTS;
DROP PROCEDURE JSPR5ins    IF EXISTS;
DROP PROCEDURE JSPR5sel    IF EXISTS;
DROP PROCEDURE JSPP5min    IF EXISTS;
DROP PROCEDURE JSPP5max    IF EXISTS;
DROP PROCEDURE JSPP5insMin IF EXISTS;
DROP PROCEDURE JSPP5insMax IF EXISTS;
DROP PROCEDURE JSPP5ins    IF EXISTS;
DROP PROCEDURE JSPP5sel    IF EXISTS;
DROP PROCEDURE JSPR6min    IF EXISTS;
DROP PROCEDURE JSPR6max    IF EXISTS;
DROP PROCEDURE JSPR6insMin IF EXISTS;
DROP PROCEDURE JSPR6insMax IF EXISTS;
DROP PROCEDURE JSPR6ins    IF EXISTS;
DROP PROCEDURE JSPR6sel    IF EXISTS;
DROP PROCEDURE JSPP6min    IF EXISTS;
DROP PROCEDURE JSPP6max    IF EXISTS;
DROP PROCEDURE JSPP6insMin IF EXISTS;
DROP PROCEDURE JSPP6insMax IF EXISTS;
DROP PROCEDURE JSPP6ins    IF EXISTS;
DROP PROCEDURE JSPP6sel    IF EXISTS;
DROP PROCEDURE JSPR7min    IF EXISTS;
DROP PROCEDURE JSPR7max    IF EXISTS;
DROP PROCEDURE JSPR7insMin IF EXISTS;
DROP PROCEDURE JSPR7insMax IF EXISTS;
DROP PROCEDURE JSPR7ins    IF EXISTS;
DROP PROCEDURE JSPR7sel    IF EXISTS;
DROP PROCEDURE JSPP7min    IF EXISTS;
DROP PROCEDURE JSPP7max    IF EXISTS;
DROP PROCEDURE JSPP7insMin IF EXISTS;
DROP PROCEDURE JSPP7insMax IF EXISTS;
DROP PROCEDURE JSPP7ins    IF EXISTS;
DROP PROCEDURE JSPP7sel    IF EXISTS;

END_OF_BATCH_1

remove classes sqlgrammartest.*;

file -inlinebatch END_OF_BATCH_2

DROP TABLE R0 IF EXISTS CASCADE;
DROP TABLE P0 IF EXISTS CASCADE;
DROP TABLE R1 IF EXISTS CASCADE;
DROP TABLE P1 IF EXISTS CASCADE;
DROP TABLE R2 IF EXISTS CASCADE;
DROP TABLE P2 IF EXISTS CASCADE;
DROP TABLE R3 IF EXISTS CASCADE;
DROP TABLE P3 IF EXISTS CASCADE;
DROP TABLE R4 IF EXISTS CASCADE;
DROP TABLE P4 IF EXISTS CASCADE;
DROP TABLE R5 IF EXISTS CASCADE;
DROP TABLE P5 IF EXISTS CASCADE;
DROP TABLE R6 IF EXISTS CASCADE;
DROP TABLE P6 IF EXISTS CASCADE;
DROP TABLE R7 IF EXISTS CASCADE;
DROP TABLE P7 IF EXISTS CASCADE;
DROP TABLE R11 IF EXISTS CASCADE;
DROP TABLE P11 IF EXISTS CASCADE;
DROP TABLE R12 IF EXISTS CASCADE;
DROP TABLE P12 IF EXISTS CASCADE;
DROP TABLE R21 IF EXISTS CASCADE;
DROP TABLE P21 IF EXISTS CASCADE;
DROP TABLE R22 IF EXISTS CASCADE;
DROP TABLE P22 IF EXISTS CASCADE;

END_OF_BATCH_2
file -inlinebatch END_OF_BATCH_3

CREATE TABLE R0 (
  ID      INTEGER,
  TINY    TINYINT,
  SMALL   SMALLINT,
  INT     INTEGER,
  BIG     BIGINT,
  NUM     FLOAT,
  DEC     DECIMAL,
  VCHAR_INLINE      VARCHAR(14),
  VCHAR_INLINE_MAX  VARCHAR(63 BYTES),
  VCHAR_OUTLINE_MIN VARCHAR(64 BYTES),
  VCHAR             VARCHAR,
  VCHAR_JSON        VARCHAR(1000),
  TIME    TIMESTAMP,
  VARBIN  VARBINARY(100),
  POINT   GEOGRAPHY_POINT,
  POLYGON GEOGRAPHY,
  -- Used to test internet address functions:
  -- INET6_ATON, INET6_NTOA, INET_ATON, INET_NTOA
  IPV4    VARCHAR(15),
  IPV6    VARCHAR(60),
  VBIPV4  VARBINARY(4),
  VBIPV6  VARBINARY(16)
);

CREATE TABLE P0 (
  ID      INTEGER NOT NULL,
  TINY    TINYINT,
  SMALL   SMALLINT,
  INT     INTEGER,
  BIG     BIGINT,
  NUM     FLOAT,
  DEC     DECIMAL,
  VCHAR_INLINE      VARCHAR(14),
  VCHAR_INLINE_MAX  VARCHAR(63 BYTES),
  VCHAR_OUTLINE_MIN VARCHAR(64 BYTES),
  VCHAR             VARCHAR,
  VCHAR_JSON        VARCHAR(1000),
  TIME    TIMESTAMP,
  VARBIN  VARBINARY(100),
  POINT   GEOGRAPHY_POINT,
  POLYGON GEOGRAPHY,
  -- Used to test internet address functions:
  -- INET6_ATON, INET6_NTOA, INET_ATON, INET_NTOA
  IPV4    VARCHAR(15),
  IPV6    VARCHAR(60),
  VBIPV4  VARBINARY(4),
  VBIPV6  VARBINARY(16)
);
PARTITION TABLE P0 ON COLUMN ID;

CREATE TABLE R1 (
  ID      INTEGER NOT NULL PRIMARY KEY,
  TINY    TINYINT,
  SMALL   SMALLINT,
  INT     INTEGER,
  BIG     BIGINT,
  NUM     FLOAT,
  DEC     DECIMAL,
  VCHAR_INLINE      VARCHAR(42 BYTES),
  VCHAR_INLINE_MAX  VARCHAR(15),
  VCHAR_OUTLINE_MIN VARCHAR(16),
  VCHAR             VARCHAR,
  VCHAR_JSON        VARCHAR(4000 BYTES),
  TIME    TIMESTAMP,
  VARBIN  VARBINARY(100),
  POINT   GEOGRAPHY_POINT,
  POLYGON GEOGRAPHY,
  -- Used to test internet address functions:
  -- INET6_ATON, INET6_NTOA, INET_ATON, INET_NTOA
  IPV4    VARCHAR(15),
  IPV6    VARCHAR(60),
  VBIPV4  VARBINARY(4),
  VBIPV6  VARBINARY(16)
);

CREATE TABLE P1 (
  ID      INTEGER NOT NULL PRIMARY KEY,
  TINY    TINYINT,
  SMALL   SMALLINT,
  INT     INTEGER,
  BIG     BIGINT,
  NUM     FLOAT,
  DEC     DECIMAL,
  VCHAR_INLINE      VARCHAR(42 BYTES),
  VCHAR_INLINE_MAX  VARCHAR(15),
  VCHAR_OUTLINE_MIN VARCHAR(16),
  VCHAR             VARCHAR,
  VCHAR_JSON        VARCHAR(4000 BYTES),
  TIME    TIMESTAMP,
  VARBIN  VARBINARY(100),
  POINT   GEOGRAPHY_POINT,
  POLYGON GEOGRAPHY,
  -- Used to test internet address functions:
  -- INET6_ATON, INET6_NTOA, INET_ATON, INET_NTOA
  IPV4    VARCHAR(15),
  IPV6    VARCHAR(60),
  VBIPV4  VARBINARY(4),
  VBIPV6  VARBINARY(16)
);
PARTITION TABLE P1 ON COLUMN ID;

CREATE TABLE R2 (
  ID      INTEGER NOT NULL,
  TINY    TINYINT,
  SMALL   SMALLINT,
  INT     INTEGER,
  BIG     BIGINT,
  NUM     FLOAT,
  DEC     DECIMAL,
  VCHAR_INLINE      VARCHAR(14),
  VCHAR_INLINE_MAX  VARCHAR(63 BYTES),
  VCHAR_OUTLINE_MIN VARCHAR(64 BYTES),
  VCHAR             VARCHAR,
  VCHAR_JSON        VARCHAR(1000),
  TIME    TIMESTAMP,
  VARBIN  VARBINARY(100),
  POINT   GEOGRAPHY_POINT,
  POLYGON GEOGRAPHY,
  -- Used to test internet address functions:
  -- INET6_ATON, INET6_NTOA, INET_ATON, INET_NTOA
  IPV4    VARCHAR(15),
  IPV6    VARCHAR(60),
  VBIPV4  VARBINARY(4),
  VBIPV6  VARBINARY(16),
  PRIMARY KEY (ID)
);
CREATE INDEX IDX_R2_TINY ON R2 (TINY);
CREATE INDEX IDX_R2_BIG  ON R2 (BIG);
CREATE INDEX IDX_R2_DEC  ON R2 (DEC);
CREATE INDEX IDX_R2_VIM  ON R2 (VCHAR_INLINE_MAX);
CREATE INDEX IDX_R2_TIME ON R2 (TIME);
CREATE INDEX IDX_R2_VBIN ON R2 (VARBIN);
CREATE INDEX IDX_R2_POLY ON R2 (POLYGON);

CREATE TABLE P2 (
  ID      INTEGER NOT NULL,
  TINY    TINYINT,
  SMALL   SMALLINT,
  INT     INTEGER,
  BIG     BIGINT,
  NUM     FLOAT,
  DEC     DECIMAL,
  VCHAR_INLINE      VARCHAR(14),
  VCHAR_INLINE_MAX  VARCHAR(63 BYTES),
  VCHAR_OUTLINE_MIN VARCHAR(64 BYTES),
  VCHAR             VARCHAR,
  VCHAR_JSON        VARCHAR(1000),
  TIME    TIMESTAMP,
  VARBIN  VARBINARY(100),
  POINT   GEOGRAPHY_POINT,
  POLYGON GEOGRAPHY,
  -- Used to test internet address functions:
  -- INET6_ATON, INET6_NTOA, INET_ATON, INET_NTOA
  IPV4    VARCHAR(15),
  IPV6    VARCHAR(60),
  VBIPV4  VARBINARY(4),
  VBIPV6  VARBINARY(16),
  PRIMARY KEY (ID)
);
PARTITION TABLE P2 ON COLUMN ID;
CREATE INDEX IDX_P2_TINY ON P2 (TINY);
CREATE INDEX IDX_P2_BIG  ON P2 (BIG);
CREATE INDEX IDX_P2_DEC  ON P2 (DEC);
CREATE INDEX IDX_P2_VIM  ON P2 (VCHAR_INLINE_MAX);
CREATE INDEX IDX_P2_TIME ON P2 (TIME);
CREATE INDEX IDX_P2_VBIN ON P2 (VARBIN);
CREATE INDEX IDX_P2_POLY ON P2 (POLYGON);

CREATE TABLE R3 (
  ID      INTEGER NOT NULL,
  TINY    TINYINT,
  SMALL   SMALLINT,
  INT     INTEGER,
  BIG     BIGINT,
  NUM     FLOAT,
  DEC     DECIMAL,
  VCHAR_INLINE      VARCHAR(42 BYTES),
  VCHAR_INLINE_MAX  VARCHAR(15),
  VCHAR_OUTLINE_MIN VARCHAR(16),
  VCHAR             VARCHAR,
  VCHAR_JSON        VARCHAR(4000 BYTES),
  TIME    TIMESTAMP,
  VARBIN  VARBINARY(100),
  POINT   GEOGRAPHY_POINT,
  POLYGON GEOGRAPHY,
  -- Used to test internet address functions:
  -- INET6_ATON, INET6_NTOA, INET_ATON, INET_NTOA
  IPV4    VARCHAR(15),
  IPV6    VARCHAR(60),
  VBIPV4  VARBINARY(4),
  VBIPV6  VARBINARY(16),
  PRIMARY KEY (VCHAR)
  -- Will not work with SqlCoverage/PostgreSQL (2 lines):
  , CONSTRAINT IDX_R3_TV  UNIQUE (TINY, VCHAR)
  , CONSTRAINT IDX_R3_VSI UNIQUE (VCHAR_INLINE, INT, NUM)
);

CREATE TABLE P3 (
  ID      INTEGER,
  TINY    TINYINT,
  SMALL   SMALLINT,
  INT     INTEGER,
  BIG     BIGINT,
  NUM     FLOAT,
  DEC     DECIMAL,
  VCHAR_INLINE      VARCHAR(42 BYTES),
  VCHAR_INLINE_MAX  VARCHAR(15),
  VCHAR_OUTLINE_MIN VARCHAR(16),
  VCHAR             VARCHAR NOT NULL,
  VCHAR_JSON        VARCHAR(4000 BYTES),
  TIME    TIMESTAMP,
  VARBIN  VARBINARY(100),
  POINT   GEOGRAPHY_POINT,
  POLYGON GEOGRAPHY,
  -- Used to test internet address functions:
  -- INET6_ATON, INET6_NTOA, INET_ATON, INET_NTOA
  IPV4    VARCHAR(15),
  IPV6    VARCHAR(60),
  VBIPV4  VARBINARY(4),
  VBIPV6  VARBINARY(16),
  PRIMARY KEY (VCHAR)
  -- Will not work with SqlCoverage/PostgreSQL (2 lines):
  , CONSTRAINT IDX_P3_TV        UNIQUE (TINY, VCHAR)
  , CONSTRAINT IDX_P3_VSI ASSUMEUNIQUE (VCHAR_INLINE, INT, NUM)
);
PARTITION TABLE P3 ON COLUMN VCHAR;

CREATE TABLE R4 (
  ID      INTEGER  DEFAULT 0,
  TINY    TINYINT  DEFAULT 0,
  SMALL   SMALLINT DEFAULT 0,
  INT     INTEGER  DEFAULT 0,
  BIG     BIGINT   DEFAULT 0,
  NUM     FLOAT    DEFAULT 0,
  DEC     DECIMAL  DEFAULT 0,
  VCHAR_INLINE      VARCHAR(14)       DEFAULT '0',
  VCHAR_INLINE_MAX  VARCHAR(63 BYTES) DEFAULT '0',
  VCHAR_OUTLINE_MIN VARCHAR(64 BYTES) DEFAULT '0' NOT NULL,
  VCHAR             VARCHAR           DEFAULT '0',
  VCHAR_JSON        VARCHAR(1000)     DEFAULT '0',
  TIME    TIMESTAMP       DEFAULT '2013-10-30 23:22:29',
  VARBIN  VARBINARY(100)  DEFAULT x'00',
  -- Default values of GEOGRAPHY_POINT and GEOGRAPHY not supported (ENG-12028)
  POINT   GEOGRAPHY_POINT,
  POLYGON GEOGRAPHY,
  -- Used to test internet address functions:
  -- INET6_ATON, INET6_NTOA, INET_ATON, INET_NTOA
  IPV4    VARCHAR(15),
  IPV6    VARCHAR(60),
  VBIPV4  VARBINARY(4),
  VBIPV6  VARBINARY(16),
  PRIMARY KEY (ID, VCHAR_OUTLINE_MIN)
);
-- Will not work with SqlCoverage/PostgreSQL (2 lines):
CREATE UNIQUE INDEX IDX_R4_TV  ON R4 (TINY, VCHAR);
CREATE UNIQUE INDEX IDX_R4_VSI ON R4 (VCHAR, SMALL, INT);

CREATE TABLE P4 (
  ID      INTEGER  DEFAULT 0,
  TINY    TINYINT  DEFAULT 0,
  SMALL   SMALLINT DEFAULT 0,
  INT     INTEGER  DEFAULT 0,
  BIG     BIGINT   DEFAULT 0,
  NUM     FLOAT    DEFAULT 0,
  DEC     DECIMAL  DEFAULT 0,
  VCHAR_INLINE      VARCHAR(14)       DEFAULT '0',
  VCHAR_INLINE_MAX  VARCHAR(63 BYTES) DEFAULT '0',
  VCHAR_OUTLINE_MIN VARCHAR(64 BYTES) DEFAULT '0' NOT NULL,
  VCHAR             VARCHAR           DEFAULT '0',
  VCHAR_JSON        VARCHAR(1000)     DEFAULT '0',
  TIME    TIMESTAMP       DEFAULT '2013-10-30 23:22:29',
  VARBIN  VARBINARY(100)  DEFAULT x'00',
  -- Default values of GEOGRAPHY_POINT and GEOGRAPHY not supported (ENG-12028)
  POINT   GEOGRAPHY_POINT,
  POLYGON GEOGRAPHY,
  -- Used to test internet address functions:
  -- INET6_ATON, INET6_NTOA, INET_ATON, INET_NTOA
  IPV4    VARCHAR(15),
  IPV6    VARCHAR(60),
  VBIPV4  VARBINARY(4),
  VBIPV6  VARBINARY(16),
  PRIMARY KEY (ID, VCHAR_OUTLINE_MIN)
);
PARTITION TABLE P4 ON COLUMN VCHAR_OUTLINE_MIN;
-- Will not work with SqlCoverage/PostgreSQL (2 lines):
CREATE       UNIQUE INDEX IDX_P4_TV  ON P4 (TINY, VCHAR_OUTLINE_MIN);
CREATE ASSUMEUNIQUE INDEX IDX_P4_VSI ON P4 (VCHAR_INLINE_MAX, SMALL, INT);

CREATE TABLE R5 (
  ID      INTEGER  NOT NULL,
  TINY    TINYINT  NOT NULL,
  SMALL   SMALLINT NOT NULL,
  INT     INTEGER  NOT NULL,
  BIG     BIGINT   NOT NULL,
  NUM     FLOAT    NOT NULL,
  DEC     DECIMAL  NOT NULL,
  VCHAR_INLINE      VARCHAR(42 BYTES)   NOT NULL,
  VCHAR_INLINE_MAX  VARCHAR(15)         NOT NULL,
  VCHAR_OUTLINE_MIN VARCHAR(16)         NOT NULL,
  VCHAR             VARCHAR             NOT NULL,
  VCHAR_JSON        VARCHAR(4000 BYTES) NOT NULL,
  TIME    TIMESTAMP       NOT NULL,
  VARBIN  VARBINARY(100)  NOT NULL,
  POINT   GEOGRAPHY_POINT NOT NULL,
  POLYGON GEOGRAPHY,
  -- Used to test internet address functions:
  -- INET6_ATON, INET6_NTOA, INET_ATON, INET_NTOA
  IPV4    VARCHAR(15),
  IPV6    VARCHAR(60),
  VBIPV4  VARBINARY(4),
  VBIPV6  VARBINARY(16)       NOT NULL,
  PRIMARY KEY (VCHAR, ID)
);
CREATE       UNIQUE INDEX IDX_R5_IV  ON R5 (ID, VCHAR)                WHERE ID >= 0;
CREATE ASSUMEUNIQUE INDEX IDX_R5_VSI ON R5 (VCHAR_INLINE, SMALL, INT) WHERE VCHAR_INLINE_MAX < 'a';
CREATE              INDEX IDX_R5_IVI ON R5 (INT, VCHAR_INLINE_MAX)    WHERE INT >= 0 AND VCHAR_INLINE IS NOT NULL;

CREATE TABLE P5 (
  ID      INTEGER  NOT NULL,
  TINY    TINYINT  NOT NULL,
  SMALL   SMALLINT NOT NULL,
  INT     INTEGER  NOT NULL,
  BIG     BIGINT   NOT NULL,
  NUM     FLOAT    NOT NULL,
  DEC     DECIMAL  NOT NULL,
  VCHAR_INLINE      VARCHAR(42 BYTES)   NOT NULL,
  VCHAR_INLINE_MAX  VARCHAR(15)         NOT NULL,
  VCHAR_OUTLINE_MIN VARCHAR(16)         NOT NULL,
  VCHAR             VARCHAR             NOT NULL,
  VCHAR_JSON        VARCHAR(4000 BYTES) NOT NULL,
  TIME    TIMESTAMP       NOT NULL,
  VARBIN  VARBINARY(100)  NOT NULL,
  POINT   GEOGRAPHY_POINT NOT NULL,
  POLYGON GEOGRAPHY,
  -- Used to test internet address functions:
  -- INET6_ATON, INET6_NTOA, INET_ATON, INET_NTOA
  IPV4    VARCHAR(15),
  IPV6    VARCHAR(60),
  VBIPV4  VARBINARY(4),
  VBIPV6  VARBINARY(16)       NOT NULL,
  PRIMARY KEY (VCHAR, ID)
);
PARTITION TABLE P5 ON COLUMN ID;
CREATE       UNIQUE INDEX IDX_P5_IV  ON P5 (ID, VCHAR)                WHERE ID >= 0;
CREATE ASSUMEUNIQUE INDEX IDX_P5_VSI ON P5 (VCHAR_INLINE, SMALL, INT) WHERE VCHAR_INLINE_MAX < 'a';
CREATE              INDEX IDX_P5_IVI ON P5 (INT, VCHAR_INLINE_MAX)    WHERE INT >= 0 AND VCHAR_INLINE IS NOT NULL;

CREATE TABLE R6 (
  ID      INTEGER  DEFAULT 0 NOT NULL,
  TINY    TINYINT  DEFAULT 0 NOT NULL,
  SMALL   SMALLINT DEFAULT 0 NOT NULL,
  INT     INTEGER  DEFAULT 0 NOT NULL,
  BIG     BIGINT   DEFAULT 0 NOT NULL,
  NUM     FLOAT    DEFAULT 0 NOT NULL,
  DEC     DECIMAL  DEFAULT 0 NOT NULL,
  VCHAR_INLINE      VARCHAR(14)       DEFAULT '0' NOT NULL,
  VCHAR_INLINE_MAX  VARCHAR(63 BYTES) DEFAULT '0' NOT NULL,
  VCHAR_OUTLINE_MIN VARCHAR(64 BYTES) DEFAULT '0' NOT NULL,
  VCHAR             VARCHAR           DEFAULT '0' NOT NULL,
  VCHAR_JSON        VARCHAR(1000)     DEFAULT '0' NOT NULL,
  TIME    TIMESTAMP       DEFAULT '2013-10-30 23:22:29' NOT NULL,
  VARBIN  VARBINARY(100)  DEFAULT x'00' NOT NULL,
  -- Default values of GEOGRAPHY_POINT and GEOGRAPHY not supported (ENG-12028)
  POINT   GEOGRAPHY_POINT,
  POLYGON GEOGRAPHY,
  -- Used to test internet address functions:
  -- INET6_ATON, INET6_NTOA, INET_ATON, INET_NTOA
  IPV4    VARCHAR(15),
  IPV6    VARCHAR(60),
  VBIPV4  VARBINARY(4),
  VBIPV6  VARBINARY(16),
  PRIMARY KEY (VARBIN)
  -- Will not work with SqlCoverage/PostgreSQL:
  , LIMIT PARTITION ROWS 5
);

CREATE TABLE P6 (
  ID      INTEGER  DEFAULT 0 NOT NULL,
  TINY    TINYINT  DEFAULT 0 NOT NULL,
  SMALL   SMALLINT DEFAULT 0 NOT NULL,
  INT     INTEGER  DEFAULT 0 NOT NULL,
  BIG     BIGINT   DEFAULT 0 NOT NULL,
  NUM     FLOAT    DEFAULT 0 NOT NULL,
  DEC     DECIMAL  DEFAULT 0 NOT NULL,
  VCHAR_INLINE      VARCHAR(14)       DEFAULT '0' NOT NULL,
  VCHAR_INLINE_MAX  VARCHAR(63 BYTES) DEFAULT '0' NOT NULL,
  VCHAR_OUTLINE_MIN VARCHAR(64 BYTES) DEFAULT '0' NOT NULL,
  VCHAR             VARCHAR           DEFAULT '0' NOT NULL,
  VCHAR_JSON        VARCHAR(1000)     DEFAULT '0' NOT NULL,
  TIME    TIMESTAMP       DEFAULT '2013-10-30 23:22:29' NOT NULL,
  VARBIN  VARBINARY(100)  DEFAULT x'00' NOT NULL,
  -- Default values of GEOGRAPHY_POINT and GEOGRAPHY not supported (ENG-12028)
  POINT   GEOGRAPHY_POINT,
  POLYGON GEOGRAPHY,
  -- Used to test internet address functions:
  -- INET6_ATON, INET6_NTOA, INET_ATON, INET_NTOA
  IPV4    VARCHAR(15),
  IPV6    VARCHAR(60),
  VBIPV4  VARBINARY(4),
  VBIPV6  VARBINARY(16),
  PRIMARY KEY (VARBIN)
  -- Will not work with SqlCoverage/PostgreSQL:
  , LIMIT PARTITION ROWS 5
);
PARTITION TABLE P6 ON COLUMN VARBIN;

CREATE TABLE R7 (
  ID      INTEGER  UNIQUE,
  TINY    TINYINT  UNIQUE,
  SMALL   SMALLINT UNIQUE,
  INT     INTEGER  UNIQUE,
  BIG     BIGINT   UNIQUE,
  NUM     FLOAT    UNIQUE,
  DEC     DECIMAL  UNIQUE,
  VCHAR_INLINE      VARCHAR(42 BYTES)   UNIQUE,
  VCHAR_INLINE_MAX  VARCHAR(15)         UNIQUE,
  VCHAR_OUTLINE_MIN VARCHAR(16)         UNIQUE,
  VCHAR             VARCHAR             UNIQUE,
  VCHAR_JSON        VARCHAR(4000 BYTES) UNIQUE,
  TIME    TIMESTAMP       UNIQUE,
  VARBIN  VARBINARY(100)  UNIQUE,
  POINT   GEOGRAPHY_POINT,
  POLYGON GEOGRAPHY,
  -- Used to test internet address functions:
  -- INET6_ATON, INET6_NTOA, INET_ATON, INET_NTOA
  IPV4    VARCHAR(15),
  IPV6    VARCHAR(60),
  VBIPV4  VARBINARY(4),
  VBIPV6  VARBINARY(16),
  PRIMARY KEY (ID, VCHAR, VARBIN)
  -- Will not work with SqlCoverage/PostgreSQL:
  , LIMIT PARTITION ROWS 6 EXECUTE
      (DELETE FROM R7 ORDER BY ID, VCHAR, VARBIN LIMIT 3)
);

CREATE TABLE P7 (
  ID      INTEGER  ASSUMEUNIQUE,
  TINY    TINYINT  ASSUMEUNIQUE,
  SMALL   SMALLINT ASSUMEUNIQUE,
  INT     INTEGER  ASSUMEUNIQUE,
  BIG     BIGINT   ASSUMEUNIQUE,
  NUM     FLOAT    ASSUMEUNIQUE,
  DEC     DECIMAL  ASSUMEUNIQUE,
  VCHAR_INLINE      VARCHAR(42 BYTES)   ASSUMEUNIQUE,
  VCHAR_INLINE_MAX  VARCHAR(15)         ASSUMEUNIQUE,
  VCHAR_OUTLINE_MIN VARCHAR(16)         ASSUMEUNIQUE,
  VCHAR             VARCHAR             ASSUMEUNIQUE,
  VCHAR_JSON        VARCHAR(4000 BYTES) ASSUMEUNIQUE,
  TIME    TIMESTAMP       ASSUMEUNIQUE,
  VARBIN  VARBINARY(100)  NOT NULL UNIQUE,
  POINT   GEOGRAPHY_POINT,
  POLYGON GEOGRAPHY,
  -- Used to test internet address functions:
  -- INET6_ATON, INET6_NTOA, INET_ATON, INET_NTOA
  IPV4    VARCHAR(15),
  IPV6    VARCHAR(60),
  VBIPV4  VARBINARY(4),
  VBIPV6  VARBINARY(16),
  PRIMARY KEY (ID, VCHAR, VARBIN)
  -- Will not work with SqlCoverage/PostgreSQL:
  , LIMIT PARTITION ROWS 6 EXECUTE
      (DELETE FROM P7 ORDER BY ID, VCHAR, VARBIN LIMIT 3)
);
PARTITION TABLE P7 ON COLUMN VARBIN;

-- The following pairs of tables are identical (and do not have views),
-- so that they can be used to test @SwapTables; e.g., R11 & R12 are
-- identical (also to R1 above, except that has a view defined on it);
-- P11 & P12 are identical (& P1, except its view), etc.

CREATE TABLE R11 (
  ID      INTEGER NOT NULL PRIMARY KEY,
  TINY    TINYINT,
  SMALL   SMALLINT,
  INT     INTEGER,
  BIG     BIGINT,
  NUM     FLOAT,
  DEC     DECIMAL,
  VCHAR_INLINE      VARCHAR(42 BYTES),
  VCHAR_INLINE_MAX  VARCHAR(15),
  VCHAR_OUTLINE_MIN VARCHAR(16),
  VCHAR             VARCHAR,
  VCHAR_JSON        VARCHAR(4000 BYTES),
  TIME    TIMESTAMP,
  VARBIN  VARBINARY(100),
  POINT   GEOGRAPHY_POINT,
  POLYGON GEOGRAPHY,
  -- Used to test internet address functions:
  -- INET6_ATON, INET6_NTOA, INET_ATON, INET_NTOA
  IPV4    VARCHAR(15),
  IPV6    VARCHAR(60),
  VBIPV4  VARBINARY(4),
  VBIPV6  VARBINARY(16)
);

CREATE TABLE R12 (
  ID      INTEGER NOT NULL PRIMARY KEY,
  TINY    TINYINT,
  SMALL   SMALLINT,
  INT     INTEGER,
  BIG     BIGINT,
  NUM     FLOAT,
  DEC     DECIMAL,
  VCHAR_INLINE      VARCHAR(42 BYTES),
  VCHAR_INLINE_MAX  VARCHAR(15),
  VCHAR_OUTLINE_MIN VARCHAR(16),
  VCHAR             VARCHAR,
  VCHAR_JSON        VARCHAR(4000 BYTES),
  TIME    TIMESTAMP,
  VARBIN  VARBINARY(100),
  POINT   GEOGRAPHY_POINT,
  POLYGON GEOGRAPHY,
  -- Used to test internet address functions:
  -- INET6_ATON, INET6_NTOA, INET_ATON, INET_NTOA
  IPV4    VARCHAR(15),
  IPV6    VARCHAR(60),
  VBIPV4  VARBINARY(4),
  VBIPV6  VARBINARY(16)
);

CREATE TABLE P11 (
  ID      INTEGER NOT NULL PRIMARY KEY,
  TINY    TINYINT,
  SMALL   SMALLINT,
  INT     INTEGER,
  BIG     BIGINT,
  NUM     FLOAT,
  DEC     DECIMAL,
  VCHAR_INLINE      VARCHAR(42 BYTES),
  VCHAR_INLINE_MAX  VARCHAR(15),
  VCHAR_OUTLINE_MIN VARCHAR(16),
  VCHAR             VARCHAR,
  VCHAR_JSON        VARCHAR(4000 BYTES),
  TIME    TIMESTAMP,
  VARBIN  VARBINARY(100),
  POINT   GEOGRAPHY_POINT,
  POLYGON GEOGRAPHY,
  -- Used to test internet address functions:
  -- INET6_ATON, INET6_NTOA, INET_ATON, INET_NTOA
  IPV4    VARCHAR(15),
  IPV6    VARCHAR(60),
  VBIPV4  VARBINARY(4),
  VBIPV6  VARBINARY(16)
);
PARTITION TABLE P11 ON COLUMN ID;

CREATE TABLE P12 (
  ID      INTEGER NOT NULL PRIMARY KEY,
  TINY    TINYINT,
  SMALL   SMALLINT,
  INT     INTEGER,
  BIG     BIGINT,
  NUM     FLOAT,
  DEC     DECIMAL,
  VCHAR_INLINE      VARCHAR(42 BYTES),
  VCHAR_INLINE_MAX  VARCHAR(15),
  VCHAR_OUTLINE_MIN VARCHAR(16),
  VCHAR             VARCHAR,
  VCHAR_JSON        VARCHAR(4000 BYTES),
  TIME    TIMESTAMP,
  VARBIN  VARBINARY(100),
  POINT   GEOGRAPHY_POINT,
  POLYGON GEOGRAPHY,
  -- Used to test internet address functions:
  -- INET6_ATON, INET6_NTOA, INET_ATON, INET_NTOA
  IPV4    VARCHAR(15),
  IPV6    VARCHAR(60),
  VBIPV4  VARBINARY(4),
  VBIPV6  VARBINARY(16)
);
PARTITION TABLE P12 ON COLUMN ID;

CREATE TABLE R21 (
  ID      INTEGER NOT NULL,
  TINY    TINYINT,
  SMALL   SMALLINT,
  INT     INTEGER,
  BIG     BIGINT,
  NUM     FLOAT,
  DEC     DECIMAL,
  VCHAR_INLINE      VARCHAR(14),
  VCHAR_INLINE_MAX  VARCHAR(63 BYTES),
  VCHAR_OUTLINE_MIN VARCHAR(64 BYTES),
  VCHAR             VARCHAR,
  VCHAR_JSON        VARCHAR(1000),
  TIME    TIMESTAMP,
  VARBIN  VARBINARY(100),
  POINT   GEOGRAPHY_POINT,
  POLYGON GEOGRAPHY,
  -- Used to test internet address functions:
  -- INET6_ATON, INET6_NTOA, INET_ATON, INET_NTOA
  IPV4    VARCHAR(15),
  IPV6    VARCHAR(60),
  VBIPV4  VARBINARY(4),
  VBIPV6  VARBINARY(16),
  PRIMARY KEY (ID)
);
CREATE INDEX IDX_R21_TINY ON R21 (TINY);
CREATE INDEX IDX_R21_BIG  ON R21 (BIG);
CREATE INDEX IDX_R21_DEC  ON R21 (DEC);
CREATE INDEX IDX_R21_VIM  ON R21 (VCHAR_INLINE_MAX);
CREATE INDEX IDX_R21_TIME ON R21 (TIME);
CREATE INDEX IDX_R21_VBIN ON R21 (VARBIN);
CREATE INDEX IDX_R21_POLY ON R21 (POLYGON);

CREATE TABLE R22 (
  ID      INTEGER NOT NULL,
  TINY    TINYINT,
  SMALL   SMALLINT,
  INT     INTEGER,
  BIG     BIGINT,
  NUM     FLOAT,
  DEC     DECIMAL,
  VCHAR_INLINE      VARCHAR(14),
  VCHAR_INLINE_MAX  VARCHAR(63 BYTES),
  VCHAR_OUTLINE_MIN VARCHAR(64 BYTES),
  VCHAR             VARCHAR,
  VCHAR_JSON        VARCHAR(1000),
  TIME    TIMESTAMP,
  VARBIN  VARBINARY(100),
  POINT   GEOGRAPHY_POINT,
  POLYGON GEOGRAPHY,
  -- Used to test internet address functions:
  -- INET6_ATON, INET6_NTOA, INET_ATON, INET_NTOA
  IPV4    VARCHAR(15),
  IPV6    VARCHAR(60),
  VBIPV4  VARBINARY(4),
  VBIPV6  VARBINARY(16),
  PRIMARY KEY (ID)
);
CREATE INDEX IDX_R22_TINY ON R22 (TINY);
CREATE INDEX IDX_R22_BIG  ON R22 (BIG);
CREATE INDEX IDX_R22_DEC  ON R22 (DEC);
CREATE INDEX IDX_R22_VIM  ON R22 (VCHAR_INLINE_MAX);
CREATE INDEX IDX_R22_TIME ON R22 (TIME);
CREATE INDEX IDX_R22_VBIN ON R22 (VARBIN);
CREATE INDEX IDX_R22_POLY ON R22 (POLYGON);

CREATE TABLE P21 (
  ID      INTEGER NOT NULL,
  TINY    TINYINT,
  SMALL   SMALLINT,
  INT     INTEGER,
  BIG     BIGINT,
  NUM     FLOAT,
  DEC     DECIMAL,
  VCHAR_INLINE      VARCHAR(14),
  VCHAR_INLINE_MAX  VARCHAR(63 BYTES),
  VCHAR_OUTLINE_MIN VARCHAR(64 BYTES),
  VCHAR             VARCHAR,
  VCHAR_JSON        VARCHAR(1000),
  TIME    TIMESTAMP,
  VARBIN  VARBINARY(100),
  POINT   GEOGRAPHY_POINT,
  POLYGON GEOGRAPHY,
  -- Used to test internet address functions:
  -- INET6_ATON, INET6_NTOA, INET_ATON, INET_NTOA
  IPV4    VARCHAR(15),
  IPV6    VARCHAR(60),
  VBIPV4  VARBINARY(4),
  VBIPV6  VARBINARY(16),
  PRIMARY KEY (ID)
);
PARTITION TABLE P21 ON COLUMN ID;
CREATE INDEX IDX_P21_TINY ON P21 (TINY);
CREATE INDEX IDX_P21_BIG  ON P21 (BIG);
CREATE INDEX IDX_P21_DEC  ON P21 (DEC);
CREATE INDEX IDX_P21_VIM  ON P21 (VCHAR_INLINE_MAX);
CREATE INDEX IDX_P21_TIME ON P21 (TIME);
CREATE INDEX IDX_P21_VBIN ON P21 (VARBIN);
CREATE INDEX IDX_P21_POLY ON P21 (POLYGON);

CREATE TABLE P22 (
  ID      INTEGER NOT NULL,
  TINY    TINYINT,
  SMALL   SMALLINT,
  INT     INTEGER,
  BIG     BIGINT,
  NUM     FLOAT,
  DEC     DECIMAL,
  VCHAR_INLINE      VARCHAR(14),
  VCHAR_INLINE_MAX  VARCHAR(63 BYTES),
  VCHAR_OUTLINE_MIN VARCHAR(64 BYTES),
  VCHAR             VARCHAR,
  VCHAR_JSON        VARCHAR(1000),
  TIME    TIMESTAMP,
  VARBIN  VARBINARY(100),
  POINT   GEOGRAPHY_POINT,
  POLYGON GEOGRAPHY,
  -- Used to test internet address functions:
  -- INET6_ATON, INET6_NTOA, INET_ATON, INET_NTOA
  IPV4    VARCHAR(15),
  IPV6    VARCHAR(60),
  VBIPV4  VARBINARY(4),
  VBIPV6  VARBINARY(16),
  PRIMARY KEY (ID)
);
PARTITION TABLE P22 ON COLUMN ID;
CREATE INDEX IDX_P22_TINY ON P22 (TINY);
CREATE INDEX IDX_P22_BIG  ON P22 (BIG);
CREATE INDEX IDX_P22_DEC  ON P22 (DEC);
CREATE INDEX IDX_P22_VIM  ON P22 (VCHAR_INLINE_MAX);
CREATE INDEX IDX_P22_TIME ON P22 (TIME);
CREATE INDEX IDX_P22_VBIN ON P22 (VARBIN);
CREATE INDEX IDX_P22_POLY ON P22 (POLYGON);

END_OF_BATCH_3
file -inlinebatch END_OF_BATCH_4

-- The following are views defined on most of the above tables
-- (but not the ones used for testing @SwapTables)

CREATE VIEW VR1 (TINY,
    ID, SMALL, INT, BIG, NUM, DEC,
    VCHAR_INLINE, VCHAR_INLINE_MAX, VCHAR_OUTLINE_MIN, VCHAR, VCHAR_JSON, TIME
    -- Will not work with SqlCoverage/PostgreSQL:
    , VARBIN, POINT, POLYGON
    , IPV4, IPV6, VBIPV4, VBIPV6
    ) AS
  SELECT TINY,
    COUNT(*), SUM(SMALL), COUNT(INT), MIN(BIG), MAX(NUM), SUM(DEC),
    MIN(VCHAR_INLINE), MIN(VCHAR_INLINE_MAX), MIN(VCHAR_OUTLINE_MIN), MIN(VCHAR), MIN(VCHAR_JSON), MIN(TIME)
    -- Will not work with SqlCoverage/PostgreSQL:
    , MIN(VARBIN), MIN(POINT), MIN(POLYGON)
    , MIN(IPV4), MIN(IPV6), MIN(VBIPV4), MIN(VBIPV6)
  FROM R1
GROUP BY TINY;

CREATE VIEW VP1 (TINY,
    ID, SMALL, INT, BIG, NUM, DEC,
    VCHAR_INLINE, VCHAR_INLINE_MAX, VCHAR_OUTLINE_MIN, VCHAR, VCHAR_JSON, TIME
    -- Will not work with SqlCoverage/PostgreSQL:
    , VARBIN, POINT, POLYGON
    , IPV4, IPV6, VBIPV4, VBIPV6
    ) AS
  SELECT TINY,
    COUNT(*), SUM(SMALL), COUNT(INT), MIN(BIG), MAX(NUM), SUM(DEC),
    MIN(VCHAR_INLINE), MIN(VCHAR_INLINE_MAX), MIN(VCHAR_OUTLINE_MIN), MIN(VCHAR), MIN(VCHAR_JSON), MIN(TIME)
    -- Will not work with SqlCoverage/PostgreSQL:
    , MIN(VARBIN), MIN(POINT), MIN(POLYGON)
    , MIN(IPV4), MIN(IPV6), MIN(VBIPV4), MIN(VBIPV6)
  FROM P1
GROUP BY TINY;


CREATE VIEW VR2 (TINY,
    ID, SMALL, INT, BIG, NUM, DEC,
    VCHAR_INLINE, VCHAR_INLINE_MAX, VCHAR_OUTLINE_MIN, VCHAR, VCHAR_JSON, TIME
    -- Will not work with SqlCoverage/PostgreSQL:
    , VARBIN, POINT, POLYGON
    , IPV4, IPV6, VBIPV4, VBIPV6
    ) AS
  SELECT TINY,
    COUNT(*), COUNT(SMALL), MIN(INT), MAX(BIG), SUM(NUM), MIN(DEC),
    MAX(VCHAR_INLINE), MAX(VCHAR_INLINE_MAX), MAX(VCHAR_OUTLINE_MIN), MAX(VCHAR), MAX(VCHAR_JSON), MAX(TIME)
    -- Will not work with SqlCoverage/PostgreSQL:
    , MAX(VARBIN), MAX(POINT), MAX(POLYGON)
    , MAX(IPV4), MAX(IPV6), MAX(VBIPV4), MAX(VBIPV6)
  FROM R2 WHERE ABS(TINY) < 64
GROUP BY TINY;

CREATE VIEW VP2 (TINY,
    ID, SMALL, INT, BIG, NUM, DEC,
    VCHAR_INLINE, VCHAR_INLINE_MAX, VCHAR_OUTLINE_MIN, VCHAR, VCHAR_JSON,TIME
    -- Will not work with SqlCoverage/PostgreSQL:
    , VARBIN, POINT, POLYGON
    , IPV4, IPV6, VBIPV4, VBIPV6
    ) AS
  SELECT TINY,
    COUNT(*), COUNT(SMALL), MIN(INT), MAX(BIG), SUM(NUM), MIN(DEC),
    MAX(VCHAR_INLINE), MAX(VCHAR_INLINE_MAX), MAX(VCHAR_OUTLINE_MIN), MAX(VCHAR), MAX(VCHAR_JSON), MAX(TIME)
    -- Will not work with SqlCoverage/PostgreSQL:
    , MAX(VARBIN), MAX(POINT), MAX(POLYGON)
    , MAX(IPV4), MAX(IPV6), MAX(VBIPV4), MAX(VBIPV6)
  FROM P2 WHERE ABS(TINY) < 64
GROUP BY TINY;


CREATE VIEW VR3 (VCHAR_INLINE_MAX,
    ID, TINY, SMALL, INT, BIG, NUM, DEC,
    VCHAR_INLINE, VCHAR_OUTLINE_MIN, VCHAR, VCHAR_JSON, TIME
    -- Will not work with SqlCoverage/PostgreSQL:
    , VARBIN, POINT, POLYGON
    , IPV4, IPV6, VBIPV4, VBIPV6
    ) AS
  SELECT VCHAR_INLINE_MAX,
    COUNT(*), COUNT(TINY), MIN(SMALL), MAX(INT), SUM(BIG), MIN(NUM), MAX(DEC),
    MIN(VCHAR_INLINE), MAX(VCHAR_OUTLINE_MIN), MIN(VCHAR), MAX(VCHAR_JSON), MIN(TIME)
    -- Will not work with SqlCoverage/PostgreSQL:
    , MAX(VARBIN), MIN(POINT), MAX(POLYGON)
    , MIN(IPV4), MAX(IPV6), MIN(VBIPV4), MAX(VBIPV6)
  FROM R3
GROUP BY VCHAR_INLINE_MAX;

CREATE VIEW VP3 (VCHAR_INLINE_MAX,
    ID, TINY, SMALL, INT, BIG, NUM, DEC,
    VCHAR_INLINE, VCHAR_OUTLINE_MIN, VCHAR, VCHAR_JSON, TIME
    -- Will not work with SqlCoverage/PostgreSQL:
    , VARBIN, POINT, POLYGON
    , IPV4, IPV6, VBIPV4, VBIPV6
    ) AS
  SELECT VCHAR_INLINE_MAX,
    COUNT(*), COUNT(TINY), MIN(SMALL), MAX(INT), SUM(BIG), MIN(NUM), MAX(DEC),
    MIN(VCHAR_INLINE), MAX(VCHAR_OUTLINE_MIN), MIN(VCHAR), MAX(VCHAR_JSON), MIN(TIME)
    -- Will not work with SqlCoverage/PostgreSQL:
    , MAX(VARBIN), MIN(POINT), MAX(POLYGON)
    , MIN(IPV4), MAX(IPV6), MIN(VBIPV4), MAX(VBIPV6)
  FROM P3
GROUP BY VCHAR_INLINE_MAX;


CREATE VIEW VR4 (VCHAR, BIG,
    ID, TINY, SMALL, INT, NUM, DEC,
    VCHAR_INLINE, VCHAR_INLINE_MAX, VCHAR_OUTLINE_MIN, VCHAR_JSON, TIME
    -- Will not work with SqlCoverage/PostgreSQL:
    , VARBIN, POINT, POLYGON
    , IPV4, IPV6, VBIPV4, VBIPV6
    ) AS
  SELECT VCHAR, BIG,
    COUNT(*), SUM(TINY), MAX(SMALL), COUNT(VCHAR_INLINE_MAX), MAX(NUM), MIN(DEC),
    MAX(VCHAR_INLINE), MIN(VCHAR_INLINE_MAX), MAX(VCHAR_OUTLINE_MIN), MIN(VCHAR_JSON), MAX(TIME)
    -- Will not work with SqlCoverage/PostgreSQL:
    , MIN(VARBIN), MAX(POINT), MIN(POLYGON)
    , MAX(IPV4), MIN(IPV6), MAX(VBIPV4), MIN(VBIPV6)
  FROM R4 WHERE VCHAR_INLINE < 'N'
GROUP BY VCHAR, BIG;
CREATE INDEX IDX_VR4_VB  ON VR4 (VCHAR, BIG)             WHERE BIG >= 0;
CREATE INDEX IDX_VR4_IDV ON VR4 (INT, DEC, VCHAR_INLINE) WHERE VCHAR_INLINE < 'a';
CREATE INDEX IDX_VR4_VMB ON VR4 (VCHAR_INLINE_MAX, BIG)  WHERE BIG >= 0 AND VCHAR_INLINE_MAX IS NOT NULL;

CREATE VIEW VP4 (VCHAR, BIG,
    ID, TINY, SMALL, INT, NUM, DEC,
    VCHAR_INLINE, VCHAR_INLINE_MAX, VCHAR_OUTLINE_MIN, VCHAR_JSON, TIME
    -- Will not work with SqlCoverage/PostgreSQL:
    , VARBIN, POINT, POLYGON
    , IPV4, IPV6, VBIPV4, VBIPV6
    ) AS
  SELECT VCHAR, BIG,
    COUNT(*), SUM(TINY), MAX(SMALL), COUNT(VCHAR_INLINE_MAX), MAX(NUM), MIN(DEC),
    MAX(VCHAR_INLINE), MIN(VCHAR_INLINE_MAX), MAX(VCHAR_OUTLINE_MIN), MIN(VCHAR_JSON), MAX(TIME)
    -- Will not work with SqlCoverage/PostgreSQL:
    , MIN(VARBIN), MAX(POINT), MIN(POLYGON)
    , MAX(IPV4), MIN(IPV6), MAX(VBIPV4), MIN(VBIPV6)
  FROM P4 WHERE VCHAR_INLINE < 'N'
GROUP BY VCHAR, BIG;
CREATE INDEX IDX_VP4_VB  ON VP4 (VCHAR, BIG)             WHERE BIG >= 0;
CREATE INDEX IDX_VP4_IDV ON VP4 (INT, DEC, VCHAR_INLINE) WHERE VCHAR_INLINE < 'a';
CREATE INDEX IDX_VP4_VMB ON VP4 (VCHAR_INLINE_MAX, BIG)  WHERE BIG >= 0 AND VCHAR_INLINE_MAX IS NOT NULL;


CREATE VIEW VR5 (SMALL, VCHAR, TINY,
    ID, INT, BIG, NUM, DEC,
    VCHAR_INLINE, VCHAR_INLINE_MAX, VCHAR_OUTLINE_MIN, VCHAR_JSON, TIME
    -- Will not work with SqlCoverage/PostgreSQL:
    , VARBIN, POINT, POLYGON
    , IPV4, IPV6, VBIPV4, VBIPV6
    ) AS
  SELECT SMALL, VCHAR, TINY,
    COUNT(*), COUNT(TIME), COUNT(POINT), SUM(NUM), SUM(DEC),
    MIN(VCHAR_INLINE), MAX(VCHAR_INLINE_MAX), MIN(VCHAR_OUTLINE_MIN), MAX(VCHAR_JSON), MIN(TIME)
    -- Will not work with SqlCoverage/PostgreSQL:
    , MAX(VARBIN), MIN(POINT), MAX(POLYGON)
    , MIN(IPV4), MAX(IPV6), MIN(VBIPV4), MAX(VBIPV6)
  FROM R5 WHERE TINY < 64
GROUP BY SMALL, VCHAR, TINY;
CREATE INDEX IDX_VR5_SVT ON VR5 (SMALL, VCHAR, TINY)      WHERE SMALL >= 0;
CREATE INDEX IDX_VR5_VID ON VR5 (VCHAR_INLINE, INT, DEC)  WHERE VCHAR_INLINE < 'a';
CREATE INDEX IDX_VR5_VS  ON VR5 (VCHAR_INLINE_MAX, SMALL) WHERE SMALL >= 0 AND VCHAR_INLINE_MAX IS NOT NULL;

CREATE VIEW VP5 (SMALL, VCHAR, TINY,
    ID, INT, BIG, NUM, DEC,
    VCHAR_INLINE, VCHAR_INLINE_MAX, VCHAR_OUTLINE_MIN, VCHAR_JSON, TIME
    -- Will not work with SqlCoverage/PostgreSQL:
    , VARBIN, POINT, POLYGON
    , IPV4, IPV6, VBIPV4, VBIPV6
    ) AS
  SELECT SMALL, VCHAR, TINY,
    COUNT(*), COUNT(VARBIN), COUNT(POLYGON), SUM(NUM), SUM(DEC),
    MIN(VCHAR_INLINE), MAX(VCHAR_INLINE_MAX), MIN(VCHAR_OUTLINE_MIN), MAX(VCHAR_JSON), MIN(TIME)
    -- Will not work with SqlCoverage/PostgreSQL:
    , MAX(VARBIN), MIN(POINT), MAX(POLYGON)
    , MIN(IPV4), MAX(IPV6), MIN(VBIPV4), MAX(VBIPV6)
  FROM P5 WHERE TINY < 64
GROUP BY SMALL, VCHAR, TINY;
CREATE INDEX IDX_VP5_SVT ON VP5 (SMALL, VCHAR, TINY)      WHERE SMALL >= 0;
CREATE INDEX IDX_VP5_VID ON VP5 (VCHAR_INLINE, INT, DEC)  WHERE VCHAR_INLINE < 'a';
CREATE INDEX IDX_VP5_VS  ON VP5 (VCHAR_INLINE_MAX, SMALL) WHERE SMALL >= 0 AND VCHAR_INLINE_MAX IS NOT NULL;

END_OF_BATCH_4
file -inlinebatch END_OF_BATCH_5

-- The following are SQL stored procedures defined on some of the above tables
-- Note: some of these stored procedures (namely the "insMin" & "insMax" ones)
-- that are defined for replicated tables are not supported for partitioned
-- tables, and are therefore omitted.
CREATE PROCEDURE SSPR0min    AS SELECT MIN(ID) FROM R0;
CREATE PROCEDURE SSPR0max    AS SELECT MAX(ID) FROM R0;
CREATE PROCEDURE SSPR0insMin AS INSERT INTO R0 VALUES ((SELECT MIN(ID)-1 FROM R0),
                                                       0, 0, 0, 0, 0, 0,
                                                       'abc', 'ABC', 'XYZ', 'xyz', '{jsonValue:0}',
                                                       null, null, null, null, null, null, null, null);
CREATE PROCEDURE SSPR0insMax AS INSERT INTO R0 VALUES ((SELECT MAX(ID)-1 FROM R0),
                                                       0, 0, 0, 0, 0, 0,
                                                       'abc', 'ABC', 'XYZ', 'xyz', '{jsonValue:0}',
                                                       null, null, null, null, null, null, null, null);
CREATE PROCEDURE SSPR0ins    AS INSERT INTO R0 VALUES (?,
                                                       0, 0, 0, 0, 0, 0,
                                                       'abc', 'ABC', 'XYZ', 'xyz', '{jsonValue:0}',
                                                       null, null, null, null, null, null, null, null);
CREATE PROCEDURE SSPR0sel    AS SELECT * FROM R0 WHERE ID = ?;
CREATE PROCEDURE SSPP0min    AS SELECT MIN(ID) FROM P0;
CREATE PROCEDURE SSPP0max    AS SELECT MAX(ID) FROM P0;
CREATE PROCEDURE SSPP0ins    AS INSERT INTO P0 VALUES (?,
                                                       0, 0, 0, 0, 0, 0,
                                                       'abc', 'ABC', 'XYZ', 'xyz', '{jsonValue:0}',
                                                       null, null, null, null, null, null, null, null);
CREATE PROCEDURE SSPP0sel    AS SELECT * FROM P0 WHERE ID = ?;

CREATE PROCEDURE SSPR1min    AS SELECT MIN(ID) FROM R1;
CREATE PROCEDURE SSPR1max    AS SELECT MAX(ID) FROM R1;
CREATE PROCEDURE SSPR1insMin AS INSERT INTO R1 VALUES ((SELECT MIN(ID)-1 FROM R1),
                                                       0, 0, 0, 0, 0, 0,
                                                       'abc', 'ABC', 'XYZ', 'xyz', '{jsonValue:0}',
                                                       null, null, null, null, null, null, null, null);
CREATE PROCEDURE SSPR1insMax AS INSERT INTO R1 VALUES ((SELECT MAX(ID)-1 FROM R1),
                                                       0, 0, 0, 0, 0, 0,
                                                       'abc', 'ABC', 'XYZ', 'xyz', '{jsonValue:0}',
                                                       null, null, null, null, null, null, null, null);
CREATE PROCEDURE SSPR1ins    AS INSERT INTO R1 VALUES (?,
                                                       0, 0, 0, 0, 0, 0,
                                                       'abc', 'ABC', 'XYZ', 'xyz', '{jsonValue:0}',
                                                       null, null, null, null, null, null, null, null);
CREATE PROCEDURE SSPR1sel    AS SELECT * FROM R1 WHERE ID = ?;
CREATE PROCEDURE SSPP1min    AS SELECT MIN(ID) FROM P1;
CREATE PROCEDURE SSPP1max    AS SELECT MAX(ID) FROM P1;
CREATE PROCEDURE SSPP1ins    AS INSERT INTO P1 VALUES (?,
                                                       0, 0, 0, 0, 0, 0,
                                                       'abc', 'ABC', 'XYZ', 'xyz', '{jsonValue:0}',
                                                       null, null, null, null, null, null, null, null);
CREATE PROCEDURE SSPP1sel    AS SELECT * FROM P1 WHERE ID = ?;

CREATE PROCEDURE SSPR2min    AS SELECT MIN(ID) FROM R2;
CREATE PROCEDURE SSPR2max    AS SELECT MAX(ID) FROM R2;
CREATE PROCEDURE SSPR2insMin AS INSERT INTO R2 VALUES ((SELECT MIN(ID)-1 FROM R2),
                                                       0, 0, 0, 0, 0, 0,
                                                       'abc', 'ABC', 'XYZ', 'xyz', '{jsonValue:0}',
                                                       null, null, null, null, null, null, null, null);
CREATE PROCEDURE SSPR2insMax AS INSERT INTO R2 VALUES ((SELECT MAX(ID)-1 FROM R2),
                                                       0, 0, 0, 0, 0, 0,
                                                       'abc', 'ABC', 'XYZ', 'xyz', '{jsonValue:0}',
                                                       null, null, null, null, null, null, null, null);
CREATE PROCEDURE SSPR2ins    AS INSERT INTO R2 VALUES (?,
                                                       0, 0, 0, 0, 0, 0,
                                                       'abc', 'ABC', 'XYZ', 'xyz', '{jsonValue:0}',
                                                       null, null, null, null, null, null, null, null);
CREATE PROCEDURE SSPR2sel    AS SELECT * FROM R2 WHERE ID = ?;
CREATE PROCEDURE SSPP2min    AS SELECT MIN(ID) FROM P2;
CREATE PROCEDURE SSPP2max    AS SELECT MAX(ID) FROM P2;
CREATE PROCEDURE SSPP2ins    AS INSERT INTO P2 VALUES (?,
                                                       0, 0, 0, 0, 0, 0,
                                                       'abc', 'ABC', 'XYZ', 'xyz', '{jsonValue:0}',
                                                       null, null, null, null, null, null, null, null);
CREATE PROCEDURE SSPP2sel    AS SELECT * FROM P2 WHERE ID = ?;

END_OF_BATCH_5

-- The following are Java stored procedures defined on some of the above tables
load classes testgrammar.jar;

file -inlinebatch END_OF_BATCH_6

CREATE PROCEDURE FROM CLASS sqlgrammartest.JSPR1min;
CREATE PROCEDURE FROM CLASS sqlgrammartest.JSPR1max;
CREATE PROCEDURE FROM CLASS sqlgrammartest.JSPR1insMin;
CREATE PROCEDURE FROM CLASS sqlgrammartest.JSPR1insMax;
CREATE PROCEDURE FROM CLASS sqlgrammartest.JSPR1ins;
CREATE PROCEDURE FROM CLASS sqlgrammartest.JSPR1sel;
CREATE PROCEDURE FROM CLASS sqlgrammartest.JSPP1min;
CREATE PROCEDURE FROM CLASS sqlgrammartest.JSPP1max;
CREATE PROCEDURE FROM CLASS sqlgrammartest.JSPP1insMin;
CREATE PROCEDURE FROM CLASS sqlgrammartest.JSPP1insMax;
CREATE PROCEDURE FROM CLASS sqlgrammartest.JSPP1ins;
CREATE PROCEDURE FROM CLASS sqlgrammartest.JSPP1sel;

END_OF_BATCH_6
