################################################################################
#
# This file defines the grammar for SQL statements of various types. The
# first section (Table names and Column names) is specific to the DDL table
# definitions that are used, along with this file, to test VoltDB; but most of
# the rest (with certain exceptions, like table and column aliases, and polygon
# values) is (intended to be) completely general, albeit it will need to be
# added to whenever new SQL functions or other features are added to VoltDB.
#
# The parser that interprets this file understands only a few simple rules:
#   1. The ::= symbol means "is defined as". Definitions are normally given on
#      a single line, but may be continued onto one or more additional lines
#      using a backslash (\) as a continuation character; the backslash must
#      be the last character on the line.
#   2. The {foo} syntax means to use symbol "foo", which is defined somewhere
#      in this file, using "::="; recursive definitions are allowed, though of
#      course a non-recursive option must also be available, to avoid infinite
#      recursion.
#   3. The | symbol means "or" (actually, XOR), with an equal probability of
#      each possible option being chosen, by default (but see #4 below). The |
#      must be preceded and followed by a space (otherwise the || concatenation
#      operator would be impossible without some sort of escape symbol, which
#      I did not want to get into).
#   4. Adding a (positive) integer before a | symbol makes the preceding option
#      more likely; the "n|" still needs to be preceded and followed by a space.
#      For example, in this definition:
#          definition :== foo 2| bar
#      the "foo" option is twice as likely as the "bar" option. You may use
#      more than one such integer; for example, in this definition:
#          definition :== foo 3| bar 2| null
#      the "foo" option will be chosen half (3/6) the time, the "bar" option
#      will be chosen a third (2/6) of the time, and the "null" option will
#      be chosen only 1 time in 6. Note that the last option always has an
#      implicit "likelihood weight" of 1, as do any options preceded simply with
#      a |. The actual probability of each option is its "likelihood weight"
#      divided by the sum of all the "likelihood weights" of all options.
#   5. Something in brackets, such as [foo], is optional, with a 50-50 chance
#      of being included; If you want to make something optional less likely,
#      add more brackets, e.g., [[foo]] has only a 25% chance of being included.
#   6. You cannot include | inside brackets, so [foo | bar] will not work
#      properly, though the reverse, e.g. [foo] | [bar] is fine; to achieve
#      the same effect as [foo | bar] use [{foo-or-bar}], with:
#          foo-or-bar :== foo | bar
#      See "all-or-distinct" for one example of this.
#   7. It is possible (despite what I said in #3 above) to escape an open ("[")
#      or close ("]") bracket symbol, by preceding it with a backslash, i.e.,
#      "\[" or "\]"; these escaped versions will be interpreted as literal
#      bracket symbols ("[" or "]"), rather than as containing optional text.
#
################################################################################

################################################################################
# Table, view, and stored procedure names pre-defined in the DDL associated with
# this test (and very occasionally, a nonexistent table name, view name, stored
# procedure name, or, below, column name is used)

# Table names broken down by the number and data type(s) of their primary key;
# this includes both Replicated and Partitioned Tables:
table-name-w-no-pk      ::= R0 | P0
table-name-w-pk-int     ::= R1 9| P1 9| R2 9| P2 9| R11 9| P11 9| R12 | P12 | R21 9| P21 9| R22 | P22
table-name-w-pk-str     ::= R3 | P3
table-name-w-pk-int-str ::= R4 | P4
table-name-w-pk-str-int ::= R5 | P5
table-name-w-pk-varbin  ::= R6 | P6
table-name-w-pk-i-s-v   ::= R7 | P7

# Only identical tables (including indexes) without views can be swapped;
# the swap of two generic {table-name} will usually not work, but should
# return a reasonable error message (commas and single quotes are optional)
swappable-tables        ::= R11[,] R12 | P11[,] P12 | R21[,] R22 | P21[,] P22 | \
                            R12[,] R11 | P12[,] P11 | R22[,] R21 | P22[,] P21 | \
                            'R11'[,] 'R12' | 'P11'[,] 'P12' | 'R21'[,] 'R22' | 'P21'[,] 'P22' | \
                            'R12'[,] 'R11' | 'P12'[,] 'P11' | 'R22'[,] 'R21' | 'P22'[,] 'P21' | \
                            'R11'[,] R12 | P11[,] 'P12' | R21[,] 'R22' | 'P21'[,] P22 | \
                            'R12'[,] R11 | P12[,] 'P11' | R22[,] 'R21' | 'P22'[,] P21 | \
                            {table-name}[,] {table-name} | '{table-name}'[,] '{table-name}'

legit-table-name        ::= {table-name-w-no-pk} | {table-name-w-pk-int} 4| {table-name-w-pk-str} | \
                            {table-name-w-pk-int-str} | {table-name-w-pk-str-int} | \
                            {table-name-w-pk-varbin}  | {table-name-w-pk-i-s-v}

legit-view-name         ::= VR1 | VP1 | VR2 | VP2 | VR3 | VP3 | VR4 | VP4 | VR5 | VP5

table-name              ::= {legit-table-name} 199| NONEXISTENT_TABLE
view-name               ::= {legit-view-name}  199| NONEXISTENT_VIEW
table-or-view-name      ::= {table-name} 3| {view-name}

# User-defined Stored Procedures: this includes both Java and SQL Stored
# Procedures; e.g., SSPR1min is a SQL Stored Procedure that returns the MIN ID
# from table R1, JSPP1insMax is a Java Stored Procedure that inserts a row with
# a new MAX ID (the old MAX(ID)+1) into table P1, etc.; "random" (SQL) Stored
# Procs are not predetermined in the DDL file, but rather created on the fly
user-proc-name          ::= {user-proc-0params} 2| {user-proc-1param}
java-proc-name          ::= {java-proc-0params} 2| {java-proc-1param}

# TODO: the "random" (SQL) Stored Procs are the most interesting, and therefore
# weighted the highest here; but we could potentially generate Java Stored Procs
# using randomly generated SQL statements (not an easy task), in which case we
# would want to reevaluate these weights (same comment potentially applies to
# user-proc-1param below)
user-proc-0params       ::= {random-proc-0params} 139| {sql-proc-0params} 40| \
                            {java-proc-0params}    20| NONEXISTENT_PROC
# TODO: could add more Java Stored Procs, for more tables (or random ones)
java-proc-0params       ::= JSPR1min | JSPR1max | JSPR1insMin | JSPR1insMax | \
                            JSPP1min | JSPP1max | JSPP1insMin | JSPP1insMax
sql-proc-0params        ::= SSPR0min | SSPR0max | SSPR0insMin | SSPR0insMax | \
                            SSPP0min | SSPP0max | SSPP0insMin | SSPP0insMax | \
                            SSPR1min | SSPR1max | SSPR1insMin | SSPR1insMax | \
                            SSPP1min | SSPP1max | SSPP1insMin | SSPP1insMax | \
                            SSPR2min | SSPR2max | SSPR2insMin | SSPR2insMax | \
                            SSPP2min | SSPP2max | SSPP2insMin | SSPP2insMax | \
                            SSPR3min | SSPR3max | SSPR3insMin | SSPR3insMax | \
                            SSPP3min | SSPP3max | SSPP3insMin | SSPP3insMax | \
                            SSPR4min | SSPR4max | SSPR4insMin | SSPR4insMax | \
                            SSPP4min | SSPP4max | SSPP4insMin | SSPP4insMax | \
                            SSPR5min | SSPR5max | SSPR5insMin | SSPR5insMax | \
                            SSPP5min | SSPP5max | SSPP5insMin | SSPP5insMax | \
                            SSPR6min | SSPR6max | SSPR6insMin | SSPR6insMax | \
                            SSPP6min | SSPP6max | SSPP6insMin | SSPP6insMax | \
                            SSPR7min | SSPR7max | SSPR7insMin | SSPR7insMax | \
                            SSPP7min | SSPP7max | SSPP7insMin | SSPP7insMax
random-proc-0params     ::= RPROC{digit-0-to-5}

# TODO: get "random" (SQL) Stored Procs with 1 parameter (or more?) working
user-proc-1param        ::= {random-proc-1param}  0| {sql-proc-1param} 133| \
                            {java-proc-1param}   66| NONEXISTENT_PROC
# TODO: could add more Java Stored Procs, for more tables
java-proc-1param        ::= JSPR1ins | JSPR1sel | JSPP1ins | JSPP1sel
sql-proc-1param         ::= SSPR0ins | SSPR0sel | SSPP0ins | SSPP0sel | \
                            SSPR1ins | SSPR1sel | SSPP1ins | SSPP1sel | \
                            SSPR2ins | SSPR2sel | SSPP2ins | SSPP2sel | \
                            SSPR3ins | SSPR3sel | SSPP3ins | SSPP3sel | \
                            SSPR4ins | SSPR4sel | SSPP4ins | SSPP4sel | \
                            SSPR5ins | SSPR5sel | SSPP5ins | SSPP5sel | \
                            SSPR6ins | SSPR6sel | SSPP6ins | SSPP6sel | \
                            SSPR7ins | SSPR7sel | SSPP7ins | SSPP7sel
# TODO: could define random (SQL) Stored Procs, that take 1 parameter (or more?)
random-proc-1param      ::= RPROC6 | RPROC7 | RPROC8 | RPROC9

# Column names used in the pre-defined DDL, of every possible data type ...
int-non-id-column-name  ::= TINY | SMALL | INT | BIG
int-column-name         ::= {int-non-id-column-name} 4| ID
byte-column-name        ::= TINY

# The "5" before the "|" makes the "int-column-name" option 5 times as likely
# as the other options, making each numeric column name equally likely
numeric-column-name     ::= {int-column-name}        5| NUM | DEC
numeric-non-id-col-name ::= {int-non-id-column-name} 4| NUM | DEC

string-column-name      ::= VCHAR_INLINE | VCHAR_INLINE_MAX | VCHAR | VCHAR_JSON
json-column-name        ::= VCHAR_JSON
timestamp-column-name   ::= TIME
varbinary-column-name   ::= VARBIN
point-column-name       ::= POINT
polygon-column-name     ::= POLYGON
geo-column-name         ::= {point-column-name} | {polygon-column-name}
non-int-str-column-name ::= {geo-column-name} 2| {timestamp-column-name} | {varbinary-column-name}

# PostgreSQL-compatible version of the above: avoids problems involving SELECT with Geospatial types
pg-point-column-name    ::= _variable\[point\]
pg-polygon-column-name  ::= _variable\[polygon\]

table-column-name       ::= {numeric-column-name} 2| {string-column-name} | {non-int-str-column-name}
view-column-name        ::= {table-column-name}
legit-column-name       ::= {table-column-name} 9| {view-column-name}
column-name             ::= {legit-column-name} 399| NONEXISTENT_COLUMN
column-list             ::= {column-name} [, {column-list}]

# These versions include the 'internet' columns (used with the INET... functions)
# which we don't normally want to set to invalid values (but selecting them is fine)
string-ipv4-column-name ::= IPV4
string-ipv6-column-name ::= IPV6
string-ipv-column-name  ::= {string-ipv4-column-name} | {string-ipv6-column-name}
varbin-ipv4-column-name ::= VBIPV4
varbin-ipv6-column-name ::= VBIPV6
varbin-ipv-column-name  ::= {varbin-ipv4-column-name} | {varbin-ipv6-column-name}
any-string-column-name  ::= {string-column-name} 2| {string-ipv-column-name}
any-varbin-column-name  ::= {varbinary-column-name} | {varbin-ipv-column-name}
any-table-column-name   ::= {table-column-name} 8| {string-ipv-column-name} | {varbin-ipv-column-name}
any-view-column-name    ::= {any-table-column-name}
any-legit-column-name   ::= {any-table-column-name} 9| {any-view-column-name}
any-column-name         ::= {any-legit-column-name} 399| NONEXISTENT_COLUMN

# These are obviously not the complete lists of all possible table and column
# aliases, but using a short list makes it more likely that when you refer to
# one it is one that was actually defined
table-alias             ::= T1 3| T2 2| T3
column-alias            ::= C1 3| C2 2| C3
table-alias-or-name     ::= {table-alias} 3| {table-or-view-name}

################################################################################
# Any (non-DDL) SQL statement:
# The "50" before the first "|" makes the "select-statement" option 50 times as
# likely as the least likely (last) option; so half of these SQL statements will
# be SELECT statements; but only 1% will be "delete-statement", since we don't
# want to delete all the rows in a table too often.
#
sql-statement           ::= {standard-sql-statement} 19| {special-sql-statement}

standard-sql-statement  ::= {select-statement} 50| {insert-statement} 18| {upsert-statement} 18| \
                            {update-statement}  8| {delete-statement}

################################################################################
# Grammar rules for an INSERT statement:
################################################################################
insert-statement        ::= {insert-values-statement} | {insert-select-statement}

# The "9" before the "|" makes the "simple-insert-values" or "ordered-values-list"
# option 9 times as likely as the other option, making simple, ordered, valid
# statements more likely
insert-values-statement ::= {simple-insert-values} 9| {insert-clause} VALUES ({values-list})
insert-select-statement ::= {simple-insert-select} 9| {insert-clause} {select-statement}
values-list             ::= {ordered-values-list}  9| {random-order-value-list}

# Putting "({column-list})" in more than one set of brackets makes it less likely
insert-clause           ::= INSERT INTO {table-name} [[({column-list})]]

ordered-values-list     ::= {integer-non-null-value}, {byte-value}, {integer-value}, {integer-value}, {integer-value}, \
                            {numeric-value}, {numeric-value}, {string-value}, {string-value}, {string-value}, \
                            {timestamp-value}, {varbinary-value}, {point-value}, {polygon-value}
random-order-value-list ::= {random-type-value} [, {random-order-value-list}]
random-type-value       ::= {integer-value}  4| {numeric-value} 2| {string-value} 4| {timestamp-value} | \
                            {varbinary-value} | {point-value}    | {polygon-value} | {scalar-sub-query}
simple-insert-values    ::= IN{in-or-up-sert-values}
simple-insert-select    ::= IN{in-or-up-sert-select}

in-or-up-sert-values    ::= {insert-values-multiple} 8| {insert-values-all}    22| {insert-values-backward} 22| \
                            {insert-values-id-num}   7| {insert-values-id-str}  4| {insert-values-id-time}    | \
                            {insert-values-id-varbin} | {insert-values-id-point} | {insert-values-id-poly}
in-or-up-sert-select    ::= {insert-select-multiple} 8| {insert-select-all}    22| {insert-select-backward} 22| \
                            {insert-select-id-num}   7| {insert-select-id-str}  4| {insert-select-id-time}    | \
                            {insert-select-id-varbin} | {insert-select-id-point} | {insert-select-id-poly}

# We leave the IN off of INSERT here, so these can also be used for UPSERT
insert-values-id-num    ::= SERT INTO {table-name} (ID, {numeric-non-id-col-name}) VALUES ({integer-non-null-value},  {numeric-value-or-subq})  | \
                            SERT INTO {table-name} ({numeric-non-id-col-name}, ID) VALUES ({numeric-value-or-subq},   {integer-non-null-value}) | \
                            SERT INTO {table-name} (ID, {int-non-id-column-name})  VALUES ({integer-non-null-value},  {integer-value-or-subq})  | \
                            SERT INTO {table-name} ({int-non-id-column-name}, ID)  VALUES ({integer-value-or-subq},   {integer-non-null-value})
insert-values-id-str    ::= SERT INTO {table-name} (ID, {string-column-name})      VALUES ({integer-non-null-value},  {string-value-or-subq}) | \
                            SERT INTO {table-name} ({string-column-name}, ID)      VALUES ({string-value-or-subq},    {integer-non-null-value})
insert-values-id-time   ::= SERT INTO {table-name} (ID, {timestamp-column-name})   VALUES ({integer-non-null-value},  {timestamp-value-or-subq}) | \
                            SERT INTO {table-name} ({timestamp-column-name}, ID)   VALUES ({timestamp-value-or-subq}, {integer-non-null-value})
insert-values-id-varbin ::= SERT INTO {table-name} (ID, {varbinary-column-name})   VALUES ({integer-non-null-value},  {varbinary-value-or-subq}) | \
                            SERT INTO {table-name} ({varbinary-column-name}, ID)   VALUES ({varbinary-value-or-subq}, {integer-non-null-value})
insert-values-id-point  ::= SERT INTO {table-name} (ID, {point-column-name})       VALUES ({integer-non-null-value},  {point-value-or-subq}) | \
                            SERT INTO {table-name} ({point-column-name}, ID)       VALUES ({point-value-or-subq},     {integer-non-null-value})
insert-values-id-poly   ::= SERT INTO {table-name} (ID, {polygon-column-name})     VALUES ({integer-non-null-value},  {polygon-value-or-subq}) | \
                            SERT INTO {table-name} ({polygon-column-name}, ID)     VALUES ({polygon-value-or-subq},   {integer-non-null-value})

numeric-value-or-subq   ::= {numeric-value}     9| {numeric-scalar-sub-q}
integer-value-or-subq   ::= {integer-value}     9| {integer-scalar-sub-q}
byte-value-or-subq      ::= {byte-value}        9| {integer-scalar-sub-q}
string-value-or-subq    ::= {string-value}      9| {string-scalar-sub-q}
json-value-or-subq      ::= {json-value}        9| {json-scalar-sub-q}
timestamp-value-or-subq ::= {timestamp-value}   9| {timestamp-scalar-sub-q}
varbinary-value-or-subq ::= {varbinary-value}   9| {varbinary-scalar-sub-q}
point-value-or-subq     ::= {point-value}       9| {point-scalar-sub-q}
polygon-value-or-subq   ::= {polygon-value}     9| {polygon-scalar-sub-q}
str-ipv4-value-or-subq  ::= {string-ipv4-value} 9| {str-ipv4-scalar-sub-q}
str-ipv6-value-or-subq  ::= {string-ipv6-value} 9| {str-ipv6-scalar-sub-q}
varb-ipv4-value-or-subq ::= {varbin-ipv4-value} 9| {varb-ipv4-scalar-sub-q}
varb-ipv6-value-or-subq ::= {varbin-ipv6-value} 9| {varb-ipv6-scalar-sub-q}

insert-values-multiple  ::= SERT INTO {table-name} ( ID, {numeric-non-id-col-name}, {string-column-name}, {timestamp-column-name}, \
                            {varbinary-column-name}, {point-column-name}, {polygon-column-name} ) VALUES ( {insert-values-mult-val} )
insert-values-all       ::= SERT INTO {table-name} [( \
                            ID, TINY, SMALL, INT, BIG, NUM, DEC, VCHAR_INLINE, VCHAR_INLINE_MAX, VCHAR, VCHAR_JSON, TIME, VARBIN, \
                            POINT, POLYGON, IPV4, IPV6, VBIPV4, VBIPV6)] VALUES ( {insert-values-all-val} )
insert-values-backward  ::= SERT INTO {table-name} ( \
                            VBIPV6, VBIPV4, IPV6, IPV4, POLYGON, POINT, VARBIN, TIME, VCHAR_JSON, VCHAR, VCHAR_INLINE_MAX, \
                            VCHAR_INLINE, DEC, NUM, BIG, INT, SMALL, TINY, ID ) VALUES ( {insert-values-back-val} )

insert-values-mult-val  ::= {insert-values-mult-val1} 4| {insert-values-mult-val2}
insert-values-mult-val1 ::= {integer-non-null-value}, {numeric-value}, {string-value}, {timestamp-value}, \
                            {varbinary-value}, {point-value}, {polygon-value}
insert-values-mult-val2 ::= {integer-non-null-value}, {numeric-value-or-subq}, {string-value-or-subq}, {timestamp-value-or-subq}, \
                            {varbinary-value-or-subq}, {point-value-or-subq}, {polygon-value-or-subq}

insert-values-all-val   ::= {insert-values-all-val1} 4| {insert-values-all-val2}
insert-values-all-val1  ::= {integer-non-null-value}, {byte-value}, {integer-value}, {integer-value}, \
                            {integer-value}, {numeric-value}, {numeric-value}, {string-value}, \
                            {string-value}, {string-value}, {json-value}, {timestamp-value}, \
                            {varbinary-value}, {point-value}, {polygon-value}, {string-ipv4-value}, \
                            {string-ipv6-value}, {varbin-ipv4-value}, {varbin-ipv6-value}
insert-values-all-val2  ::= {integer-non-null-value}, {byte-value-or-subq}, {integer-value-or-subq}, {integer-value-or-subq}, \
                            {integer-value-or-subq}, {numeric-value-or-subq}, {numeric-value-or-subq}, {string-value-or-subq}, \
                            {string-value-or-subq}, {string-value-or-subq}, {json-value-or-subq}, {timestamp-value-or-subq}, \
                            {varbinary-value-or-subq}, {point-value-or-subq}, {polygon-value-or-subq}, {str-ipv4-value-or-subq}, \
                            {str-ipv6-value-or-subq}, {varb-ipv4-value-or-subq}, {varb-ipv6-value-or-subq}

insert-values-back-val  ::= {insert-values-back-val1} 4| {insert-values-back-val2}
insert-values-back-val1 ::= {polygon-value}, {point-value}, {varbinary-value}, {timestamp-value}, \
                            {json-value}, {string-value}, {string-value}, {string-value}, \
                            {numeric-value}, {numeric-value}, {integer-value}, {integer-value}, \
                            {integer-value}, {byte-value}, {integer-non-null-value}
insert-values-back-val2 ::= {polygon-value-or-subq}, {point-value-or-subq}, {varbinary-value-or-subq}, {timestamp-value-or-subq}, \
                            {json-value-or-subq}, {string-value-or-subq}, {string-value-or-subq}, {string-value-or-subq}, \
                            {numeric-value-or-subq}, {numeric-value-or-subq}, {integer-value-or-subq}, {integer-value-or-subq}, \
                            {integer-value-or-subq}, {byte-value-or-subq}, {integer-non-null-value}

insert-select-id-num    ::= SERT INTO {table-name} (ID, {numeric-non-id-col-name}) SELECT {int-column-name}, {numeric-col-or-subq}   FROM {table-reference} | \
                            SERT INTO {table-name} ({numeric-non-id-col-name}, ID) SELECT {numeric-col-or-subq}, {int-column-name}   FROM {table-reference} | \
                            SERT INTO {table-name} (ID, {int-non-id-column-name})  SELECT {int-column-name}, {integer-col-or-subq}   FROM {table-reference} | \
                            SERT INTO {table-name} ({int-non-id-column-name}, ID)  SELECT {integer-col-or-subq}, {int-column-name}   FROM {table-reference}
insert-select-id-str    ::= SERT INTO {table-name} (ID, {string-column-name})      SELECT {int-column-name}, {string-col-or-subq}    FROM {table-reference} | \
                            SERT INTO {table-name} ({string-column-name}, ID)      SELECT {string-col-or-subq}, {int-column-name}    FROM {table-reference}
insert-select-id-time   ::= SERT INTO {table-name} (ID, {timestamp-column-name})   SELECT {int-column-name}, {timestamp-col-or-subq} FROM {table-reference} | \
                            SERT INTO {table-name} ({timestamp-column-name}, ID)   SELECT {timestamp-col-or-subq}, {int-column-name} FROM {table-reference}
insert-select-id-varbin ::= SERT INTO {table-name} (ID, {varbinary-column-name})   SELECT {int-column-name}, {varbinary-col-or-subq} FROM {table-reference} | \
                            SERT INTO {table-name} ({varbinary-column-name}, ID)   SELECT {varbinary-col-or-subq}, {int-column-name} FROM {table-reference}
insert-select-id-point  ::= SERT INTO {table-name} (ID, {point-column-name})       SELECT {int-column-name}, {point-col-or-subq}     FROM {table-reference} | \
                            SERT INTO {table-name} ({point-column-name}, ID)       SELECT {point-col-or-subq}, {int-column-name}     FROM {table-reference}
insert-select-id-poly   ::= SERT INTO {table-name} (ID, {polygon-column-name})     SELECT {int-column-name}, {polygon-col-or-subq}   FROM {table-reference} | \
                            SERT INTO {table-name} ({polygon-column-name}, ID)     SELECT {polygon-col-or-subq}, {int-column-name}   FROM {table-reference}

numeric-col-or-subq     ::= {numeric-column-name}     9| {numeric-scalar-sub-q}
integer-col-or-subq     ::= {int-column-name}         9| {integer-scalar-sub-q}
byte-col-or-subq        ::= {byte-column-name}        9| {integer-scalar-sub-q}
string-col-or-subq      ::= {string-column-name}      9| {string-scalar-sub-q}
json-col-or-subq        ::= {json-column-name}        9| {string-scalar-sub-q}
timestamp-col-or-subq   ::= {timestamp-column-name}   9| {timestamp-scalar-sub-q}
varbinary-col-or-subq   ::= {varbinary-column-name}   9| {varbinary-scalar-sub-q}
point-col-or-subq       ::= {point-column-name}       9| {point-scalar-sub-q}
polygon-col-or-subq     ::= {polygon-column-name}     9| {polygon-scalar-sub-q}
str-ipv4-col-or-subq    ::= {string-ipv4-column-name} 9| {str-ipv4-scalar-sub-q}
str-ipv6-col-or-subq    ::= {string-ipv6-column-name} 9| {str-ipv6-scalar-sub-q}
varb-ipv4-col-or-subq   ::= {varbin-ipv4-column-name} 9| {varb-ipv4-scalar-sub-q}
varb-ipv6-col-or-subq   ::= {varbin-ipv6-column-name} 9| {varb-ipv6-scalar-sub-q}

insert-select-multiple  ::= SERT INTO {table-name} (ID, {numeric-non-id-col-name}, {string-column-name}, {timestamp-column-name}, \
                            {varbinary-column-name}, {point-column-name}, {polygon-column-name} ) SELECT {insert-select-mult-val} \
                            FROM {table-reference}
insert-select-all       ::= SERT INTO {table-name} (ID, TINY, SMALL, INT, BIG, NUM, DEC, VCHAR_INLINE, VCHAR_INLINE_MAX, VCHAR, \
                            VCHAR_JSON, TIME, VARBIN, POINT, POLYGON, IPV4, IPV6, VBIPV4, VBIPV6) SELECT {insert-select-all-val} \
                            FROM {table-reference}
insert-select-backward  ::= SERT INTO {table-name} (VBIPV6, VBIPV4, IPV6, IPV4, POLYGON, POINT, VARBIN, TIME, VCHAR_JSON, VCHAR, \
                            VCHAR_INLINE_MAX, VCHAR_INLINE, DEC, NUM, BIG, INT, SMALL, TINY, ID) SELECT {insert-select-back-val} \
                            FROM {table-reference}

insert-select-mult-val  ::= {insert-select-mult-val1} 4| {insert-select-mult-val2}
insert-select-mult-val1 ::= {int-column-name}, {numeric-column-name}, {string-column-name}, {timestamp-column-name}, \
                            {varbinary-column-name}, {point-column-name}, {polygon-column-name}
insert-select-mult-val2 ::= {int-column-name}, {numeric-col-or-subq}, {string-col-or-subq}, {timestamp-col-or-subq}, \
                            {varbinary-col-or-subq}, {point-col-or-subq}, {polygon-col-or-subq}

insert-select-all-val   ::= {insert-select-all-val1} 4| {insert-select-all-val2}
insert-select-all-val1  ::= {int-column-name}, {byte-column-name}, {int-column-name}, {int-column-name}, \
                            {int-column-name}, {numeric-column-name}, {numeric-column-name}, {string-column-name}, \
                            {string-column-name}, {string-column-name}, {json-column-name}, {timestamp-column-name}, \
                            {varbinary-column-name}, {point-column-name}, {polygon-column-name}, {string-ipv4-column-name}, \
                            {string-ipv6-column-name}, {varbin-ipv4-column-name}, {varbin-ipv6-column-name}
insert-select-all-val2  ::= {int-column-name}, {byte-col-or-subq}, {integer-col-or-subq}, {integer-col-or-subq}, \
                            {integer-col-or-subq}, {numeric-col-or-subq}, {numeric-col-or-subq}, {string-col-or-subq}, \
                            {string-col-or-subq}, {string-col-or-subq}, {json-col-or-subq}, {timestamp-col-or-subq}, \
                            {varbinary-col-or-subq}, {point-col-or-subq}, {polygon-col-or-subq}, {str-ipv4-col-or-subq}, \
                            {str-ipv6-col-or-subq}, {varb-ipv4-col-or-subq}, {varb-ipv6-col-or-subq}

insert-select-back-val  ::= {insert-select-back-val1} 4| {insert-select-back-val2}
insert-select-back-val1 ::= {varbin-ipv6-column-name}, {varbin-ipv4-column-name}, {string-ipv6-column-name}, \
                            {string-ipv4-column-name}, {polygon-column-name}, {point-column-name}, {varbinary-column-name}, \
                            {timestamp-column-name}, {json-column-name}, {string-column-name}, {string-column-name}, \
                            {string-column-name}, {numeric-column-name}, {numeric-column-name}, {int-column-name}, \
                            {int-column-name}, {int-column-name}, {byte-column-name}, {int-column-name}
insert-select-back-val2 ::= {varb-ipv6-col-or-subq}, {varb-ipv4-col-or-subq}, {str-ipv6-col-or-subq}, {str-ipv4-col-or-subq}, \
                            {polygon-col-or-subq}, {point-col-or-subq}, {varbinary-col-or-subq}, {timestamp-col-or-subq}, \
                            {json-col-or-subq}, {string-col-or-subq}, {string-col-or-subq}, {string-col-or-subq}, \
                            {numeric-col-or-subq}, {numeric-col-or-subq}, {integer-col-or-subq}, {integer-col-or-subq}, \
                            {integer-col-or-subq}, {byte-col-or-subq}, {int-column-name}

################################################################################
# Grammar rules for an UPSERT statement (almost identical to INSERT):
################################################################################
upsert-statement        ::= {upsert-values-statement} | {upsert-select-statement}

# The "9" before the "|" makes the "simple-upsert-values" or "simple-upsert-select"
# option 9 times as likely as the other option, making simple, valid statements
# more likely
upsert-values-statement ::= {simple-upsert-values} 9| {upsert-clause} VALUES ({values-list})
upsert-select-statement ::= {simple-upsert-select} 9| {upsert-clause} {select-statement}

# Putting "({column-list})" in more than one set of brackets makes it less likely
upsert-clause           ::= UPSERT INTO {table-name} [[({column-list})]]

simple-upsert-values    ::= UP{in-or-up-sert-values}
simple-upsert-select    ::= UP{in-or-up-sert-select}

################################################################################
# Grammar rules for an UPDATE statement:
################################################################################
update-statement        ::= UPDATE {table-name} [[AS ]{table-alias}] SET {column-updates} [{where-clause}] 4| \
                            {corltd-update-statement}

column-updates          ::= {column-update} [, {column-updates}]
column-update           ::= {valid-column-update} 99| \
                            {column-name}             = {value-expression}
valid-column-update     ::= {numeric-column-name}     = {numeric-expression}  7| \
                            {string-column-name}      = {string-expression}   4| \
                            {timestamp-column-name}   = {timestamp-expression} | \
                            {varbinary-column-name}   = {varbinary-expression} | \
                            {point-column-name}       = {point-expression}     | \
                            {polygon-column-name}     = {polygon-expression}   | \
                            {string-ipv4-column-name} = {string-ipv4-expression} | \
                            {string-ipv6-column-name} = {string-ipv6-expression} | \
                            {varbin-ipv4-column-name} = {varbin-ipv4-expression} | \
                            {varbin-ipv6-column-name} = {varbin-ipv6-expression}

# UPDATE statements making use of a correlated column, often in a sub-query,
# in either the SET or the WHERE clause, or both
corltd-update-statement ::= UPDATE {table-name} [AS ]T0     SET {column-updates} WHERE {correlated-t0-bool-expr}  | \
                            UPDATE {table-name-or-alias-t1} SET {column-updates} WHERE {correlated-t1-bool-expr}  | \
                            UPDATE {table-name} [AS ]T0     SET {corltd-t0-column-updates} [{where-clause}] | \
                            UPDATE {table-name-or-alias-t1} SET {corltd-t1-column-updates} [{where-clause}] | \
                            UPDATE {table-name} [AS ]T0     SET {corltd-t0-column-updates} WHERE {correlated-t0-bool-expr} | \
                            UPDATE {table-name-or-alias-t1} SET {corltd-t1-column-updates} WHERE {correlated-t1-bool-expr}

table-name-or-alias-t1  ::= {table-name:t1} 3| {table-name} [AS ]{table-alias:t1}
view-name-or-alias-t1   ::= {view-name:t1}  3| {view-name}  [AS ]{table-alias:t1}

corltd-t0-column-updates::= {corltd-t0-column-update} [, {corltd-t0-column-updates}]
corltd-t0-column-update ::= {column-update} 5| \
                            {numeric-column-name}   = {corltd-t0-numeric-expr}  7| \
                            {string-column-name}    = {corltd-t0-string-expr}   4| \
                            {timestamp-column-name} = {corltd-t0-timestamp-expr} | \
                            {varbinary-column-name} = {corltd-t0-varbinary-expr} | \
                            {point-column-name}     = {corltd-t0-point-expr}     | \
                            {polygon-column-name}   = {corltd-t0-polygon-expr}

corltd-t1-column-updates::= {corltd-t1-column-update} [, {corltd-t1-column-updates}]
corltd-t1-column-update ::= {column-update} 5| \
                            {numeric-column-name}   = {corltd-t1-numeric-expr}  7| \
                            {string-column-name}    = {corltd-t1-string-expr}   4| \
                            {timestamp-column-name} = {corltd-t1-timestamp-expr} | \
                            {varbinary-column-name} = {corltd-t1-varbinary-expr} | \
                            {point-column-name}     = {corltd-t1-point-expr}     | \
                            {polygon-column-name}   = {corltd-t1-polygon-expr}

################################################################################
# Grammar rules for a DELETE (or TRUNCATE) statement:
################################################################################
# The "9" before the "|" makes the "basic-delete-statement" option much more
# likely than the "truncate-statement" option, since we don't want to truncate
# (delete all data from) a table too often
#
delete-statement        ::= {basic-delete-statement} 19| {truncate-statement}

basic-delete-statement  ::= DELETE FROM {table-name} [{where-clause}] [{sort-clause}] 4| \
                            DELETE FROM {table-name:t1} WHERE {correlated-t1-bool-expr}

truncate-statement      ::= TRUNCATE TABLE {table-name}

################################################################################
# Grammar rules for special non-standard SQL statements that can be used in
# sqlcmd (and therefore should be tested), even though they are not part of
# standard SQL. The most important such statements are the ones that 'exec'
# a (System, Default, or User-defined) Stored Procedure; but you can also
# CREATE or DROP a Stored Procedure (which are DDL statements); or 'explain'
# a SQL statement, procedure, or view; or 'show' a list of tables, classes,
# procedures, or functions.
################################################################################
#
special-sql-statement   ::= {exec-stored-proc} 80| {explain-statement} 10| \
                            {random-proc-statement} 9| {show-statement}

# Note: both 'exec' and 'show' have two spaces after them; this is a kludge
# so that all 'exec' statements, and similarly all 'show' statements, will be
# classified as the same type of statement, since the first 6 characters are
# used to determine the SQL statment type.
exec-stored-proc        ::= exec  {stored-proc}
stored-proc             ::= {user-stored-proc} 3| {default-stored-proc} 2| {system-stored-proc}

show-statement          ::= show  {show-items}
legit-show-items        ::= tables 2| classes 2| functions 2| proc | procedures
show-items              ::= {legit-show-items} 199| NONEXISTENT

explain-statement       ::= {explain-sql-statement} | {explainproc-statement} | {explainview-statement}
explain-sql-statement   ::= explain {sql-statement}
explainproc-statement   ::= explainproc {stored-proc-name}
explainview-statement   ::= explainview {view-name}

stored-proc-name        ::= {user-proc-name} 5| {default-proc-name} 4| {system-proc-name}

# Note that these are DDL statements
# TODO: enable {drop-create-proc-stmnt}, once hanging issues resolved
random-proc-statement   ::= {drop-create-proc-stmnt} 0| {create-proc-as-statement} 2| {drop-proc-statement}

################################################################################
# System Stored Procedures
#
system-proc-name        ::= @AdHocLarge | @Explain | @ExplainProc | @ExplainView | \
                            @GetPartitionKeys | @ShapshotDelete | @ShapshotRestore | \
                            @ShapshotSave | @ShapshotScan | @Statistcs | @SwapTables | \
                            @SystemCatalog | @SystemInformation | @UpdateApplicationCatalog | \
                            @UpdateClasses | @UpdateLogging

# Note: the following System Stored Procedures are deliberately omitted above
# (& below), because we do not want to stop, pause, or resume the VoltDB server,
# nor modify the cluster, etc.: @Pause, @Promote, @Quiesce, @Resume, @Shutdown,
# @StopNode; also, you cannot explicitly (using 'exec') call @AdHoc within sqlcmd
# (but it is called implicitly, every time you type a normal SQL statement).

# TODO: may want to include the use of @AdHocLarge
#                            @AdHocLarge '{sql-statement}' | \
system-stored-proc      ::= @Explain '{sql-statement}' | @ExplainProc '{stored-proc-name}' | @ExplainView '{view-name}' | \
                            @GetPartitionKeys {partition-keys-datatype} | \
                            @Statistics {statistics-component}[,] {zero-or-one} | \
                            @SwapTables {swappable-tables} | \
                            @SystemCatalog {system-catalog-component}  | \
                            @SystemInformation {system-info-component} | \
                            @UpdateApplicationCatalog NULL[,] {config-file-name} | \
                            @UpdateClasses {jar-file-name} {java-class-selector} | \
                            @UpdateLogging {log4j-file-name}

partition-keys-datatype ::= INTEGER 2| VARBINARY 2| STRING | VARCHAR | \
                            integer 2| varbinary 2| string | varchar | \
                            '{partition-keys-datatype}'
statistics-component    ::= COMMANDLOG | CPU | DRCONSUMER | DRPRODUCER | DRROLE | IMPORTER | INDEX | INITIATOR | \
                            IOSTATS | LATENCY | LIVECLIENTS | MANAGEMENT | MEMORY | PARTITIONCOUNT | PLANNER | \
                            PROCEDURE | PROCEDUREDETAIL | PROCEDUREINPUT | PROCEDUREOUTPUT | PROCEDUREPROFILE | \
                            QUEUE | REBALANCE | SNAPSHOTSTATUS | TABLE | \
                            '{statistics-component}' 5| \
                            commandlog | cpu | drconsumer | drproducer | drrole | importer | index | initiator | \
                            iostats | latency | liveclient | management | memory | partitioncount | planner | \
                            procedure | proceduredetail | procedureinput | procedureoutput | procedureprofile | \
                            queue | rebalance | snapshotstatus | table
system-catalog-component::= COLUMNS | FUNCTIONS | INDEXINFO | PRIMARYKEYS | PROCEDURECOLUMNS | PROCEDURES | TABLES | \
                            columns | functions | indexinfo | primarykeys | procedurecolumns | procedures | tables | \
                            '{system-catalog-component}'
system-info-component   ::= DEPLOYMENT 2| OVERVIEW 2| deployment 2| overview 2| \
                            '{system-info-component}'

# Some arbitrary (deployment, log4j & jar) config files that are normally found
# within the VoltDB (community) GitHub directories, to be used with some of the
# System Stored Procedures above. Note that the paths are relative to the <voltdb>
# directory, so these will work best when SQL-grammar-gen is run from there; but
# there is also a small chance of prepending '../../' to the paths, in which case
# they will work from the <voltdb>/tests/sqlgrammar/ directory (or some other
# directory two levels down from <voltdb>). However, they will not work at all
# when running from directories other than those.
config-file-name        ::= {config-file-path}  9|  ../../{config-file-path} | \
                           '{config-file-path}' 9| '../../{config-file-path}'
config-file-path        ::= doc/tutorials/auction/deployment.xml | \
                            doc/tutorials/helloworld/deployment.xml | \
                            doc/tutorials/helloworldrevisited/deployment.xml | \
                            tests/geb/vmc/server/deployment.xml | \
                            tests/geb/vmc/server/deploy_pro.xml | \
                            tests/test_apps/log4jsocketimporter/deployment.xml
# TODO: temporarily removed this because it causes a crash (ENG-13394):
#                            tests/test_apps/socketimporter/deployment-log4j.xml
log4j-file-name         ::= {log4j-file-path}  9|  ../../{log4j-file-path} | \
                           '{log4j-file-path}' 9| '../../{log4j-file-path}'
log4j-file-path         ::= voltdb/log4j.xml | \
                            tests/log4j-allconsole.xml | \
                            tests/test_apps/live-rejoin-consistency/log4j.xml | \
                            tests/test_apps/log4jsocketimporter/log4j.xml
jar-file-name           ::= {jar-file-path}  9|  ../../{jar-file-path} | \
                           '{jar-file-path}' 9| '../../{jar-file-path}'
jar-file-path           ::= NULL 16| testgrammar.jar 4| \
                            testfuncs.jar 3| testfuncs_alternative.jar | \
                            doc/tutorials/auction/auction-client.jar | \
                            doc/tutorials/auction/auction-procs.jar | \
                            doc/tutorials/helloworld/helloworld.jar | \
                            doc/tutorials/helloworldrevisited/helloworld.jar | \
                            examples/geospatial/geospatial-client.jar | \
                            examples/geospatial/geospatial-procs.jar | \
                            examples/voter/voter-client.jar | \
                            examples/voter/voter-procs.jar
java-class-selector     ::= "" 16| "sqlgrammartest.*" 2| "sqlgrammartest.{java-proc-name}" 2| \
                            "org.voltdb_testfuncs.*" 2| "org.voltdb_testfuncs.UserDefinedTestFunctions" 2| \
                            "com.auctionexample[[.debug]][[.datafiles]].*" 2| \
                            "geospatial.*" 2| "voter.*" 2| \
                            "Client" | "SignIn"

################################################################################
# Default Stored Procedures
#
default-proc-name       ::= {table-name}.{default-proc-suffix}
default-proc-suffix     ::= delete | insert | select | update | upsert

# The number and type of parameters used by a Default Stored Procedure (e.g.
# R1.delete or P2.insert) depends on both the "suffix name" of the procedure
# (delete, insert, select, update, or upsert) and on the number and type of the
# table's primary key column(s); note that only certain column types are allowed
# in a primary key.
default-stored-proc     ::= {table-name-w-pk-int}.delete {integer-value} | \
                            {table-name-w-pk-int}.select {integer-value} | \
                            {table-name-w-pk-int}.insert {insert-values-all-val} | \
                            {table-name-w-pk-int}.upsert {insert-values-all-val} | \
                            {table-name-w-pk-int}.update {insert-values-all-val} {integer-value} | \
                            {table-name-w-pk-str}.delete {string-value}  | \
                            {table-name-w-pk-str}.select {string-value}  | \
                            {table-name-w-pk-str}.insert {insert-values-all-val} | \
                            {table-name-w-pk-str}.upsert {insert-values-all-val} | \
                            {table-name-w-pk-str}.update {insert-values-all-val} {string-value} | \
                            {table-name-w-pk-varbin}.delete {varbinary-value}  | \
                            {table-name-w-pk-varbin}.select {varbinary-value}  | \
                            {table-name-w-pk-varbin}.insert {insert-values-all-val} | \
                            {table-name-w-pk-varbin}.upsert {insert-values-all-val} | \
                            {table-name-w-pk-varbin}.update {insert-values-all-val} {varbinary-value} | \
                            {table-name-w-pk-int-str}.delete {integer-value} {string-value} | \
                            {table-name-w-pk-int-str}.select {integer-value} {string-value} | \
                            {table-name-w-pk-int-str}.insert {insert-values-all-val} | \
                            {table-name-w-pk-int-str}.upsert {insert-values-all-val} | \
                            {table-name-w-pk-int-str}.update {insert-values-all-val} {integer-value} {string-value} | \
                            {table-name-w-pk-str-int}.delete {string-value} {integer-value} | \
                            {table-name-w-pk-str-int}.select {string-value} {integer-value} | \
                            {table-name-w-pk-str-int}.insert {insert-values-all-val} | \
                            {table-name-w-pk-str-int}.upsert {insert-values-all-val} | \
                            {table-name-w-pk-str-int}.update {insert-values-all-val} {string-value} {integer-value} | \
                            {table-name-w-pk-i-s-v}.delete {integer-value} {string-value} {varbinary-value} | \
                            {table-name-w-pk-i-s-v}.select {integer-value} {string-value} {varbinary-value} | \
                            {table-name-w-pk-i-s-v}.insert {insert-values-all-val} | \
                            {table-name-w-pk-i-s-v}.upsert {insert-values-all-val} | \
                            {table-name-w-pk-i-s-v}.update {insert-values-all-val} {integer-value} {string-value} {varbinary-value}

################################################################################
# User-defined Stored Procedures
#
user-stored-proc        ::= {user-proc-0params} 2| {user-proc-1param} {integer-value}

################################################################################
# Grammar rules for a SELECT statement (lots of these!):
################################################################################
select-statement        ::= {basic-select-statement} 9| {select-statement} {set-operator} {select-statement}
set-operator            ::= UNION [ALL] | INTERSECT [ALL] | EXCEPT

# Putting the "top-clause" and "all-or-distinct" in more than one set of
# brackets makes them less likely
basic-select-statement  ::= SELECT {top-all-or-distinct} {select-list} {from-clause}
top-all-or-distinct     ::= [[[{top-clause}]]] [[{all-or-distinct}]]
from-clause             ::= FROM {table-references} [[{where-clause}]] [[{group-clause}]] [{sort-clause}] 38| \
                            {from-clause-with-t0} | {from-clause-with-t1}
from-clause-no-limit    ::= FROM {table-references} [[{where-clause}]] {group-order-no-limit} 38| \
                            {from-clause-with-t0} | {from-clause-with-t1}
group-order-no-limit    ::= [[{group-clause}]] [{order-by-clause}]

all-or-distinct         ::= ALL | DISTINCT
select-list             ::= {select-list-item}[[, {select-list}]]
select-list-item        ::= {star} 5| {column-expression} [[AS] {column-alias}] 14| {window-function-expr} [[AS] {column-alias}]

column-expression       ::= {column-name-ref} 3| {selection-expression}
column-reference        ::= {column-name-ref} 4| {column-alias}
column-ref-or-expr      ::= {column-reference} | {column-expression}
# The use of ":tr1", ":tr2", etc., is mainly useful in the case of a JOIN,
# so that the column names are unambiguous
column-name-ref         ::= {any-column-name} 78| \
                            {table-alias-or-name:tr1}.{any-column-name} 16| \
                            {table-alias-or-name:tr2}.{any-column-name} 16| \
                            {table-alias-or-name:tr3}.{any-column-name}  4| \
                            {table-alias-or-name:tr4}.{any-column-name}  2| \
                            {table-alias-or-name:tr5}.{any-column-name}

# Putting the ", {table-references}" in more than one set of brackets makes it less likely
table-references        ::= {table-reference} [[[, {table-references}]]] 4| {join-clause}

# The "3" before the first "|" makes the "table-name..." option, and the "2"
# before the "view-name..." option, makes them more likely than the "sub-query..."
# option, making simple, valid statements more likely
table-reference         ::= {table-name}[[ AS] {table-alias}] 5| \
                            {view-name}[ [ AS] {table-alias}] 2| \
                            {sub-query}  [ AS] {table-alias}   | \
                            {table-name-or-alias-t1} | \
                            {view-name-or-alias-t1}

# Defining these separately so that they can optionally be overridden, for use
# with SQLCoverage, to avoid syntax (TOP) not supported by PostgreSQL, and
# issues with Geospatial types (point & polygon), where using * can be a problem
star                    ::= *
top-clause              ::= TOP {non-negative-int-value}
top-one                 ::= TOP 1   98| TOP 0   | TOP {byte-non-null-value}
limit-one               ::= LIMIT 1 98| LIMIT 0 | LIMIT {byte-non-null-value}

# PostgreSQL-compatible versions of the above: avoids problems involving SELECT *
# with Geospatial types; and involving TOP, which PostgreSQL does not support
pg-star                 ::= ID, TINY, SMALL, INT, BIG, NUM, DEC, VCHAR_INLINE, VCHAR_INLINE_MAX, \
                            VCHAR, VCHAR_JSON, TIME, VARBIN, AsText(POINT), AsText(POLYGON)
pg-top-clause           ::=
pg-top-one              ::=

where-clause            ::= WHERE {boolean-expression}
boolean-expression      ::=   [NOT ] {boolean-type-expr}   [[{and-or} {boolean-expression}]] 8| \
                            ([[NOT ]]{boolean-expression}) [[{and-or} {boolean-expression}]] 2| \
                            {correlated-bool-expr}
and-or                  ::= AND | OR

group-clause            ::= GROUP BY {group-by-list} [HAVING {boolean-expression}]
order-by-clause         ::= ORDER BY {order-by-list}
sort-clause             ::= [{order-by-clause}] [LIMIT {non-negative-int-value}] [OFFSET {non-negative-int-value}]
group-by-list           ::= {column-ref-or-expr}                 [, {group-by-list}]
order-by-list           ::= {column-ref-or-expr} [{asc-or-desc}] [, {order-by-list}]
asc-or-desc             ::= ASC | DESC

# PostgreSQL-compatible version of the above: avoids LIMIT or OFFSET without ORDER BY
pg-sort-clause          ::= {order-by-clause}, ID [LIMIT {non-negative-int-value}] [OFFSET {non-negative-int-value}]

value-expression        ::= {numeric-expression} 7| {string-expression} 4| {timestamp-expression}
selection-expression    ::= {value-expression} 9| COUNT(*)
boolean-type-expr       ::= {column-expression} IS [NOT ]NULL | {sub-query} IS [NOT ]NULL | \
                            {boolean-numeric-expr}  7| {boolean-string-expr} 4| {boolean-timestamp-expr} | \
                            {boolean-varbinary-expr} | {boolean-point-expr}   | {boolean-polygon-expr} | \
                            EXISTS {sub-query} | {bool-val-timestamp-expr} | {bool-valued-polygon-expr}
boolean-numeric-expr    ::= {numeric-expression}   {comparison-operator} {numeric-expression}   4| \
                            {numeric-column-name}   IN {numeric-sub-query}
boolean-string-expr     ::= {string-expression}    {comparison-operator} {string-expression}    4| \
                            {string-column-name}    IN {string-sub-query}
boolean-timestamp-expr  ::= {timestamp-expression} {comparison-operator} {timestamp-expression} 4| \
                            {timestamp-column-name} IN {timestamp-sub-query}
boolean-varbinary-expr  ::= {varbinary-expression} {comparison-operator} {varbinary-expression} 4| \
                            {varbinary-column-name} IN {varbinary-sub-query}
boolean-point-expr      ::= {point-expression} {comparison-operator} {point-expression} 4| \
                            {point-column-name}     IN {point-sub-query}
boolean-polygon-expr    ::= {polygon-expression} {comparison-operator} {polygon-expression} 4| \
                            {polygon-column-name}   IN {polygon-sub-query}
comparison-operator     ::= = 3| <> | != | < | > | <= | >= | IS NOT DISTINCT FROM

################################################################################
# Joins, of various types, including multi-joins of up to 5 tables
#
join-clause             ::= {table-reference:tr1} [{join-type}] JOIN {table-reference:tr2} {join-condition1} \
                                               [[ [{join-type}] JOIN {table-reference:tr3} {join-condition2} \
                                                [ [{join-type}] JOIN {table-reference:tr4} {join-condition3} \
                                                [ [{join-type}] JOIN {table-reference:tr5} {join-condition4} ]] ]]
join-type               ::= INNER | {left-or-right} [OUTER]
left-or-right           ::= LEFT | RIGHT | FULL

join-condition1         ::= USING ({column-reference:c1}) 4| \
                            ON {:tr1}.{column-ref-or-expr:c1} = {:tr2}.{:c1} | \
                            ON {:tr2}.{column-ref-or-expr:c1} = {:tr1}.{:c1} | \
                            ON {:tr1}.{column-ref-or-expr} {comparison-operator} {:tr2}.{column-ref-or-expr} | \
                            ON {:tr2}.{column-ref-or-expr} {comparison-operator} {:tr1}.{column-ref-or-expr}
join-condition2         ::= USING ({column-reference:c1}) 4| \
                            ON {:tr2}.{column-ref-or-expr:c2} = {:tr3}.{:c2} | \
                            ON {:tr3}.{column-ref-or-expr:c2} = {:tr1}.{:c2} | \
                            ON {:tr3}.{column-ref-or-expr} {comparison-operator} {:tr1}.{column-ref-or-expr} | \
                            ON {:tr2}.{column-ref-or-expr} {comparison-operator} {:tr3}.{column-ref-or-expr}
join-condition3         ::= USING ({column-reference:c1}) 4| \
                            ON {:tr3}.{column-ref-or-expr:c3} = {:tr4}.{:c3} | \
                            ON {:tr4}.{column-ref-or-expr:c3} = {:tr1}.{:c3} | \
                            ON {:tr2}.{column-ref-or-expr} {comparison-operator} {:tr4}.{column-ref-or-expr} | \
                            ON {:tr4}.{column-ref-or-expr} {comparison-operator} {:tr3}.{column-ref-or-expr}
join-condition4         ::= USING ({column-reference:c1}) 4| \
                            ON {:tr1}.{column-ref-or-expr:c4} = {:tr5}.{:c4} | \
                            ON {:tr5}.{column-ref-or-expr:c4} = {:tr4}.{:c4} | \
                            ON {:tr2}.{column-ref-or-expr} {comparison-operator} {:tr5}.{column-ref-or-expr} | \
                            ON {:tr5}.{column-ref-or-expr} {comparison-operator} {:tr3}.{column-ref-or-expr}

################################################################################
# Sub-queries, scalar and otherwise, of various types
#
sub-query               ::= ({select-statement}) 3| {scalar-sub-query}
scalar-sub-query        ::= {numeric-scalar-sub-q}  7| {string-scalar-sub-q}   4| \
                            {timestamp-scalar-sub-q} | {varbinary-scalar-sub-q} | \
                            {point-scalar-sub-q}     | {polygon-scalar-sub-q}

numeric-sub-query       ::= (SELECT {top-all-or-distinct}   {numeric-expression} {from-clause})
string-sub-query        ::= (SELECT {top-all-or-distinct}    {string-expression} {from-clause})
timestamp-sub-query     ::= (SELECT {top-all-or-distinct} {timestamp-expression} {from-clause})
varbinary-sub-query     ::= (SELECT {top-all-or-distinct} {varbinary-expression} {from-clause})
point-sub-query         ::= (SELECT {top-all-or-distinct}     {point-expression} {from-clause})
polygon-sub-query       ::= (SELECT {top-all-or-distinct}   {polygon-expression} {from-clause})
numeric-scalar-sub-q    ::= (SELECT  {aggregate-function}({numeric-expression})  {from-clause}) 3| \
                            (SELECT {num-result-aggr-func}({column-expression})  {from-clause}) 3| \
                            (SELECT COUNT(*)                                     {from-clause})  | \
                            (SELECT {top-one}   {numeric-expression} {from-clause-no-limit})     | \
                            (SELECT             {numeric-expression} {from-clause-no-limit} {limit-one})
integer-scalar-sub-q    ::= (SELECT  {aggregate-function}({int-expression})      {from-clause}) 3| \
                            (SELECT {num-result-aggr-func}({column-expression})  {from-clause}) 3| \
                            (SELECT COUNT(*)                                     {from-clause})  | \
                            (SELECT {top-one}   {int-expression}     {from-clause-no-limit})     | \
                            (SELECT             {int-expression}     {from-clause-no-limit} {limit-one})
string-scalar-sub-q     ::= (SELECT {non-num-aggregate-func}({string-expression})  {from-clause}) 6| \
                            (SELECT {top-one}    {string-expression} {from-clause-no-limit})       | \
                            (SELECT              {string-expression} {from-clause-no-limit} {limit-one})
json-scalar-sub-q       ::= (SELECT {non-num-aggregate-func}({json-expression})  {from-clause}) 6| \
                            (SELECT {top-one}    {json-expression} {from-clause-no-limit})       | \
                            (SELECT              {json-expression} {from-clause-no-limit} {limit-one})
timestamp-scalar-sub-q  ::= (SELECT {non-num-aggregate-func}({timestamp-expression}) {from-clause}) 6| \
                            (SELECT {top-one} {timestamp-expression} {from-clause-no-limit})         | \
                            (SELECT           {timestamp-expression} {from-clause-no-limit} {limit-one})
varbinary-scalar-sub-q  ::= (SELECT {non-num-aggregate-func}({varbinary-expression}) {from-clause}) 6| \
                            (SELECT {top-one} {varbinary-expression} {from-clause-no-limit})         | \
                            (SELECT           {varbinary-expression} {from-clause-no-limit} {limit-one})
point-scalar-sub-q      ::= (SELECT {non-num-aggregate-func}({point-expression}) {from-clause}) 6| \
                            (SELECT {top-one} {point-expression} {from-clause-no-limit})         | \
                            (SELECT           {point-expression} {from-clause-no-limit} {limit-one})
polygon-scalar-sub-q    ::= (SELECT {non-num-aggregate-func}({polygon-expression}) {from-clause}) 6| \
                            (SELECT {top-one} {polygon-expression} {from-clause-no-limit})         | \
                            (SELECT           {polygon-expression} {from-clause-no-limit} {limit-one})
str-ipv4-scalar-sub-q   ::= (SELECT {non-num-aggregate-func}({string-ipv4-expression}) {from-clause}) 6| \
                            (SELECT {top-one} {string-ipv4-expression} {from-clause-no-limit})         | \
                            (SELECT           {string-ipv4-expression} {from-clause-no-limit} {limit-one})
str-ipv6-scalar-sub-q   ::= (SELECT {non-num-aggregate-func}({string-ipv6-expression}) {from-clause}) 6| \
                            (SELECT {top-one} {string-ipv6-expression} {from-clause-no-limit})         | \
                            (SELECT           {string-ipv6-expression} {from-clause-no-limit} {limit-one})
varb-ipv4-scalar-sub-q  ::= (SELECT {non-num-aggregate-func}({varbin-ipv4-expression}) {from-clause}) 6| \
                            (SELECT {top-one} {varbin-ipv4-expression} {from-clause-no-limit})         | \
                            (SELECT           {varbin-ipv4-expression} {from-clause-no-limit} {limit-one})
varb-ipv6-scalar-sub-q  ::= (SELECT {non-num-aggregate-func}({varbin-ipv6-expression}) {from-clause}) 6| \
                            (SELECT {top-one} {varbin-ipv6-expression} {from-clause-no-limit})         | \
                            (SELECT           {varbin-ipv6-expression} {from-clause-no-limit} {limit-one})

################################################################################
# Used to create correlated expressions and sub-queries, referring to a "T0"
# table (or view) alias; that is, a boolean expression or sub-query that
# compares the values from its own table (or view) with those of "T0" which
# was defined in the outer query
#

correlated-t0-bool-expr ::= {corltd-t0-bool-simp-expr}  | {corltd-t0-bool-subq-expr}
correlated-t0-bool-expr2::= {corltd-t0-bool-simp-expr} 9| {corltd-t0-bool-subq-expr}
corltd-t0-bool-simp-expr::= {numeric-expression}   {comparison-operator} T0.{numeric-column-name}  7| \
                            {string-expression}    {comparison-operator} T0.{string-column-name}   4| \
                            {timestamp-expression} {comparison-operator} T0.{timestamp-column-name} | \
                            {varbinary-expression} {comparison-operator} T0.{varbinary-column-name} | \
                            {point-expression}     {comparison-operator} T0.{point-column-name}     | \
                            {polygon-expression}   {comparison-operator} T0.{polygon-column-name}   | \
                            T0.{numeric-column-name}   {comparison-operator} {numeric-expression}  7| \
                            T0.{string-column-name}    {comparison-operator} {string-expression}   4| \
                            T0.{timestamp-column-name} {comparison-operator} {timestamp-expression} | \
                            T0.{varbinary-column-name} {comparison-operator} {varbinary-expression} | \
                            T0.{point-column-name}     {comparison-operator} {point-expression}     | \
                            T0.{polygon-column-name}   {comparison-operator} {polygon-expression}
corltd-t0-bool-subq-expr::= {numeric-expression}   {comparison-operator} ({numeric-corltd-t0-subq})   7| \
                            {string-expression}    {comparison-operator} ({string-corltd-t0-subq})    4| \
                            {timestamp-expression} {comparison-operator} ({timestamp-corltd-t0-subq})  | \
                            {varbinary-expression} {comparison-operator} ({varbinary-corltd-t0-subq})  | \
                            {point-expression}     {comparison-operator} ({point-corltd-t0-subq})      | \
                            {polygon-expression}   {comparison-operator} ({polygon-corltd-t0-subq})    | \
                            ({numeric-corltd-t0-subq})   {comparison-operator} {numeric-expression}   7| \
                            ({string-corltd-t0-subq})    {comparison-operator} {string-expression}    4| \
                            ({timestamp-corltd-t0-subq}) {comparison-operator} {timestamp-expression}  | \
                            ({varbinary-corltd-t0-subq}) {comparison-operator} {varbinary-expression}  | \
                            ({point-corltd-t0-subq})     {comparison-operator} {point-expression}      | \
                            ({polygon-corltd-t0-subq})   {comparison-operator} {polygon-expression}

numeric-corltd-t0-subq  ::= SELECT  {aggregate-function}({numeric-expression}) {from-clause-corltd-t0} 3| \
                            SELECT {num-result-aggr-func}({column-expression}) {from-clause-corltd-t0} 3| \
                            SELECT COUNT(*)                                    {from-clause-corltd-t0}  | \
                            SELECT {top-one}             {numeric-expression}  {from-clause-corltd-t0}  | \
                            SELECT                       {numeric-expression}  {from-clause-corltd-t0} {limit-one}
string-corltd-t0-subq   ::= SELECT {non-num-aggregate-func}({string-expression}) {from-clause-corltd-t0} 6| \
                            SELECT {top-one}                {string-expression}  {from-clause-corltd-t0}  | \
                            SELECT                          {string-expression}  {from-clause-corltd-t0} {limit-one}
timestamp-corltd-t0-subq::= SELECT {non-num-aggregate-func}({timestamp-expression}) {from-clause-corltd-t0} 6| \
                            SELECT {top-one}                {timestamp-expression}  {from-clause-corltd-t0}  | \
                            SELECT                          {timestamp-expression}  {from-clause-corltd-t0} {limit-one}
varbinary-corltd-t0-subq::= SELECT {non-num-aggregate-func}({varbinary-expression}) {from-clause-corltd-t0} 6| \
                            SELECT {top-one}                {varbinary-expression}  {from-clause-corltd-t0}  | \
                            SELECT                          {varbinary-expression}  {from-clause-corltd-t0} {limit-one}
point-corltd-t0-subq    ::= SELECT {non-num-aggregate-func}({point-expression}) {from-clause-corltd-t0} 6| \
                            SELECT {top-one}                {point-expression}  {from-clause-corltd-t0}  | \
                            SELECT                          {point-expression}  {from-clause-corltd-t0} {limit-one}
polygon-corltd-t0-subq  ::= SELECT {non-num-aggregate-func}({polygon-expression}) {from-clause-corltd-t0} 6| \
                            SELECT {top-one}                {polygon-expression}  {from-clause-corltd-t0}  | \
                            SELECT                          {polygon-expression}  {from-clause-corltd-t0} {limit-one}
from-clause-corltd-t0   ::= FROM {table-or-view-name}    WHERE {correlated-t0-bool-expr2} [{group-order-no-limit}]
from-clause-with-t0     ::= FROM {table-or-view-name} T0 WHERE {corltd-t0-bool-subq-expr} [{group-order-no-limit}]

# Same idea as above, but without using a "T0" alias; instead, the same actual
# table name (referred to here as {:t1}) is used again
correlated-t1-bool-expr ::= {corltd-t1-bool-simp-expr}  | {corltd-t1-bool-subq-expr}
correlated-t1-bool-expr2::= {corltd-t1-bool-simp-expr} 9| {corltd-t1-bool-subq-expr}
corltd-t1-bool-simp-expr::= {numeric-expression}   {comparison-operator} {:t1}.{numeric-column-name}  7| \
                            {string-expression}    {comparison-operator} {:t1}.{string-column-name}   4| \
                            {timestamp-expression} {comparison-operator} {:t1}.{timestamp-column-name} | \
                            {varbinary-expression} {comparison-operator} {:t1}.{varbinary-column-name} | \
                            {point-expression}     {comparison-operator} {:t1}.{point-column-name}     | \
                            {polygon-expression}   {comparison-operator} {:t1}.{polygon-column-name}   | \
                            {:t1}.{numeric-column-name}   {comparison-operator} {numeric-expression}  7| \
                            {:t1}.{string-column-name}    {comparison-operator} {string-expression}   4| \
                            {:t1}.{timestamp-column-name} {comparison-operator} {timestamp-expression} | \
                            {:t1}.{varbinary-column-name} {comparison-operator} {varbinary-expression} | \
                            {:t1}.{point-column-name}     {comparison-operator} {point-expression}     | \
                            {:t1}.{polygon-column-name}   {comparison-operator} {polygon-expression}
corltd-t1-bool-subq-expr::= {numeric-expression}   {comparison-operator} ({numeric-corltd-t1-subq})    7| \
                            {string-expression}    {comparison-operator} ({string-corltd-t1-subq})     4| \
                            {timestamp-expression} {comparison-operator} ({timestamp-corltd-t1-subq})   | \
                            {varbinary-expression} {comparison-operator} ({varbinary-corltd-t1-subq})   | \
                            {point-expression}     {comparison-operator} ({point-corltd-t1-subq})       | \
                            {polygon-expression}   {comparison-operator} ({polygon-corltd-t1-subq})     | \
                            ({numeric-corltd-t1-subq})   {comparison-operator} {numeric-expression}    7| \
                            ({string-corltd-t1-subq})    {comparison-operator} {string-expression}     4| \
                            ({timestamp-corltd-t1-subq}) {comparison-operator} {timestamp-expression}   | \
                            ({varbinary-corltd-t1-subq}) {comparison-operator} {varbinary-expression}   | \
                            ({point-corltd-t1-subq})     {comparison-operator} {point-expression}       | \
                            ({polygon-corltd-t1-subq})   {comparison-operator} {polygon-expression}

numeric-corltd-t1-subq  ::= SELECT  {aggregate-function}({numeric-expression}) {from-clause-corltd-t1} 3| \
                            SELECT {num-result-aggr-func}({column-expression}) {from-clause-corltd-t1} 3| \
                            SELECT COUNT(*)                                    {from-clause-corltd-t1}  | \
                            SELECT {top-one}             {numeric-expression}  {from-clause-corltd-t1}  | \
                            SELECT                       {numeric-expression}  {from-clause-corltd-t1} {limit-one}
string-corltd-t1-subq   ::= SELECT {non-num-aggregate-func}({string-expression}) {from-clause-corltd-t1} 6| \
                            SELECT {top-one}                {string-expression}  {from-clause-corltd-t1}  | \
                            SELECT                          {string-expression}  {from-clause-corltd-t1} {limit-one}
timestamp-corltd-t1-subq::= SELECT {non-num-aggregate-func}({timestamp-expression}) {from-clause-corltd-t1} 6| \
                            SELECT {top-one}                {timestamp-expression}  {from-clause-corltd-t1}  | \
                            SELECT                          {timestamp-expression}  {from-clause-corltd-t1} {limit-one}
varbinary-corltd-t1-subq::= SELECT {non-num-aggregate-func}({varbinary-expression}) {from-clause-corltd-t1} 6| \
                            SELECT {top-one}                {varbinary-expression}  {from-clause-corltd-t1}  | \
                            SELECT                          {varbinary-expression}  {from-clause-corltd-t1} {limit-one}
point-corltd-t1-subq    ::= SELECT {non-num-aggregate-func}({point-expression}) {from-clause-corltd-t1} 6| \
                            SELECT {top-one}                {point-expression}  {from-clause-corltd-t1}  | \
                            SELECT                          {point-expression}  {from-clause-corltd-t1} {limit-one}
polygon-corltd-t1-subq  ::= SELECT {non-num-aggregate-func}({polygon-expression}) {from-clause-corltd-t1} 6| \
                            SELECT {top-one}                {polygon-expression}  {from-clause-corltd-t1}  | \
                            SELECT                          {polygon-expression}  {from-clause-corltd-t1} {limit-one}
from-clause-corltd-t1   ::= FROM {table-or-view-name}    WHERE {correlated-t1-bool-expr2} [{group-order-no-limit}]
from-clause-with-t1     ::= FROM {table-or-view-name:t1} WHERE {corltd-t1-bool-subq-expr} [{group-order-no-limit}]

# Similar ideas to the above, but returning values of a certain specified type,
# rather than a boolean value
corltd-t0-numeric-expr  ::= ({numeric-corltd-t0-subq})   3| T0.{numeric-column-name}
corltd-t0-string-expr   ::= ({string-corltd-t0-subq})    3| T0.{string-column-name}
corltd-t0-timestamp-expr::= ({timestamp-corltd-t0-subq}) 3| T0.{timestamp-column-name}
corltd-t0-varbinary-expr::= ({varbinary-corltd-t0-subq}) 3| T0.{varbinary-column-name}
corltd-t0-point-expr    ::= ({point-corltd-t0-subq})     3| T0.{point-column-name}
corltd-t0-polygon-expr  ::= ({polygon-corltd-t0-subq})   3| T0.{polygon-column-name}

corltd-t1-numeric-expr  ::= ({numeric-corltd-t1-subq})   3| {:t1}.{numeric-column-name}
corltd-t1-string-expr   ::= ({string-corltd-t1-subq})    3| {:t1}.{string-column-name}
corltd-t1-timestamp-expr::= ({timestamp-corltd-t1-subq}) 3| {:t1}.{timestamp-column-name}
corltd-t1-varbinary-expr::= ({varbinary-corltd-t1-subq}) 3| {:t1}.{varbinary-column-name}
corltd-t1-point-expr    ::= ({point-corltd-t1-subq})     3| {:t1}.{point-column-name}
corltd-t1-polygon-expr  ::= ({polygon-corltd-t1-subq})   3| {:t1}.{polygon-column-name}

# Similar idea to the above, but in a generic SELECT statement, where a table
# alias of T0 or {table-name:t1} may or may not have been used
correlated-bool-expr    ::= {numeric-expression}   {comparison-operator} {table-alias-or-name}.{numeric-column-name}  7| \
                            {string-expression}    {comparison-operator} {table-alias-or-name}.{string-column-name}   4| \
                            {timestamp-expression} {comparison-operator} {table-alias-or-name}.{timestamp-column-name} | \
                            {table-alias-or-name}.{numeric-column-name}   {comparison-operator} {numeric-expression}  7| \
                            {table-alias-or-name}.{string-column-name}    {comparison-operator} {string-expression}   4| \
                            {table-alias-or-name}.{timestamp-column-name} {comparison-operator} {timestamp-expression} | \
                            {numeric-expression}   {comparison-operator} {table-name:t1}.{numeric-column-name} 14| \
                            {string-expression}    {comparison-operator} {table-name:t1}.{string-column-name}   8| \
                            {timestamp-expression} {comparison-operator} {table-name:t1}.{timestamp-column-name} | \
                            {table-name:t1}.{numeric-column-name}   {comparison-operator} {numeric-expression} 14| \
                            {table-name:t1}.{string-column-name}    {comparison-operator} {string-expression}   8| \
                            {table-name:t1}.{timestamp-column-name} {comparison-operator} {timestamp-expression} | \
                            {numeric-expression}   {comparison-operator} T0.{numeric-column-name}  7| \
                            {string-expression}    {comparison-operator} T0.{string-column-name}   4| \
                            {timestamp-expression} {comparison-operator} T0.{timestamp-column-name} | \
                            T0.{numeric-column-name}   {comparison-operator} {numeric-expression}  7| \
                            T0.{string-column-name}    {comparison-operator} {string-expression}   4| \
                            T0.{timestamp-column-name} {comparison-operator} {timestamp-expression}

################################################################################
# Window functions - a.k.a. analytic functions
#
window-function-expr    ::= {window-function} OVER ({partition-or-order-by})
window-function         ::= {window-agg-func-expr} 4| COUNT(*) | RANK() | DENSE_RANK()

# SUM can only take numeric argument; others can take any type;
# (AVG not actually supported here, but it should not crash)
window-agg-func-expr    ::= {non-num-arg-aggr-func}({column-expression}) 3| \
                            {num-only-aggregate-func}({numeric-expression})

# This is somewhat redundant, but since some window functions (RANK, DENSE_RANK)
# require an ORDER BY, we make that more likely; and while other window functions
# do allow this to be empty, that is less interesting, even when legal, so we
# make it less likely
partition-or-order-by   ::= [PARTITION BY {partition-by-list}]  ORDER BY {window-order-by-list} | \
                            [PARTITION BY {partition-by-list}] [ORDER BY {window-order-by-list}]
partition-by-list       ::= {column-expression} [[, {partition-by-list}]]

# Some window functions (RANK, DENSE_RANK) only allow a single int or timestamp
# expression in the ORDER BY clause, so we make those options more likely
window-order-by-list    ::= {window-order-by-item} [{asc-or-desc}] [[, {window-order-by-list}]]
window-order-by-item    ::= {column-expression} 2| {int-expression} | {timestamp-expression}

################################################################################
# Aggregate functions - used with various data types defined below
# (and in the window functions and scalar sub-queries above)
#
# TODO: More use of these in GROUP BY queries
num-only-aggregate-func ::= SUM | AVG
num-result-aggr-func    ::= COUNT 3| APPROX_COUNT_DISTINCT
non-num-aggregate-func  ::= MIN | MAX
non-num-arg-aggr-func   ::= {non-num-aggregate-func} 2| {num-result-aggr-func}
aggregate-function      ::= {non-num-arg-aggr-func}  2| {num-only-aggregate-func}

################################################################################
# Numeric constant values, functions, operators and expressions
#
non-zero-digit          ::= 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
digit                   ::= {non-zero-digit} 9| 0
non-negative-int-value  ::= {digit}[{digit}[{digit}][{non-negative-int-value}]]
integer-non-null-value  ::= [-]{non-negative-int-value}
numeric-non-null-value  ::= {integer-non-null-value}[.{non-negative-int-value}[{non-negative-int-value}]]

# Byte values as defined here run from -129 to 129; since byte is really
# defined as -127 to 127, a few of those values are illegal, which is OK
byte-start              ::= 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12
byte-non-null-value     ::= [-][{byte-start}]{digit}

# The "3" before the "|" makes the "byte-non-null-value", "integer-non-null-value",
# and "numeric-non-null-value" options 3 times as likely as the NULL option
byte-value              ::= {byte-non-null-value}    3| NULL
integer-value           ::= {integer-non-null-value} 3| NULL
numeric-value           ::= {numeric-non-null-value} 3| NULL

byte-expression         ::= {byte-value}    | {byte-column-name}  2| {byte-function-expr}
int-expression          ::= {integer-value} |  {int-column-name}  2|  {int-function-expr}
numeric-expression      ::= {simple-numeric-expr} 49| {numeric-scalar-sub-q}
simple-numeric-expr     ::= {numeric-value} | [[[[{table-alias-or-name}.]]]]{numeric-column-name} 9| \
                            {numeric-function-expr} | {int-expression}

int-function-expr       ::= {int-expression} {math-operator} {int-expression} | \
                            {int-function-1arg}({int-expression}) | \
                            {int-function-2args}({int-expression}, {int-expression}) | \
                            {int-function-2args-1pos}({int-expression},{non-negative-int-value}) | \
                            {int-valued-string-expr} | {int-valued-time-expr} | {int-valued-t-unit-expr}
byte-function-expr      ::= {byte-expression} {math-operator} {byte-expression} | \
                            {int-function-2args}({byte-expression}, {byte-expression})
numeric-function-expr   ::= {numeric-expression} {math-operator} {numeric-expression} | \
                            {math-function-0args}[()] | \
                            {math-function-1arg}({numeric-expression}) 14| \
                            {math-function-2args}({numeric-expression}, {numeric-expression}) | \
                            {num-valued-time-expr} | {num-valued-point-expr} | {num-valued-polygon-expr}

math-operator           ::= + | - | * | /
math-function-0args     ::= PI 9| {numeric-udf-func-0args}
math-function-1arg      ::= ABS | CEILING | EXP | FLOOR | LN | LOG | LOG10 | SQRT | \
                            {numeric-udf-func-1arg} 2| SIN | COS | TAN | CSC | SEC | COT
math-function-2args     ::= POWER 9| {numeric-udf-func-2args}
int-function-2args      ::= MOD   9| {int-udf-func-2args} | BITAND | BITOR | BITXOR
int-function-1arg       ::= BITNOT
# the bit_shift functions require a positive int offset value
int-function-2args-1pos ::= BIT_SHIFT_LEFT | BIT_SHIFT_RIGHT

numeric-udf-func-0args  ::= piUdf | piUdfBoxed
byte-udf-func-1arg      ::= absTinyint | absTinyintBoxed
int-udf-func-1arg       ::= {byte-udf-func-1arg} 2| absSmallint | absSmallintBoxed | \
                            absInteger | absIntegerBoxed | absBigint | absBigintBoxed
numeric-udf-func-1arg   ::= {int-udf-func-1arg}  8| absFloat | absFloatBoxed | absDecimal
byte-udf-func-2args     ::= add2Tinyint  | add2TinyintBoxed  | add2TinyintWithoutNullCheck  | \
                            modTinyint   | modTinyintBoxed   | add2TinyintBoxedWithoutNullCheck
int-udf-func-2args      ::= {byte-udf-func-2args} 6| \
                            add2Smallint | add2SmallintBoxed | add2SmallintWithoutNullCheck | \
                            modSmallint  | modSmallintBoxed  | add2SmallintBoxedWithoutNullCheck | \
                            add2Integer  | add2IntegerBoxed  | add2IntegerWithoutNullCheck  | \
                            modInteger   | modIntegerBoxed   | add2IntegerBoxedWithoutNullCheck  | \
                            add2Bigint   | add2BigintBoxed   | add2BigintWithoutNullCheck   | \
                            modBigint    | modBigintBoxed    | add2BigintBoxedWithoutNullCheck
numeric-udf-func-2args  ::= {int-udf-func-2args} 24| \
                            add2Decimal | add2Float | add2FloatBoxed | add2FloatWithoutNullCheck | \
                            modDecimal  | modFloat  | modFloatBoxed  | add2FloatBoxedWithoutNullCheck

################################################################################
# String (VARCHAR) constant values, functions, operators and expressions
#
character               ::= A | B | C | D | E | F | G | H | I | J | K | L | M | N | O | P | Q | R | S | T | U | V | W | X | Y | Z | \
                            a | b | c | d | e | f | g | h | i | j | k | l | m | n | o | p | q | r | s | t | u | v | w | x | y | z | \
                            {digit} 10| . | , | ! | @ | # | $ | % | ^ | & | * | ( | ) | - | _ | + | =
characters              ::= [{character}][{character}][{character}[{characters}]]
string-non-null-value   ::= '{characters}'

# The "3" before the "|" makes the "string-non-null-value" option 3 times as
# likely as the NULL option, making NULL values less likely
string-value            ::= {string-non-null-value} 3| NULL

# TODO: make these into actual JSON strings:
json-value              ::= {string-value}
json-expression         ::= {string-expression}

string-expression       ::= {simple-string-expr} 49| {string-scalar-sub-q}
simple-string-expr      ::= {string-value} | [[[[{table-alias-or-name}.]]]]{string-column-name} 6| \
                            {string-function-expr}
string-function-expr    ::= {string-expression} {string-operator} {string-expression} 2| \
                            {string-valued-int-expr}  4| {string-val-str-int-expr}  5| \
                            {string-val-num-int-expr} 2| {string-special-func-expr} 3| \
                            {str-valued-point-expr}    | {str-valued-polygon-expr}   | \
                            {string-function-1arg} ({string-expression}) 3| \
                            {string-function-2args}({string-expression}, {string-expression}) 2| \
                                    REGEXP_POSITION({string-expression}, {string-expression}, {case-sensitivity})   | \
                            {string-function-3args}({string-expression}, {string-expression}, {string-expression}) 2| \
                            {string-function-4args}({string-expression}, {string-expression}, {string-expression}, {string-expression})

string-operator         ::= || | +
string-function-1arg    ::= LOWER  3| TRIM 3| UPPER 3| {string-udf-func-1arg}
string-function-2args   ::= CONCAT 4| REGEXP_POSITION 4| {string-udf-func-2args}
string-function-3args   ::= CONCAT 4| REPLACE 4| {string-udf-func-3args}
string-function-4args   ::= CONCAT 9| {string-udf-func-4args}
# Optional third argument for the REGEXP_POSITION function
case-sensitivity        ::= 'c' | 'i' | {string-expression}

string-udf-func-1arg    ::= reverse
string-udf-func-2args   ::= concat2Varchar | add2Varchar
string-udf-func-3args   ::= concat3Varchar
string-udf-func-4args   ::= concat4Varchar

# Some functions of a string produce an integer value
int-valued-string-func  ::= CHAR_LENGTH | OCTET_LENGTH
# POSITION is a special case, due to the use of the IN keyword
int-valued-string-expr  ::= {int-valued-string-func}({string-expression}) 2| POSITION({string-expression} IN {string-expression})

# Some functions of an integer produce a string value
string-valued-int-func  ::= BIN | CHAR | HEX | SPACE
string-valued-int-expr  ::= {string-valued-int-func}({int-expression})

# Some functions of a string and an integer (or 2) produce a string value
string-val-str-int-func ::= LEFT | RIGHT | SUBSTRING
# We only allow byte values in the REPEAT function, because giving it large values can
# freeze VoltDB, consume all CPU time, and slow down your machine to a crawl; see ENG-12118
string-val-str-byte-fun ::= REPEAT
string-val-str-2int-fun ::= SUBSTRING
string-val-str-int-expr ::= {string-val-str-int-func}({string-expression}, {int-expression})  3| \
                            {string-val-str-byte-fun}({string-expression}, {byte-expression})  | \
                            {string-val-str-2int-fun}({string-expression}, {int-expression},  {int-expression})

# One function of 2 numbers (1 decimal and 1 integer) produces string values
string-val-num-int-func ::= FORMAT_CURRENCY
# One function of 1, 2, or 3 numbers (1 decimal and 2 optional integers) produces string values
string-val-num-2int-fun ::= STR
string-val-num-int-expr ::= {string-val-num-int-func}({numeric-expression}, {int-expression}) | \
                            {string-val-num-2int-fun}({numeric-expression}) | \
                            {string-val-num-2int-fun}({numeric-expression}, {int-expression}) | \
                            {string-val-num-2int-fun}({numeric-expression}, {int-expression}, {int-expression})

# Some string functions use special keywords (e.g. PLACING, FROM, FOR)
string-special-func-expr::= OVERLAY({string-expression} PLACING {string-expression} FROM {int-expression} [FOR {int-expression}]) | \
                            SUBSTRING({string-expression} FROM {int-expression} [FOR {int-expression}]) | \
                            TRIM([[{trim-keyword} ]['{character}'] FROM ]{string-expression})
trim-keyword            ::= LEADING | TRAILING | BOTH

################################################################################
# Timestamp (date-time) constant values, functions, operators and expressions
#
month                   ::= 01 | 02 | 03 | 04 | 05 | 06 | 07 | 08 | 09 | 10 | 11 | 12
hour-more-than-12       ::= 13 | 14 | 15 | 16 | 17 | 18 | 19 | 20 | 21 | 22 | 23
digit-0-to-5            ::= 0 | 1 | 2 | 3 | 4 | 5
century                 ::= 18 | 19 | 20 | 21 | {digit}{digit}
year                    ::= {century}{digit}{digit}

# The "12" or "11" before the "|" makes those options more likely, making all
# valid day or hour values equally likely
day                     ::= {month} 12| {hour-more-than-12} 11| 24 | 25 | 26 | 27 | 28 | 29 | 30 | 31
hour                    ::= {month} 12| {hour-more-than-12} 11| 00
minute-or-second        ::= {digit-0-to-5}{digit}

# PostgreSQL-compatible version of the above: avoids April 31, February 29 in non-leap year, etc.
pg-day                  ::= {month} 12| {hour-more-than-12} 11| 24 | 25 | 26 | 27 | 28

timestamp-non-null-value::= '{year}-{month}-{day} {hour}:{minute-or-second}:{minute-or-second}[.{digit}{digit}{digit}]'

# The "3" before the "|" makes the "timestamp-non-null-value" option 3 times as
# likely as the NULL option, making NULL values less likely
timestamp-value         ::= {timestamp-non-null-value} 3| NULL

timestamp-expression    ::= {simple-timestamp-expr} 49| {timestamp-scalar-sub-q}
simple-timestamp-expr   ::= {timestamp-value} | [[[[{table-alias-or-name}.]]]]{timestamp-column-name} 6| \
                            {timestamp-function-expr}
timestamp-function-expr ::= {timestamp-func-0args} 4| \
                            FROM_UNIXTIME({int-expression}) | \
                            TO_TIMESTAMP({short-time-unit}, {int-expression}) | \
                            TRUNCATE({dateadd-time-unit}, {timestamp-expression}) | \
                            DATEADD({dateadd-time-unit}, {int-expression}, {timestamp-expression}) | \
                            {timestamp-udf-func-expr}
timestamp-func-0args    ::= CURRENT_TIMESTAMP[()]   | NOW[()] | \
                            MIN_VALID_TIMESTAMP[()] | MAX_VALID_TIMESTAMP[()]
timestamp-udf-func-expr ::= addYearsToTimestamp({timestamp-expression}, {int-expression})

# PostgreSQL-compatible version of the above: avoids presence or absence
# of parens not supported, as well as unsupported functions
pg-timestamp-func-0args ::= CURRENT_TIMESTAMP | NOW()
pg-timest-udf-func-expr ::= {pg-timestamp-func-0args}

# One function of a timestamp produces a boolean result
bool-val-timestamp-expr ::= IS_VALID_TIMESTAMP({timestamp-expression})

# Some functions of a timestamp produce an integer value
int-valued-time-func    ::= DAY | DAYOFMONTH | DAYOFWEEK | DAYOFYEAR | HOUR | MINUTE | \
                            MONTH | QUARTER | WEEK | WEEKOFYEAR | WEEKDAY | YEAR
int-valued-time-expr    ::= {int-valued-time-func}({timestamp-expression})

# One function of a timestamp produces a numeric (float) value
num-valued-time-func    ::= {int-valued-time-func} 3| SECOND
num-valued-time-expr    ::= {num-valued-time-func}({timestamp-expression})

# Some functions of a time-unit (string) and a timestamp produce an integer value
# (and EXTRACT optionally uses the special keyword FROM)
# Note: EXTRACT actually produces a decimal (not integer) when the SECOND time-unit is used,
# which may produce an error in some contexts, if an integer is expected - which is OK
int-valued-t-unit-expr  ::= SINCE_EPOCH({short-time-unit}, {timestamp-expression}) | \
                            EXTRACT({extract-time-unit}, {timestamp-expression}) | \
                            EXTRACT({extract-time-unit} FROM {timestamp-expression})

# Time units used in the definitions above:
long-time-unit          ::= YEAR | QUARTER | MONTH | DAY | HOUR | MINUTE | SECOND
short-time-unit         ::= SECOND | MILLISECOND | MILLIS | MICROSECOND | MICROS
special-time-unit       ::= DAY_OF_MONTH | DAY_OF_WEEK | DAY_OF_YEAR | WEEK | WEEK_OF_YEAR | WEEKDAY
extract-time-unit       ::= {long-time-unit} | {special-time-unit}
dateadd-time-unit       ::= {long-time-unit} | {short-time-unit}

################################################################################
# Varbinary (binary) constant values, functions, operators and expressions
#
hex-alphabetic-digit    ::= A | B | C | D | E | F | a | b | c | d | e | f
hex-digit               ::= {digit} 2| {hex-alphabetic-digit}
max4-hex-digits         ::= [[[{hex-digit}]{hex-digit}]{hex-digit}]{hex-digit}
eight-hex-digits        ::= {hex-digit}{hex-digit}{hex-digit}{hex-digit}{hex-digit}{hex-digit}{hex-digit}{hex-digit}
thirty-two-hex-digits   ::= {eight-hex-digits}{eight-hex-digits}{eight-hex-digits}{eight-hex-digits}
even-num-of-hex-digits  ::= {hex-digit}{hex-digit}[{even-num-of-hex-digits}]
varbinary-value         ::= x'{even-num-of-hex-digits}' 3| NULL

varbinary-expression    ::= {simple-varbinary-expr} 49| {varbinary-scalar-sub-q}
simple-varbinary-expr   ::= {varbinary-value} | [[[[{table-alias-or-name}.]]]]{varbinary-column-name} 6| \
                            {varbinary-function-expr}

varbinary-function-expr ::= {varbinary-udf-func-expr}
varbinary-udf-func-2args::= add2Varbinary | add2VarbinaryBoxed | btrim | btrimBoxed
varbinary-udf-func-expr ::= varbinary-udf-func-2args({varbinary-expression}, {varbinary-expression})

# Some functions of a varbinary produce a string value
string-valued-varb-func ::= BIN | CHAR | HEX | SPACE
string-valued-varb-expr ::= {string-valued-int-func}({int-expression})


################################################################################
# Special Internet address varbinary and string values, functions, operators
# and expressions used with the functions:
# INET6_ATON, INET6_NTOA, INET_ATON, INET_NTOA
# (If we called these functions on regular varbinary and string values, they
# would simply always give an error message, which would not test much.)
#
varbin-ipv4-value       ::= x'{eight-hex-digits}'      3| NULL
varbin-ipv6-value       ::= x'{thirty-two-hex-digits}' 3| NULL
string-ipv4-value       ::= '{zero-to-255}.{zero-to-255}.{zero-to-255}.{zero-to-255}' 3| NULL
string-ipv6-value       ::= '{max4-hex-digits}:[{max4-hex-digits}:[{max4-hex-digits}:[{max4-hex-digits}:{max4-hex-digits}]:{max4-hex-digits}]:{max4-hex-digits}]:{max4-hex-digits}' 3|  \
                            ':[{max4-hex-digits}:[{max4-hex-digits}:[{max4-hex-digits}:{max4-hex-digits}]:{max4-hex-digits}]:{max4-hex-digits}]:{max4-hex-digits}' | \
                            '{max4-hex-digits}:[{max4-hex-digits}:[{max4-hex-digits}:[{max4-hex-digits}:{max4-hex-digits}]:{max4-hex-digits}]:{max4-hex-digits}]:' | \
                            NULL

zero-to-255             ::= 25{zero-to-five} | 2{zero-to-four}{digit} 5| 1{digit}{digit} 10| \
                            {non-zero-digit}{digit} 9| {digit}
zero-or-one             ::= 0 | 1
zero-to-four            ::= {zero-or-one} 2| 2 | 3 | 4
zero-to-five            ::= {zero-to-four} 5| 5

varbin-ipv4-expression  ::= {varbin-ipv4-value} | [[[[{table-alias-or-name}.]]]]{varbin-ipv4-column-name} 6| \
                            {varbin-ipv4-func-expr}
varbin-ipv6-expression  ::= {varbin-ipv6-value} | [[[[{table-alias-or-name}.]]]]{varbin-ipv6-column-name} 6| \
                            {varbin-ipv6-func-expr}
varbin-ipv4-func-expr   ::= INET_ATON({string-ipv4-expression})
varbin-ipv6-func-expr   ::= INET6_ATON({string-ipv6-expression})

string-ipv4-expression  ::= {string-ipv4-value} | [[[[{table-alias-or-name}.]]]]{string-ipv4-column-name} 6| \
                            {string-ipv4-func-expr}
string-ipv6-expression  ::= {string-ipv6-value} | [[[[{table-alias-or-name}.]]]]{string-ipv6-column-name} 6| \
                            {string-ipv6-func-expr}
string-ipv4-func-expr   ::= INET_NTOA({varbin-ipv4-expression})
string-ipv6-func-expr   ::= INET6_NTOA({varbin-ipv6-expression})

################################################################################
# Geospatial Point constant values, functions, operators and expressions
#

digit-less-than-8       ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7
digit-less-than-9       ::= {digit-less-than-8} 8| 8
number-less-than-80     ::= {digit-less-than-8}[{digit}][.{non-negative-int-value}]
number-less-than-90     ::= {digit-less-than-9}[{digit}][.{non-negative-int-value}]
number-less-than-100    ::= {digit}[{digit}][.{non-negative-int-value}]

# Latitude is a number between -100 and 100 (exclusive); longitude is between
# -200 and 200 (exclusive); these include some illegal values, which is OK
latitude                ::= [-]{number-less-than-100}
longitude               ::= [-][1]{number-less-than-100}
point-non-null-value    ::= PointFromText('POINT({longitude} {latitude})')

# PostgreSQL-compatible version of the above: avoids differing treatment of illegal values:
# Latitude is a number between -90 and 90 (exclusive);
# longitude is between -180 and 180 (exclusive);
# illegal values not allowed, since they cause inconsistencies with PostgreSQL
pg-latitude             ::= [-]{number-less-than-90}
pg-longitude            ::= [-][1]{number-less-than-80}

# The "3" before the "|" makes the "point-non-null-value" option 3 times as
# likely as the NULL option, making NULL values less likely
point-value             ::= {point-non-null-value} 3| NULL

point-expression        ::= {simple-point-expr} 49| {point-scalar-sub-q}
simple-point-expr       ::= {point-value} | [[[[{table-alias-or-name}.]]]]{point-column-name} 6| \
                            {point-function-expr}
point-function-expr     ::= {simple-point-func-expr} 4| {point-udf-func-expr}
simple-point-func-expr  ::= CENTROID({polygon-expression}) | {point-non-null-value}
point-udf-func-expr     ::= add2GeographyPoint({point-expression}, {point-expression})

# Some functions of a point produce a string or numeric value
str-valued-point-expr   ::= AsText({point-expression})
num-valued-point-expr   ::= LATITUDE({point-expression}) | LONGITUDE({point-expression})

################################################################################
# Geospatial Polygon constant values, functions, operators and expressions
#

# About a quarter of these simple polygons will be defined clockwise, hence invalid
polygon-non-null-value  ::= {polygon-from-text}('POLYGON((0 0, {longitude} 0, 0 {latitude}, 0 0))') | \
                            {polygon-from-text}('POLYGON((-2 -2, 10 -2, -2 10, -2 -2),(-1 -1, -1 {digit}, {digit} -1, -1 -1))')
polygon-from-text       ::= PolygonFromText 3| ValidPolygonFromText

# The "3" before the "|" makes the "polygon-non-null-value" option 3 times as
# likely as the NULL option, making NULL values less likely
polygon-value           ::= {polygon-non-null-value} 3| NULL

# UDF TODO: add back something like this (here and elsewhere):
#polygon-expression      ::= {non-num-aggregate-func}({polygon-expression}) 9| ...

polygon-expression      ::= {simple-polygon-expr} 49| {polygon-scalar-sub-q}
simple-polygon-expr     ::= {polygon-value} | [[[[{table-alias-or-name}.]]]]{polygon-column-name} 6| \
                            {polygon-function-expr}
polygon-function-expr   ::= {simple-polygon-func-expr} 4| {polygon-udf-func-expr}
simple-polygon-func-expr::= {polygon-non-null-value}
polygon-udf-func-expr   ::= addGeographyPointToGeography({polygon-expression}, {point-expression})

# Some functions of a polygon produce a string or numeric value
str-valued-polygon-expr ::= AsText({polygon-expression}) | IsInvalidReason({polygon-expression})
int-valued-polygon-expr ::= NumPoints({polygon-expression}) | NumInteriorRings({polygon-expression})
num-valued-polygon-expr ::= {int-valued-polygon-expr} 2| {distance-function} 3| \
                            AREA({polygon-expression}) | {int-valued-polygon-udf}
distance-function       ::= DISTANCE({point-expression},   {point-expression})   3| \
                            DISTANCE({point-expression},   {polygon-expression}) 3| \
                            DISTANCE({polygon-expression}, {point-expression})   3| \
                            DISTANCE({polygon-expression}, {polygon-expression})
int-valued-polygon-udf  ::= NumRings({polygon-expression}) | NumPointsUdf({polygon-expression})

# Some functions of a polygon produce a boolean result
bool-valued-polygon-expr::= IsValid({polygon-expression}) | {dwithin-function} 2| \
                            CONTAINS({polygon-expression}, {point-expression})
dwithin-function        ::= DWITHIN({point-expression},   {point-expression},   {numeric-expression}) 3| \
                            DWITHIN({point-expression},   {polygon-expression}, {numeric-expression}) 3| \
                            DWITHIN({polygon-expression}, {point-expression},   {numeric-expression}) 3| \
                            DWITHIN({polygon-expression}, {polygon-expression}, {numeric-expression})

################################################################################
# Non-geospatial (ng-) alternative values of some of the above definitions, for
# use with SQLCoverage, to avoid issues with Geospatial types (point & polygon,
# i.e. GEOGRAPHY_POINT & GEOGRAPHY); these definitions are largely the same,
# but with the points and polygons [and varbinary?] left out, or NULL
#
# Note: this section is not currently used, though it may be used in the future,
# in a version that feeds queries to SQLCoverage (see ENG-10240); though more
# likely it will be replaced by the various 'pg-...' definitions above.

ng-non-int-str-column-name ::= {timestamp-column-name} | {varbinary-column-name} | {int-column-name}

ng-random-type-value       ::= {integer-value} | {numeric-value} | {string-value} | {timestamp-value} | \
                               {varbinary-value}
ng-in-or-up-sert-values    ::= {insert-values-id-num}    | {insert-values-id-str}   | {insert-values-id-time} | \
                               {insert-values-id-varbin} | \
                               {insert-values-multiple}  | {insert-values-all}      | {insert-values-backward}
ng-in-or-up-sert-select    ::= {insert-select-id-num}    | {insert-select-id-str}   | {insert-select-id-time} | \
                               {insert-select-id-varbin} | \
                               {insert-select-multiple}  | {insert-select-all}      | {insert-select-backward}
ng-insert-values-multiple  ::= SERT INTO {table-name} (ID, {numeric-column-name}, {string-column-name}, {timestamp-column-name}, \
                               {varbinary-column-name} ) VALUES ({integer-non-null-value}, \
                               {numeric-value}, {string-value}, {timestamp-value}, {varbinary-value} )
ng-insert-values-all       ::= SERT INTO {table-name} ( \
                               ID, TINY, SMALL, INT, BIG, NUM, DEC, VCHAR, VCHAR_INLINE_MAX, VCHAR_INLINE, TIME, VARBIN \
                               ) VALUES ( {integer-non-null-value}, {byte-value}, {integer-value}, {integer-value}, {integer-value}, \
                               {numeric-value}, {numeric-value}, {string-value}, {string-value}, {string-value}, {timestamp-value}, \
                               {varbinary-value} )
ng-insert-values-backward  ::= SERT INTO {table-name} ( \
                               VARBIN, TIME, VCHAR_INLINE, VCHAR_INLINE_MAX, VCHAR, DEC, NUM, BIG, INT, SMALL, TINY, ID \
                               ) VALUES ( {varbinary-value}, {timestamp-value}, {string-value}, \
                               {string-value}, {string-value}, {numeric-value}, {numeric-value}, {integer-value}, {integer-value}, \
                               {integer-value}, {byte-value}, {integer-non-null-value} )
ng-insert-select-multiple  ::= SERT INTO {table-name} ( ID, {numeric-column-name}, {string-column-name}, {timestamp-column-name}, \
                               {varbinary-column-name} ) SELECT {int-column-name}, \
                               {numeric-column-name}, {string-column-name}, {timestamp-column-name}, {varbinary-column-name} \
                               FROM {table-reference}
ng-insert-select-all       ::= SERT INTO {table-name} ( \
                               ID, TINY, SMALL, INT, BIG, NUM, DEC, VCHAR, VCHAR_INLINE_MAX, VCHAR_INLINE, TIME, VARBIN ) SELECT \
                               ID, TINY, SMALL, INT, BIG, NUM, DEC, VCHAR, VCHAR_INLINE_MAX, VCHAR_INLINE, TIME, VARBIN FROM {table-reference}
ng-insert-select-backward  ::= SERT INTO {table-name} ( \
                               VARBIN, TIME, VCHAR_INLINE, VCHAR_INLINE_MAX, VCHAR, DEC, NUM, BIG, INT, SMALL, TINY, ID ) SELECT \
                               VARBIN, TIME, VCHAR_INLINE, VCHAR_INLINE_MAX, VCHAR, DEC, NUM, BIG, INT, SMALL, TINY, ID FROM {table-reference}
ng-star                    ::= ID, TINY, SMALL, INT, BIG, NUM, DEC, VCHAR, VCHAR_INLINE_MAX, VCHAR_INLINE, TIME, VARBIN
ng-point-value             ::= NULL
ng-polygon-value           ::= NULL


################################################################################
# TODO: we probably should eventually combine the sql-ddl-grammar.txt file with
# this one (i.e., copy it to here), but what follows are the only sections that
# we need so far (formerly in that file but moved here).

################################################################################
# Grammar rules for CREATE PROCEDURE AS statements:
#
# TODO: eventually uncomment the ALLOW {role-name-list} clause (after defining
# role-name-list, and dealing with roles generally)
################################################################################
create-proc-as-statement::= CREATE PROCEDURE {random-proc-0params} \
                            [PARTITION ON TABLE {table-name} COLUMN {column-name} [PARAMETER {digit}]] \
#                           [[[ALLOW {role-name-list}]]] \
                            AS {sql-statement}

# This version drops a procedure first (if it exists), before creating a new
# one using the same procedure name, so this is more likely to be valid
drop-create-proc-stmnt  ::= DROP PROCEDURE {random-proc-0params:p0} IF EXISTS; \
                            CREATE PROCEDURE {:p0} \
                            [PARTITION ON TABLE {table-name} COLUMN {column-name} [PARAMETER {digit}]] \
#                           [[[ALLOW {role-name-list}]]] \
                            AS {sql-statement}

################################################################################
# Grammar rules for all DROP statements, i.e., DROP TABLE, DROP VIEW,
# DROP INDEX, and DROP PROCEDURE statements:
################################################################################
drop-statement          ::= {drop-table-statement} | {drop-view-statement} | \
                            {drop-index-statement} | {drop-proc-statement}
drop-table-statement    ::= DROP TABLE {table-name} [[IF EXISTS]] [[CASCADE]]
drop-view-statement     ::= DROP VIEW  {view-name}   [IF EXISTS]
drop-index-statement    ::= DROP INDEX {index-name}  [IF EXISTS]
drop-proc-statement     ::= DROP PROCEDURE {random-proc-0params} [IF EXISTS]
