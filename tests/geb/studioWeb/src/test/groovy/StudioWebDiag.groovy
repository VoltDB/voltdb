import geb.*
import geb.spock.*
import geb.driver.CachingDriverFactory
import org.openqa.selenium.interactions.Actions
import spock.lang.*

class StudioWebPage extends Page {

    static url = 'file://localhost/' + new File("../../../obj/release/dist/tools/studio.web/index.htm").getCanonicalPath()
    static at = { title == "VoltDB Web Studio" }
}

class StudioWebDiag extends GebReportingSpec {

    ////specify paths to files with correct elements////
    def prgrm = $("span", text: "Programmability")
    def eleFile = new File("src/test/resources/elems.txt")
    def procFile = new File("src/test/resources/storedProcs.txt")
    def correctReadme = new File("src/test/resources/readme.htm")
    def chkReadme = new File("../../../obj/release/dist/tools/studio.web/readme.htm")

    ////// Server MUST have been initialized//////

    def "To StudioWeb"() {

        setup: "Open Studio web"
        to StudioWebPage

        expect: "to be on studio web page"
        at StudioWebPage
    }

    def "Contains important elements"(){

        setup: "Get elements from page"
        def chk = $('[id]:not(canvas)').collect {"${ it.attr("id") }"}
        //important elements identified by ID. List of id's returned
        //ignores canvas elements generated by firefoxDriver

        expect: "compare page contents to file contents and expect them to be the same"
        assert chkElements(chk, eleFile)
    }

    def "Connect to server"(){

        when: "connect button is clicked"
        $("span.connect").click()

        then: "test connection"
        $("span.ui-button-text", text: "Test Connection").click()

        then: "wait for server response"
        waitFor {$("td.validateTips").text().contains("successful") | $("td.validateTips").text().contains("Unable")}

        then: "get server state"
        def state = $("td.validateTips").text()

        when: "if server available"
        state.contains("successful")

        then: "connect to server"
        $("span.ui-button-text", text: "OK").click() //OK button
    }

    def "Check readMe file"(){

        expect: "them to be the same"
        assert correctReadme.getText() == chkReadme.getText() & correctReadme.size() != 0 
    }

    def "System Stored Procedures"(){

        setup: "make stored procedures visible"
        expandFolds()

        and: "obtain their locations and make list of their text"
        def procs = prgrm.siblings().find("li",0).find("li",0).find("ul", 0).children().children("span")*.text()

        and: "expect them to be the same (no extras, none missing)"
        assert chkElements(procs, procFile)
    }

    def "Disconnect from server"(){
        
        setup: "Actions interface to enable right click"
        def actions = new Actions(this.getDriver())

        and: "find element in sidebar to right click"
        def clickMe = prgrm.firstElement()

        when: "context menu is brought up"
        actions.contextClick(clickMe).build().perform()

        then: "find disconnect option"
        def disconn = $("ul", id: "objectbrowsermenu").find("li.disconnect").find("a")

        when: "disconnect is visible"
        disconn.isDisplayed()

        then: "click to disconnect from server"
        disconn.click()

        and: "expect server content to be unavailable"
        assert $("ul#dbbrowser.treeview").children().isEmpty()
    }

    def cleanupSpec(){}

    void expandFolds(){
        def fold1 = prgrm.siblings("div")
        def fold2 = fold1.siblings().find("li",0).children("div")
        def fold3 = fold2.siblings().find("li",0).children("div")
        [fold1, fold2, fold3]*.click() //open each folder
    }

    def chkElements(def eles, def file){

        def correct = []
        if(file.size() == 0){file.withWriter {out -> eles.each {out.writeLine(it)} } }
        file.eachLine {correct.add(it)}
        correct == eles
        /* items are retrieved in nondeterministic order due to potential changes to webpage.
        The test fails when this happens to indicate need for update */   
    }
}
